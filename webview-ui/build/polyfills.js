"use strict";(self.webpackChunkwebview_ui=self.webpackChunkwebview_ui||[]).push([[429],{435:(__unused_webpack_module,__unused_webpack___webpack_exports__,__webpack_require__)=>{eval(__webpack_require__.ts("/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(583);\n/* harmony import */ var zone_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(zone_js__WEBPACK_IMPORTED_MODULE_0__);\n/**\r\n * This file includes polyfills needed by Angular and is loaded before the app.\r\n * You can add your own extra polyfills to this file.\r\n *\r\n * This file is divided into 2 sections:\r\n *   1. Browser polyfills. These are applied before loading ZoneJS and are sorted by browsers.\r\n *   2. Application imports. Files imported after ZoneJS that should be loaded before your main\r\n *      file.\r\n *\r\n * The current setup is for so-called \"evergreen\" browsers; the last versions of browsers that\r\n * automatically update themselves. This includes recent versions of Safari, Chrome (including\r\n * Opera), Edge on the desktop, and iOS and Chrome on mobile.\r\n *\r\n * Learn more in https://angular.io/guide/browser-support\r\n */\n\n/***************************************************************************************************\r\n * BROWSER POLYFILLS\r\n */\n\n/**\r\n * By default, zone.js will patch all possible macroTask and DomEvents\r\n * user can disable parts of macroTask/DomEvents patch by setting following flags\r\n * because those flags need to be set before `zone.js` being loaded, and webpack\r\n * will put import in the top of bundle, so user need to create a separate file\r\n * in this directory (for example: zone-flags.ts), and put the following flags\r\n * into that file, and then add the following code before importing zone.js.\r\n * import './zone-flags';\r\n *\r\n * The flags allowed in zone-flags.ts are listed here.\r\n *\r\n * The following flags will work for all browsers.\r\n *\r\n * (window as any).__Zone_disable_requestAnimationFrame = true; // disable patch requestAnimationFrame\r\n * (window as any).__Zone_disable_on_property = true; // disable patch onProperty such as onclick\r\n * (window as any).__zone_symbol__UNPATCHED_EVENTS = ['scroll', 'mousemove']; // disable patch specified eventNames\r\n *\r\n *  in IE/Edge developer tools, the addEventListener will also be wrapped by zone.js\r\n *  with the following flag, it will bypass `zone.js` patch for IE/Edge\r\n *\r\n *  (window as any).__Zone_enable_cross_context_check = true;\r\n *\r\n */\n\n/***************************************************************************************************\r\n * Zone JS is required by default for Angular itself.\r\n */\n // Included with Angular CLI.\n\n/***************************************************************************************************\r\n * APPLICATION IMPORTS\r\n *///# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiNDM1LmpzIiwibWFwcGluZ3MiOiI7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtDQUNrQjs7QUFDbEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2Vidmlldy11aS8uL3NyYy9wb2x5ZmlsbHMudHM/ZmNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogVGhpcyBmaWxlIGluY2x1ZGVzIHBvbHlmaWxscyBuZWVkZWQgYnkgQW5ndWxhciBhbmQgaXMgbG9hZGVkIGJlZm9yZSB0aGUgYXBwLlxyXG4gKiBZb3UgY2FuIGFkZCB5b3VyIG93biBleHRyYSBwb2x5ZmlsbHMgdG8gdGhpcyBmaWxlLlxyXG4gKlxyXG4gKiBUaGlzIGZpbGUgaXMgZGl2aWRlZCBpbnRvIDIgc2VjdGlvbnM6XHJcbiAqICAgMS4gQnJvd3NlciBwb2x5ZmlsbHMuIFRoZXNlIGFyZSBhcHBsaWVkIGJlZm9yZSBsb2FkaW5nIFpvbmVKUyBhbmQgYXJlIHNvcnRlZCBieSBicm93c2Vycy5cclxuICogICAyLiBBcHBsaWNhdGlvbiBpbXBvcnRzLiBGaWxlcyBpbXBvcnRlZCBhZnRlciBab25lSlMgdGhhdCBzaG91bGQgYmUgbG9hZGVkIGJlZm9yZSB5b3VyIG1haW5cclxuICogICAgICBmaWxlLlxyXG4gKlxyXG4gKiBUaGUgY3VycmVudCBzZXR1cCBpcyBmb3Igc28tY2FsbGVkIFwiZXZlcmdyZWVuXCIgYnJvd3NlcnM7IHRoZSBsYXN0IHZlcnNpb25zIG9mIGJyb3dzZXJzIHRoYXRcclxuICogYXV0b21hdGljYWxseSB1cGRhdGUgdGhlbXNlbHZlcy4gVGhpcyBpbmNsdWRlcyByZWNlbnQgdmVyc2lvbnMgb2YgU2FmYXJpLCBDaHJvbWUgKGluY2x1ZGluZ1xyXG4gKiBPcGVyYSksIEVkZ2Ugb24gdGhlIGRlc2t0b3AsIGFuZCBpT1MgYW5kIENocm9tZSBvbiBtb2JpbGUuXHJcbiAqXHJcbiAqIExlYXJuIG1vcmUgaW4gaHR0cHM6Ly9hbmd1bGFyLmlvL2d1aWRlL2Jyb3dzZXItc3VwcG9ydFxyXG4gKi9cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBCUk9XU0VSIFBPTFlGSUxMU1xyXG4gKi9cclxuLyoqXHJcbiAqIEJ5IGRlZmF1bHQsIHpvbmUuanMgd2lsbCBwYXRjaCBhbGwgcG9zc2libGUgbWFjcm9UYXNrIGFuZCBEb21FdmVudHNcclxuICogdXNlciBjYW4gZGlzYWJsZSBwYXJ0cyBvZiBtYWNyb1Rhc2svRG9tRXZlbnRzIHBhdGNoIGJ5IHNldHRpbmcgZm9sbG93aW5nIGZsYWdzXHJcbiAqIGJlY2F1c2UgdGhvc2UgZmxhZ3MgbmVlZCB0byBiZSBzZXQgYmVmb3JlIGB6b25lLmpzYCBiZWluZyBsb2FkZWQsIGFuZCB3ZWJwYWNrXHJcbiAqIHdpbGwgcHV0IGltcG9ydCBpbiB0aGUgdG9wIG9mIGJ1bmRsZSwgc28gdXNlciBuZWVkIHRvIGNyZWF0ZSBhIHNlcGFyYXRlIGZpbGVcclxuICogaW4gdGhpcyBkaXJlY3RvcnkgKGZvciBleGFtcGxlOiB6b25lLWZsYWdzLnRzKSwgYW5kIHB1dCB0aGUgZm9sbG93aW5nIGZsYWdzXHJcbiAqIGludG8gdGhhdCBmaWxlLCBhbmQgdGhlbiBhZGQgdGhlIGZvbGxvd2luZyBjb2RlIGJlZm9yZSBpbXBvcnRpbmcgem9uZS5qcy5cclxuICogaW1wb3J0ICcuL3pvbmUtZmxhZ3MnO1xyXG4gKlxyXG4gKiBUaGUgZmxhZ3MgYWxsb3dlZCBpbiB6b25lLWZsYWdzLnRzIGFyZSBsaXN0ZWQgaGVyZS5cclxuICpcclxuICogVGhlIGZvbGxvd2luZyBmbGFncyB3aWxsIHdvcmsgZm9yIGFsbCBicm93c2Vycy5cclxuICpcclxuICogKHdpbmRvdyBhcyBhbnkpLl9fWm9uZV9kaXNhYmxlX3JlcXVlc3RBbmltYXRpb25GcmFtZSA9IHRydWU7IC8vIGRpc2FibGUgcGF0Y2ggcmVxdWVzdEFuaW1hdGlvbkZyYW1lXHJcbiAqICh3aW5kb3cgYXMgYW55KS5fX1pvbmVfZGlzYWJsZV9vbl9wcm9wZXJ0eSA9IHRydWU7IC8vIGRpc2FibGUgcGF0Y2ggb25Qcm9wZXJ0eSBzdWNoIGFzIG9uY2xpY2tcclxuICogKHdpbmRvdyBhcyBhbnkpLl9fem9uZV9zeW1ib2xfX1VOUEFUQ0hFRF9FVkVOVFMgPSBbJ3Njcm9sbCcsICdtb3VzZW1vdmUnXTsgLy8gZGlzYWJsZSBwYXRjaCBzcGVjaWZpZWQgZXZlbnROYW1lc1xyXG4gKlxyXG4gKiAgaW4gSUUvRWRnZSBkZXZlbG9wZXIgdG9vbHMsIHRoZSBhZGRFdmVudExpc3RlbmVyIHdpbGwgYWxzbyBiZSB3cmFwcGVkIGJ5IHpvbmUuanNcclxuICogIHdpdGggdGhlIGZvbGxvd2luZyBmbGFnLCBpdCB3aWxsIGJ5cGFzcyBgem9uZS5qc2AgcGF0Y2ggZm9yIElFL0VkZ2VcclxuICpcclxuICogICh3aW5kb3cgYXMgYW55KS5fX1pvbmVfZW5hYmxlX2Nyb3NzX2NvbnRleHRfY2hlY2sgPSB0cnVlO1xyXG4gKlxyXG4gKi9cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBab25lIEpTIGlzIHJlcXVpcmVkIGJ5IGRlZmF1bHQgZm9yIEFuZ3VsYXIgaXRzZWxmLlxyXG4gKi9cclxuaW1wb3J0ICd6b25lLmpzJzsgLy8gSW5jbHVkZWQgd2l0aCBBbmd1bGFyIENMSS5cclxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG4gKiBBUFBMSUNBVElPTiBJTVBPUlRTXHJcbiAqL1xyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///435\n"))},583:(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval(__webpack_require__.ts("\n/**\n * @license Angular v14.2.0-next.0\n * (c) 2010-2022 Google LLC. https://angular.io/\n * License: MIT\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n(function (global) {\n  const performance = global['performance'];\n\n  function mark(name) {\n    performance && performance['mark'] && performance['mark'](name);\n  }\n\n  function performanceMeasure(name, label) {\n    performance && performance['measure'] && performance['measure'](name, label);\n  }\n\n  mark('Zone'); // Initialize before it's accessed below.\n  // __Zone_symbol_prefix global can be used to override the default zone\n  // symbol prefix with a custom one if needed.\n\n  const symbolPrefix = global['__Zone_symbol_prefix'] || '__zone_symbol__';\n\n  function __symbol__(name) {\n    return symbolPrefix + name;\n  }\n\n  const checkDuplicate = global[__symbol__('forceDuplicateZoneCheck')] === true;\n\n  if (global['Zone']) {\n    // if global['Zone'] already exists (maybe zone.js was already loaded or\n    // some other lib also registered a global object named Zone), we may need\n    // to throw an error, but sometimes user may not want this error.\n    // For example,\n    // we have two web pages, page1 includes zone.js, page2 doesn't.\n    // and the 1st time user load page1 and page2, everything work fine,\n    // but when user load page2 again, error occurs because global['Zone'] already exists.\n    // so we add a flag to let user choose whether to throw this error or not.\n    // By default, if existing Zone is from zone.js, we will not throw the error.\n    if (checkDuplicate || typeof global['Zone'].__symbol__ !== 'function') {\n      throw new Error('Zone already loaded.');\n    } else {\n      return global['Zone'];\n    }\n  }\n\n  let Zone = /*#__PURE__*/(() => {\n    class Zone {\n      constructor(parent, zoneSpec) {\n        this._parent = parent;\n        this._name = zoneSpec ? zoneSpec.name || 'unnamed' : '<root>';\n        this._properties = zoneSpec && zoneSpec.properties || {};\n        this._zoneDelegate = new _ZoneDelegate(this, this._parent && this._parent._zoneDelegate, zoneSpec);\n      }\n\n      static assertZonePatched() {\n        if (global['Promise'] !== patches['ZoneAwarePromise']) {\n          throw new Error('Zone.js has detected that ZoneAwarePromise `(window|global).Promise` ' + 'has been overwritten.\\n' + 'Most likely cause is that a Promise polyfill has been loaded ' + 'after Zone.js (Polyfilling Promise api is not necessary when zone.js is loaded. ' + 'If you must load one, do so before loading zone.js.)');\n        }\n      }\n\n      static get root() {\n        let zone = Zone.current;\n\n        while (zone.parent) {\n          zone = zone.parent;\n        }\n\n        return zone;\n      }\n\n      static get current() {\n        return _currentZoneFrame.zone;\n      }\n\n      static get currentTask() {\n        return _currentTask;\n      } // tslint:disable-next-line:require-internal-with-underscore\n\n\n      static __load_patch(name, fn, ignoreDuplicate = false) {\n        if (patches.hasOwnProperty(name)) {\n          // `checkDuplicate` option is defined from global variable\n          // so it works for all modules.\n          // `ignoreDuplicate` can work for the specified module\n          if (!ignoreDuplicate && checkDuplicate) {\n            throw Error('Already loaded patch: ' + name);\n          }\n        } else if (!global['__Zone_disable_' + name]) {\n          const perfName = 'Zone:' + name;\n          mark(perfName);\n          patches[name] = fn(global, Zone, _api);\n          performanceMeasure(perfName, perfName);\n        }\n      }\n\n      get parent() {\n        return this._parent;\n      }\n\n      get name() {\n        return this._name;\n      }\n\n      get(key) {\n        const zone = this.getZoneWith(key);\n        if (zone) return zone._properties[key];\n      }\n\n      getZoneWith(key) {\n        let current = this;\n\n        while (current) {\n          if (current._properties.hasOwnProperty(key)) {\n            return current;\n          }\n\n          current = current._parent;\n        }\n\n        return null;\n      }\n\n      fork(zoneSpec) {\n        if (!zoneSpec) throw new Error('ZoneSpec required!');\n        return this._zoneDelegate.fork(this, zoneSpec);\n      }\n\n      wrap(callback, source) {\n        if (typeof callback !== 'function') {\n          throw new Error('Expecting function got: ' + callback);\n        }\n\n        const _callback = this._zoneDelegate.intercept(this, callback, source);\n\n        const zone = this;\n        return function () {\n          return zone.runGuarded(_callback, this, arguments, source);\n        };\n      }\n\n      run(callback, applyThis, applyArgs, source) {\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n\n        try {\n          return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n        } finally {\n          _currentZoneFrame = _currentZoneFrame.parent;\n        }\n      }\n\n      runGuarded(callback, applyThis = null, applyArgs, source) {\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n\n        try {\n          try {\n            return this._zoneDelegate.invoke(this, callback, applyThis, applyArgs, source);\n          } catch (error) {\n            if (this._zoneDelegate.handleError(this, error)) {\n              throw error;\n            }\n          }\n        } finally {\n          _currentZoneFrame = _currentZoneFrame.parent;\n        }\n      }\n\n      runTask(task, applyThis, applyArgs) {\n        if (task.zone != this) {\n          throw new Error('A task can only be run in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n        } // https://github.com/angular/zone.js/issues/778, sometimes eventTask\n        // will run in notScheduled(canceled) state, we should not try to\n        // run such kind of task but just return\n\n\n        if (task.state === notScheduled && (task.type === eventTask || task.type === macroTask)) {\n          return;\n        }\n\n        const reEntryGuard = task.state != running;\n        reEntryGuard && task._transitionTo(running, scheduled);\n        task.runCount++;\n        const previousTask = _currentTask;\n        _currentTask = task;\n        _currentZoneFrame = {\n          parent: _currentZoneFrame,\n          zone: this\n        };\n\n        try {\n          if (task.type == macroTask && task.data && !task.data.isPeriodic) {\n            task.cancelFn = undefined;\n          }\n\n          try {\n            return this._zoneDelegate.invokeTask(this, task, applyThis, applyArgs);\n          } catch (error) {\n            if (this._zoneDelegate.handleError(this, error)) {\n              throw error;\n            }\n          }\n        } finally {\n          // if the task's state is notScheduled or unknown, then it has already been cancelled\n          // we should not reset the state to scheduled\n          if (task.state !== notScheduled && task.state !== unknown) {\n            if (task.type == eventTask || task.data && task.data.isPeriodic) {\n              reEntryGuard && task._transitionTo(scheduled, running);\n            } else {\n              task.runCount = 0;\n\n              this._updateTaskCount(task, -1);\n\n              reEntryGuard && task._transitionTo(notScheduled, running, notScheduled);\n            }\n          }\n\n          _currentZoneFrame = _currentZoneFrame.parent;\n          _currentTask = previousTask;\n        }\n      }\n\n      scheduleTask(task) {\n        if (task.zone && task.zone !== this) {\n          // check if the task was rescheduled, the newZone\n          // should not be the children of the original zone\n          let newZone = this;\n\n          while (newZone) {\n            if (newZone === task.zone) {\n              throw Error(`can not reschedule task to ${this.name} which is descendants of the original zone ${task.zone.name}`);\n            }\n\n            newZone = newZone.parent;\n          }\n        }\n\n        task._transitionTo(scheduling, notScheduled);\n\n        const zoneDelegates = [];\n        task._zoneDelegates = zoneDelegates;\n        task._zone = this;\n\n        try {\n          task = this._zoneDelegate.scheduleTask(this, task);\n        } catch (err) {\n          // should set task's state to unknown when scheduleTask throw error\n          // because the err may from reschedule, so the fromState maybe notScheduled\n          task._transitionTo(unknown, scheduling, notScheduled); // TODO: @JiaLiPassion, should we check the result from handleError?\n\n\n          this._zoneDelegate.handleError(this, err);\n\n          throw err;\n        }\n\n        if (task._zoneDelegates === zoneDelegates) {\n          // we have to check because internally the delegate can reschedule the task.\n          this._updateTaskCount(task, 1);\n        }\n\n        if (task.state == scheduling) {\n          task._transitionTo(scheduled, scheduling);\n        }\n\n        return task;\n      }\n\n      scheduleMicroTask(source, callback, data, customSchedule) {\n        return this.scheduleTask(new ZoneTask(microTask, source, callback, data, customSchedule, undefined));\n      }\n\n      scheduleMacroTask(source, callback, data, customSchedule, customCancel) {\n        return this.scheduleTask(new ZoneTask(macroTask, source, callback, data, customSchedule, customCancel));\n      }\n\n      scheduleEventTask(source, callback, data, customSchedule, customCancel) {\n        return this.scheduleTask(new ZoneTask(eventTask, source, callback, data, customSchedule, customCancel));\n      }\n\n      cancelTask(task) {\n        if (task.zone != this) throw new Error('A task can only be cancelled in the zone of creation! (Creation: ' + (task.zone || NO_ZONE).name + '; Execution: ' + this.name + ')');\n\n        task._transitionTo(canceling, scheduled, running);\n\n        try {\n          this._zoneDelegate.cancelTask(this, task);\n        } catch (err) {\n          // if error occurs when cancelTask, transit the state to unknown\n          task._transitionTo(unknown, canceling);\n\n          this._zoneDelegate.handleError(this, err);\n\n          throw err;\n        }\n\n        this._updateTaskCount(task, -1);\n\n        task._transitionTo(notScheduled, canceling);\n\n        task.runCount = 0;\n        return task;\n      }\n\n      _updateTaskCount(task, count) {\n        const zoneDelegates = task._zoneDelegates;\n\n        if (count == -1) {\n          task._zoneDelegates = null;\n        }\n\n        for (let i = 0; i < zoneDelegates.length; i++) {\n          zoneDelegates[i]._updateTaskCount(task.type, count);\n        }\n      }\n\n    }\n\n    // tslint:disable-next-line:require-internal-with-underscore\n    Zone.__symbol__ = __symbol__;\n    return Zone;\n  })();\n  const DELEGATE_ZS = {\n    name: '',\n    onHasTask: (delegate, _, target, hasTaskState) => delegate.hasTask(target, hasTaskState),\n    onScheduleTask: (delegate, _, target, task) => delegate.scheduleTask(target, task),\n    onInvokeTask: (delegate, _, target, task, applyThis, applyArgs) => delegate.invokeTask(target, task, applyThis, applyArgs),\n    onCancelTask: (delegate, _, target, task) => delegate.cancelTask(target, task)\n  };\n\n  class _ZoneDelegate {\n    constructor(zone, parentDelegate, zoneSpec) {\n      this._taskCounts = {\n        'microTask': 0,\n        'macroTask': 0,\n        'eventTask': 0\n      };\n      this.zone = zone;\n      this._parentDelegate = parentDelegate;\n      this._forkZS = zoneSpec && (zoneSpec && zoneSpec.onFork ? zoneSpec : parentDelegate._forkZS);\n      this._forkDlgt = zoneSpec && (zoneSpec.onFork ? parentDelegate : parentDelegate._forkDlgt);\n      this._forkCurrZone = zoneSpec && (zoneSpec.onFork ? this.zone : parentDelegate._forkCurrZone);\n      this._interceptZS = zoneSpec && (zoneSpec.onIntercept ? zoneSpec : parentDelegate._interceptZS);\n      this._interceptDlgt = zoneSpec && (zoneSpec.onIntercept ? parentDelegate : parentDelegate._interceptDlgt);\n      this._interceptCurrZone = zoneSpec && (zoneSpec.onIntercept ? this.zone : parentDelegate._interceptCurrZone);\n      this._invokeZS = zoneSpec && (zoneSpec.onInvoke ? zoneSpec : parentDelegate._invokeZS);\n      this._invokeDlgt = zoneSpec && (zoneSpec.onInvoke ? parentDelegate : parentDelegate._invokeDlgt);\n      this._invokeCurrZone = zoneSpec && (zoneSpec.onInvoke ? this.zone : parentDelegate._invokeCurrZone);\n      this._handleErrorZS = zoneSpec && (zoneSpec.onHandleError ? zoneSpec : parentDelegate._handleErrorZS);\n      this._handleErrorDlgt = zoneSpec && (zoneSpec.onHandleError ? parentDelegate : parentDelegate._handleErrorDlgt);\n      this._handleErrorCurrZone = zoneSpec && (zoneSpec.onHandleError ? this.zone : parentDelegate._handleErrorCurrZone);\n      this._scheduleTaskZS = zoneSpec && (zoneSpec.onScheduleTask ? zoneSpec : parentDelegate._scheduleTaskZS);\n      this._scheduleTaskDlgt = zoneSpec && (zoneSpec.onScheduleTask ? parentDelegate : parentDelegate._scheduleTaskDlgt);\n      this._scheduleTaskCurrZone = zoneSpec && (zoneSpec.onScheduleTask ? this.zone : parentDelegate._scheduleTaskCurrZone);\n      this._invokeTaskZS = zoneSpec && (zoneSpec.onInvokeTask ? zoneSpec : parentDelegate._invokeTaskZS);\n      this._invokeTaskDlgt = zoneSpec && (zoneSpec.onInvokeTask ? parentDelegate : parentDelegate._invokeTaskDlgt);\n      this._invokeTaskCurrZone = zoneSpec && (zoneSpec.onInvokeTask ? this.zone : parentDelegate._invokeTaskCurrZone);\n      this._cancelTaskZS = zoneSpec && (zoneSpec.onCancelTask ? zoneSpec : parentDelegate._cancelTaskZS);\n      this._cancelTaskDlgt = zoneSpec && (zoneSpec.onCancelTask ? parentDelegate : parentDelegate._cancelTaskDlgt);\n      this._cancelTaskCurrZone = zoneSpec && (zoneSpec.onCancelTask ? this.zone : parentDelegate._cancelTaskCurrZone);\n      this._hasTaskZS = null;\n      this._hasTaskDlgt = null;\n      this._hasTaskDlgtOwner = null;\n      this._hasTaskCurrZone = null;\n      const zoneSpecHasTask = zoneSpec && zoneSpec.onHasTask;\n      const parentHasTask = parentDelegate && parentDelegate._hasTaskZS;\n\n      if (zoneSpecHasTask || parentHasTask) {\n        // If we need to report hasTask, than this ZS needs to do ref counting on tasks. In such\n        // a case all task related interceptors must go through this ZD. We can't short circuit it.\n        this._hasTaskZS = zoneSpecHasTask ? zoneSpec : DELEGATE_ZS;\n        this._hasTaskDlgt = parentDelegate;\n        this._hasTaskDlgtOwner = this;\n        this._hasTaskCurrZone = zone;\n\n        if (!zoneSpec.onScheduleTask) {\n          this._scheduleTaskZS = DELEGATE_ZS;\n          this._scheduleTaskDlgt = parentDelegate;\n          this._scheduleTaskCurrZone = this.zone;\n        }\n\n        if (!zoneSpec.onInvokeTask) {\n          this._invokeTaskZS = DELEGATE_ZS;\n          this._invokeTaskDlgt = parentDelegate;\n          this._invokeTaskCurrZone = this.zone;\n        }\n\n        if (!zoneSpec.onCancelTask) {\n          this._cancelTaskZS = DELEGATE_ZS;\n          this._cancelTaskDlgt = parentDelegate;\n          this._cancelTaskCurrZone = this.zone;\n        }\n      }\n    }\n\n    fork(targetZone, zoneSpec) {\n      return this._forkZS ? this._forkZS.onFork(this._forkDlgt, this.zone, targetZone, zoneSpec) : new Zone(targetZone, zoneSpec);\n    }\n\n    intercept(targetZone, callback, source) {\n      return this._interceptZS ? this._interceptZS.onIntercept(this._interceptDlgt, this._interceptCurrZone, targetZone, callback, source) : callback;\n    }\n\n    invoke(targetZone, callback, applyThis, applyArgs, source) {\n      return this._invokeZS ? this._invokeZS.onInvoke(this._invokeDlgt, this._invokeCurrZone, targetZone, callback, applyThis, applyArgs, source) : callback.apply(applyThis, applyArgs);\n    }\n\n    handleError(targetZone, error) {\n      return this._handleErrorZS ? this._handleErrorZS.onHandleError(this._handleErrorDlgt, this._handleErrorCurrZone, targetZone, error) : true;\n    }\n\n    scheduleTask(targetZone, task) {\n      let returnTask = task;\n\n      if (this._scheduleTaskZS) {\n        if (this._hasTaskZS) {\n          returnTask._zoneDelegates.push(this._hasTaskDlgtOwner);\n        } // clang-format off\n\n\n        returnTask = this._scheduleTaskZS.onScheduleTask(this._scheduleTaskDlgt, this._scheduleTaskCurrZone, targetZone, task); // clang-format on\n\n        if (!returnTask) returnTask = task;\n      } else {\n        if (task.scheduleFn) {\n          task.scheduleFn(task);\n        } else if (task.type == microTask) {\n          scheduleMicroTask(task);\n        } else {\n          throw new Error('Task is missing scheduleFn.');\n        }\n      }\n\n      return returnTask;\n    }\n\n    invokeTask(targetZone, task, applyThis, applyArgs) {\n      return this._invokeTaskZS ? this._invokeTaskZS.onInvokeTask(this._invokeTaskDlgt, this._invokeTaskCurrZone, targetZone, task, applyThis, applyArgs) : task.callback.apply(applyThis, applyArgs);\n    }\n\n    cancelTask(targetZone, task) {\n      let value;\n\n      if (this._cancelTaskZS) {\n        value = this._cancelTaskZS.onCancelTask(this._cancelTaskDlgt, this._cancelTaskCurrZone, targetZone, task);\n      } else {\n        if (!task.cancelFn) {\n          throw Error('Task is not cancelable');\n        }\n\n        value = task.cancelFn(task);\n      }\n\n      return value;\n    }\n\n    hasTask(targetZone, isEmpty) {\n      // hasTask should not throw error so other ZoneDelegate\n      // can still trigger hasTask callback\n      try {\n        this._hasTaskZS && this._hasTaskZS.onHasTask(this._hasTaskDlgt, this._hasTaskCurrZone, targetZone, isEmpty);\n      } catch (err) {\n        this.handleError(targetZone, err);\n      }\n    } // tslint:disable-next-line:require-internal-with-underscore\n\n\n    _updateTaskCount(type, count) {\n      const counts = this._taskCounts;\n      const prev = counts[type];\n      const next = counts[type] = prev + count;\n\n      if (next < 0) {\n        throw new Error('More tasks executed then were scheduled.');\n      }\n\n      if (prev == 0 || next == 0) {\n        const isEmpty = {\n          microTask: counts['microTask'] > 0,\n          macroTask: counts['macroTask'] > 0,\n          eventTask: counts['eventTask'] > 0,\n          change: type\n        };\n        this.hasTask(this.zone, isEmpty);\n      }\n    }\n\n  }\n\n  class ZoneTask {\n    constructor(type, source, callback, options, scheduleFn, cancelFn) {\n      // tslint:disable-next-line:require-internal-with-underscore\n      this._zone = null;\n      this.runCount = 0; // tslint:disable-next-line:require-internal-with-underscore\n\n      this._zoneDelegates = null; // tslint:disable-next-line:require-internal-with-underscore\n\n      this._state = 'notScheduled';\n      this.type = type;\n      this.source = source;\n      this.data = options;\n      this.scheduleFn = scheduleFn;\n      this.cancelFn = cancelFn;\n\n      if (!callback) {\n        throw new Error('callback is not defined');\n      }\n\n      this.callback = callback;\n      const self = this; // TODO: @JiaLiPassion options should have interface\n\n      if (type === eventTask && options && options.useG) {\n        this.invoke = ZoneTask.invokeTask;\n      } else {\n        this.invoke = function () {\n          return ZoneTask.invokeTask.call(global, self, this, arguments);\n        };\n      }\n    }\n\n    static invokeTask(task, target, args) {\n      if (!task) {\n        task = this;\n      }\n\n      _numberOfNestedTaskFrames++;\n\n      try {\n        task.runCount++;\n        return task.zone.runTask(task, target, args);\n      } finally {\n        if (_numberOfNestedTaskFrames == 1) {\n          drainMicroTaskQueue();\n        }\n\n        _numberOfNestedTaskFrames--;\n      }\n    }\n\n    get zone() {\n      return this._zone;\n    }\n\n    get state() {\n      return this._state;\n    }\n\n    cancelScheduleRequest() {\n      this._transitionTo(notScheduled, scheduling);\n    } // tslint:disable-next-line:require-internal-with-underscore\n\n\n    _transitionTo(toState, fromState1, fromState2) {\n      if (this._state === fromState1 || this._state === fromState2) {\n        this._state = toState;\n\n        if (toState == notScheduled) {\n          this._zoneDelegates = null;\n        }\n      } else {\n        throw new Error(`${this.type} '${this.source}': can not transition to '${toState}', expecting state '${fromState1}'${fromState2 ? ' or \\'' + fromState2 + '\\'' : ''}, was '${this._state}'.`);\n      }\n    }\n\n    toString() {\n      if (this.data && typeof this.data.handleId !== 'undefined') {\n        return this.data.handleId.toString();\n      } else {\n        return Object.prototype.toString.call(this);\n      }\n    } // add toJSON method to prevent cyclic error when\n    // call JSON.stringify(zoneTask)\n\n\n    toJSON() {\n      return {\n        type: this.type,\n        state: this.state,\n        source: this.source,\n        zone: this.zone.name,\n        runCount: this.runCount\n      };\n    }\n\n  } //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n  ///  MICROTASK QUEUE\n  //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n\n\n  const symbolSetTimeout = __symbol__('setTimeout');\n\n  const symbolPromise = __symbol__('Promise');\n\n  const symbolThen = __symbol__('then');\n\n  let _microTaskQueue = [];\n  let _isDrainingMicrotaskQueue = false;\n  let nativeMicroTaskQueuePromise;\n\n  function nativeScheduleMicroTask(func) {\n    if (!nativeMicroTaskQueuePromise) {\n      if (global[symbolPromise]) {\n        nativeMicroTaskQueuePromise = global[symbolPromise].resolve(0);\n      }\n    }\n\n    if (nativeMicroTaskQueuePromise) {\n      let nativeThen = nativeMicroTaskQueuePromise[symbolThen];\n\n      if (!nativeThen) {\n        // native Promise is not patchable, we need to use `then` directly\n        // issue 1078\n        nativeThen = nativeMicroTaskQueuePromise['then'];\n      }\n\n      nativeThen.call(nativeMicroTaskQueuePromise, func);\n    } else {\n      global[symbolSetTimeout](func, 0);\n    }\n  }\n\n  function scheduleMicroTask(task) {\n    // if we are not running in any task, and there has not been anything scheduled\n    // we must bootstrap the initial task creation by manually scheduling the drain\n    if (_numberOfNestedTaskFrames === 0 && _microTaskQueue.length === 0) {\n      // We are not running in Task, so we need to kickstart the microtask queue.\n      nativeScheduleMicroTask(drainMicroTaskQueue);\n    }\n\n    task && _microTaskQueue.push(task);\n  }\n\n  function drainMicroTaskQueue() {\n    if (!_isDrainingMicrotaskQueue) {\n      _isDrainingMicrotaskQueue = true;\n\n      while (_microTaskQueue.length) {\n        const queue = _microTaskQueue;\n        _microTaskQueue = [];\n\n        for (let i = 0; i < queue.length; i++) {\n          const task = queue[i];\n\n          try {\n            task.zone.runTask(task, null, null);\n          } catch (error) {\n            _api.onUnhandledError(error);\n          }\n        }\n      }\n\n      _api.microtaskDrainDone();\n\n      _isDrainingMicrotaskQueue = false;\n    }\n  } //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n  ///  BOOTSTRAP\n  //////////////////////////////////////////////////////\n  //////////////////////////////////////////////////////\n\n\n  const NO_ZONE = {\n    name: 'NO ZONE'\n  };\n  const notScheduled = 'notScheduled',\n        scheduling = 'scheduling',\n        scheduled = 'scheduled',\n        running = 'running',\n        canceling = 'canceling',\n        unknown = 'unknown';\n  const microTask = 'microTask',\n        macroTask = 'macroTask',\n        eventTask = 'eventTask';\n  const patches = {};\n  const _api = {\n    symbol: __symbol__,\n    currentZoneFrame: () => _currentZoneFrame,\n    onUnhandledError: noop,\n    microtaskDrainDone: noop,\n    scheduleMicroTask: scheduleMicroTask,\n    showUncaughtError: () => !Zone[__symbol__('ignoreConsoleErrorUncaughtError')],\n    patchEventTarget: () => [],\n    patchOnProperties: noop,\n    patchMethod: () => noop,\n    bindArguments: () => [],\n    patchThen: () => noop,\n    patchMacroTask: () => noop,\n    patchEventPrototype: () => noop,\n    isIEOrEdge: () => false,\n    getGlobalObjects: () => undefined,\n    ObjectDefineProperty: () => noop,\n    ObjectGetOwnPropertyDescriptor: () => undefined,\n    ObjectCreate: () => undefined,\n    ArraySlice: () => [],\n    patchClass: () => noop,\n    wrapWithCurrentZone: () => noop,\n    filterProperties: () => [],\n    attachOriginToPatched: () => noop,\n    _redefineProperty: () => noop,\n    patchCallbacks: () => noop,\n    nativeScheduleMicroTask: nativeScheduleMicroTask\n  };\n  let _currentZoneFrame = {\n    parent: null,\n    zone: new Zone(null, null)\n  };\n  let _currentTask = null;\n  let _numberOfNestedTaskFrames = 0;\n\n  function noop() {}\n\n  performanceMeasure('Zone', 'Zone');\n  return global['Zone'] = Zone;\n})(typeof window !== 'undefined' && window || typeof self !== 'undefined' && self || global);\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Suppress closure compiler errors about unknown 'Zone' variable\n * @fileoverview\n * @suppress {undefinedVars,globalThis,missingRequire}\n */\n/// <reference types=\"node\"/>\n// issue #989, to reduce bundle size, use short name\n\n/** Object.getOwnPropertyDescriptor */\n\n\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n/** Object.defineProperty */\n\nconst ObjectDefineProperty = Object.defineProperty;\n/** Object.getPrototypeOf */\n\nconst ObjectGetPrototypeOf = Object.getPrototypeOf;\n/** Object.create */\n\nconst ObjectCreate = Object.create;\n/** Array.prototype.slice */\n\nconst ArraySlice = Array.prototype.slice;\n/** addEventListener string const */\n\nconst ADD_EVENT_LISTENER_STR = 'addEventListener';\n/** removeEventListener string const */\n\nconst REMOVE_EVENT_LISTENER_STR = 'removeEventListener';\n/** zoneSymbol addEventListener */\n\nconst ZONE_SYMBOL_ADD_EVENT_LISTENER = Zone.__symbol__(ADD_EVENT_LISTENER_STR);\n/** zoneSymbol removeEventListener */\n\n\nconst ZONE_SYMBOL_REMOVE_EVENT_LISTENER = Zone.__symbol__(REMOVE_EVENT_LISTENER_STR);\n/** true string const */\n\n\nconst TRUE_STR = 'true';\n/** false string const */\n\nconst FALSE_STR = 'false';\n/** Zone symbol prefix string const. */\n\nconst ZONE_SYMBOL_PREFIX = Zone.__symbol__('');\n\nfunction wrapWithCurrentZone(callback, source) {\n  return Zone.current.wrap(callback, source);\n}\n\nfunction scheduleMacroTaskWithCurrentZone(source, callback, data, customSchedule, customCancel) {\n  return Zone.current.scheduleMacroTask(source, callback, data, customSchedule, customCancel);\n}\n\nconst zoneSymbol = Zone.__symbol__;\nconst isWindowExists = typeof window !== 'undefined';\nconst internalWindow = isWindowExists ? window : undefined;\n\nconst _global = isWindowExists && internalWindow || typeof self === 'object' && self || global;\n\nconst REMOVE_ATTRIBUTE = 'removeAttribute';\n\nfunction bindArguments(args, source) {\n  for (let i = args.length - 1; i >= 0; i--) {\n    if (typeof args[i] === 'function') {\n      args[i] = wrapWithCurrentZone(args[i], source + '_' + i);\n    }\n  }\n\n  return args;\n}\n\nfunction patchPrototype(prototype, fnNames) {\n  const source = prototype.constructor['name'];\n\n  for (let i = 0; i < fnNames.length; i++) {\n    const name = fnNames[i];\n    const delegate = prototype[name];\n\n    if (delegate) {\n      const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, name);\n\n      if (!isPropertyWritable(prototypeDesc)) {\n        continue;\n      }\n\n      prototype[name] = (delegate => {\n        const patched = function () {\n          return delegate.apply(this, bindArguments(arguments, source + '.' + name));\n        };\n\n        attachOriginToPatched(patched, delegate);\n        return patched;\n      })(delegate);\n    }\n  }\n}\n\nfunction isPropertyWritable(propertyDesc) {\n  if (!propertyDesc) {\n    return true;\n  }\n\n  if (propertyDesc.writable === false) {\n    return false;\n  }\n\n  return !(typeof propertyDesc.get === 'function' && typeof propertyDesc.set === 'undefined');\n}\n\nconst isWebWorker = typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope; // Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\n\nconst isNode = !('nw' in _global) && typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]';\nconst isBrowser = !isNode && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']); // we are in electron of nw, so we are both browser and nodejs\n// Make sure to access `process` through `_global` so that WebPack does not accidentally browserify\n// this code.\n\nconst isMix = typeof _global.process !== 'undefined' && {}.toString.call(_global.process) === '[object process]' && !isWebWorker && !!(isWindowExists && internalWindow['HTMLElement']);\nconst zoneSymbolEventNames$1 = {};\n\nconst wrapFn = function (event) {\n  // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n  // event will be undefined, so we need to use window.event\n  event = event || _global.event;\n\n  if (!event) {\n    return;\n  }\n\n  let eventNameSymbol = zoneSymbolEventNames$1[event.type];\n\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames$1[event.type] = zoneSymbol('ON_PROPERTY' + event.type);\n  }\n\n  const target = this || event.target || _global;\n  const listener = target[eventNameSymbol];\n  let result;\n\n  if (isBrowser && target === internalWindow && event.type === 'error') {\n    // window.onerror have different signature\n    // https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onerror#window.onerror\n    // and onerror callback will prevent default when callback return true\n    const errorEvent = event;\n    result = listener && listener.call(this, errorEvent.message, errorEvent.filename, errorEvent.lineno, errorEvent.colno, errorEvent.error);\n\n    if (result === true) {\n      event.preventDefault();\n    }\n  } else {\n    result = listener && listener.apply(this, arguments);\n\n    if (result != undefined && !result) {\n      event.preventDefault();\n    }\n  }\n\n  return result;\n};\n\nfunction patchProperty(obj, prop, prototype) {\n  let desc = ObjectGetOwnPropertyDescriptor(obj, prop);\n\n  if (!desc && prototype) {\n    // when patch window object, use prototype to check prop exist or not\n    const prototypeDesc = ObjectGetOwnPropertyDescriptor(prototype, prop);\n\n    if (prototypeDesc) {\n      desc = {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  } // if the descriptor not exists or is not configurable\n  // just return\n\n\n  if (!desc || !desc.configurable) {\n    return;\n  }\n\n  const onPropPatchedSymbol = zoneSymbol('on' + prop + 'patched');\n\n  if (obj.hasOwnProperty(onPropPatchedSymbol) && obj[onPropPatchedSymbol]) {\n    return;\n  } // A property descriptor cannot have getter/setter and be writable\n  // deleting the writable and value properties avoids this error:\n  //\n  // TypeError: property descriptors must not specify a value or be writable when a\n  // getter or setter has been specified\n\n\n  delete desc.writable;\n  delete desc.value;\n  const originalDescGet = desc.get;\n  const originalDescSet = desc.set; // slice(2) cuz 'onclick' -> 'click', etc\n\n  const eventName = prop.slice(2);\n  let eventNameSymbol = zoneSymbolEventNames$1[eventName];\n\n  if (!eventNameSymbol) {\n    eventNameSymbol = zoneSymbolEventNames$1[eventName] = zoneSymbol('ON_PROPERTY' + eventName);\n  }\n\n  desc.set = function (newValue) {\n    // in some of windows's onproperty callback, this is undefined\n    // so we need to check it\n    let target = this;\n\n    if (!target && obj === _global) {\n      target = _global;\n    }\n\n    if (!target) {\n      return;\n    }\n\n    const previousValue = target[eventNameSymbol];\n\n    if (typeof previousValue === 'function') {\n      target.removeEventListener(eventName, wrapFn);\n    } // issue #978, when onload handler was added before loading zone.js\n    // we should remove it with originalDescSet\n\n\n    originalDescSet && originalDescSet.call(target, null);\n    target[eventNameSymbol] = newValue;\n\n    if (typeof newValue === 'function') {\n      target.addEventListener(eventName, wrapFn, false);\n    }\n  }; // The getter would return undefined for unassigned properties but the default value of an\n  // unassigned property is null\n\n\n  desc.get = function () {\n    // in some of windows's onproperty callback, this is undefined\n    // so we need to check it\n    let target = this;\n\n    if (!target && obj === _global) {\n      target = _global;\n    }\n\n    if (!target) {\n      return null;\n    }\n\n    const listener = target[eventNameSymbol];\n\n    if (listener) {\n      return listener;\n    } else if (originalDescGet) {\n      // result will be null when use inline event attribute,\n      // such as <button onclick=\"func();\">OK</button>\n      // because the onclick function is internal raw uncompiled handler\n      // the onclick will be evaluated when first time event was triggered or\n      // the property is accessed, https://github.com/angular/zone.js/issues/525\n      // so we should use original native get to retrieve the handler\n      let value = originalDescGet.call(this);\n\n      if (value) {\n        desc.set.call(this, value);\n\n        if (typeof target[REMOVE_ATTRIBUTE] === 'function') {\n          target.removeAttribute(prop);\n        }\n\n        return value;\n      }\n    }\n\n    return null;\n  };\n\n  ObjectDefineProperty(obj, prop, desc);\n  obj[onPropPatchedSymbol] = true;\n}\n\nfunction patchOnProperties(obj, properties, prototype) {\n  if (properties) {\n    for (let i = 0; i < properties.length; i++) {\n      patchProperty(obj, 'on' + properties[i], prototype);\n    }\n  } else {\n    const onProperties = [];\n\n    for (const prop in obj) {\n      if (prop.slice(0, 2) == 'on') {\n        onProperties.push(prop);\n      }\n    }\n\n    for (let j = 0; j < onProperties.length; j++) {\n      patchProperty(obj, onProperties[j], prototype);\n    }\n  }\n}\n\nconst originalInstanceKey = zoneSymbol('originalInstance'); // wrap some native API on `window`\n\nfunction patchClass(className) {\n  const OriginalClass = _global[className];\n  if (!OriginalClass) return; // keep original class in global\n\n  _global[zoneSymbol(className)] = OriginalClass;\n\n  _global[className] = function () {\n    const a = bindArguments(arguments, className);\n\n    switch (a.length) {\n      case 0:\n        this[originalInstanceKey] = new OriginalClass();\n        break;\n\n      case 1:\n        this[originalInstanceKey] = new OriginalClass(a[0]);\n        break;\n\n      case 2:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1]);\n        break;\n\n      case 3:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2]);\n        break;\n\n      case 4:\n        this[originalInstanceKey] = new OriginalClass(a[0], a[1], a[2], a[3]);\n        break;\n\n      default:\n        throw new Error('Arg list too long.');\n    }\n  }; // attach original delegate to patched function\n\n\n  attachOriginToPatched(_global[className], OriginalClass);\n  const instance = new OriginalClass(function () {});\n  let prop;\n\n  for (prop in instance) {\n    // https://bugs.webkit.org/show_bug.cgi?id=44721\n    if (className === 'XMLHttpRequest' && prop === 'responseBlob') continue;\n\n    (function (prop) {\n      if (typeof instance[prop] === 'function') {\n        _global[className].prototype[prop] = function () {\n          return this[originalInstanceKey][prop].apply(this[originalInstanceKey], arguments);\n        };\n      } else {\n        ObjectDefineProperty(_global[className].prototype, prop, {\n          set: function (fn) {\n            if (typeof fn === 'function') {\n              this[originalInstanceKey][prop] = wrapWithCurrentZone(fn, className + '.' + prop); // keep callback in wrapped function so we can\n              // use it in Function.prototype.toString to return\n              // the native one.\n\n              attachOriginToPatched(this[originalInstanceKey][prop], fn);\n            } else {\n              this[originalInstanceKey][prop] = fn;\n            }\n          },\n          get: function () {\n            return this[originalInstanceKey][prop];\n          }\n        });\n      }\n    })(prop);\n  }\n\n  for (prop in OriginalClass) {\n    if (prop !== 'prototype' && OriginalClass.hasOwnProperty(prop)) {\n      _global[className][prop] = OriginalClass[prop];\n    }\n  }\n}\n\nfunction patchMethod(target, name, patchFn) {\n  let proto = target;\n\n  while (proto && !proto.hasOwnProperty(name)) {\n    proto = ObjectGetPrototypeOf(proto);\n  }\n\n  if (!proto && target[name]) {\n    // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n    proto = target;\n  }\n\n  const delegateName = zoneSymbol(name);\n  let delegate = null;\n\n  if (proto && (!(delegate = proto[delegateName]) || !proto.hasOwnProperty(delegateName))) {\n    delegate = proto[delegateName] = proto[name]; // check whether proto[name] is writable\n    // some property is readonly in safari, such as HtmlCanvasElement.prototype.toBlob\n\n    const desc = proto && ObjectGetOwnPropertyDescriptor(proto, name);\n\n    if (isPropertyWritable(desc)) {\n      const patchDelegate = patchFn(delegate, delegateName, name);\n\n      proto[name] = function () {\n        return patchDelegate(this, arguments);\n      };\n\n      attachOriginToPatched(proto[name], delegate);\n    }\n  }\n\n  return delegate;\n} // TODO: @JiaLiPassion, support cancel task later if necessary\n\n\nfunction patchMacroTask(obj, funcName, metaCreator) {\n  let setNative = null;\n\n  function scheduleTask(task) {\n    const data = task.data;\n\n    data.args[data.cbIdx] = function () {\n      task.invoke.apply(this, arguments);\n    };\n\n    setNative.apply(data.target, data.args);\n    return task;\n  }\n\n  setNative = patchMethod(obj, funcName, delegate => function (self, args) {\n    const meta = metaCreator(self, args);\n\n    if (meta.cbIdx >= 0 && typeof args[meta.cbIdx] === 'function') {\n      return scheduleMacroTaskWithCurrentZone(meta.name, args[meta.cbIdx], meta, scheduleTask);\n    } else {\n      // cause an error by calling it directly.\n      return delegate.apply(self, args);\n    }\n  });\n}\n\nfunction attachOriginToPatched(patched, original) {\n  patched[zoneSymbol('OriginalDelegate')] = original;\n}\n\nlet isDetectedIEOrEdge = false;\nlet ieOrEdge = false;\n\nfunction isIE() {\n  try {\n    const ua = internalWindow.navigator.userAgent;\n\n    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1) {\n      return true;\n    }\n  } catch (error) {}\n\n  return false;\n}\n\nfunction isIEOrEdge() {\n  if (isDetectedIEOrEdge) {\n    return ieOrEdge;\n  }\n\n  isDetectedIEOrEdge = true;\n\n  try {\n    const ua = internalWindow.navigator.userAgent;\n\n    if (ua.indexOf('MSIE ') !== -1 || ua.indexOf('Trident/') !== -1 || ua.indexOf('Edge/') !== -1) {\n      ieOrEdge = true;\n    }\n  } catch (error) {}\n\n  return ieOrEdge;\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('ZoneAwarePromise', (global, Zone, api) => {\n  const ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\n  const ObjectDefineProperty = Object.defineProperty;\n\n  function readableObjectToString(obj) {\n    if (obj && obj.toString === Object.prototype.toString) {\n      const className = obj.constructor && obj.constructor.name;\n      return (className ? className : '') + ': ' + JSON.stringify(obj);\n    }\n\n    return obj ? obj.toString() : Object.prototype.toString.call(obj);\n  }\n\n  const __symbol__ = api.symbol;\n  const _uncaughtPromiseErrors = [];\n  const isDisableWrappingUncaughtPromiseRejection = global[__symbol__('DISABLE_WRAPPING_UNCAUGHT_PROMISE_REJECTION')] === true;\n\n  const symbolPromise = __symbol__('Promise');\n\n  const symbolThen = __symbol__('then');\n\n  const creationTrace = '__creationTrace__';\n\n  api.onUnhandledError = e => {\n    if (api.showUncaughtError()) {\n      const rejection = e && e.rejection;\n\n      if (rejection) {\n        console.error('Unhandled Promise rejection:', rejection instanceof Error ? rejection.message : rejection, '; Zone:', e.zone.name, '; Task:', e.task && e.task.source, '; Value:', rejection, rejection instanceof Error ? rejection.stack : undefined);\n      } else {\n        console.error(e);\n      }\n    }\n  };\n\n  api.microtaskDrainDone = () => {\n    while (_uncaughtPromiseErrors.length) {\n      const uncaughtPromiseError = _uncaughtPromiseErrors.shift();\n\n      try {\n        uncaughtPromiseError.zone.runGuarded(() => {\n          if (uncaughtPromiseError.throwOriginal) {\n            throw uncaughtPromiseError.rejection;\n          }\n\n          throw uncaughtPromiseError;\n        });\n      } catch (error) {\n        handleUnhandledRejection(error);\n      }\n    }\n  };\n\n  const UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL = __symbol__('unhandledPromiseRejectionHandler');\n\n  function handleUnhandledRejection(e) {\n    api.onUnhandledError(e);\n\n    try {\n      const handler = Zone[UNHANDLED_PROMISE_REJECTION_HANDLER_SYMBOL];\n\n      if (typeof handler === 'function') {\n        handler.call(this, e);\n      }\n    } catch (err) {}\n  }\n\n  function isThenable(value) {\n    return value && value.then;\n  }\n\n  function forwardResolution(value) {\n    return value;\n  }\n\n  function forwardRejection(rejection) {\n    return ZoneAwarePromise.reject(rejection);\n  }\n\n  const symbolState = __symbol__('state');\n\n  const symbolValue = __symbol__('value');\n\n  const symbolFinally = __symbol__('finally');\n\n  const symbolParentPromiseValue = __symbol__('parentPromiseValue');\n\n  const symbolParentPromiseState = __symbol__('parentPromiseState');\n\n  const source = 'Promise.then';\n  const UNRESOLVED = null;\n  const RESOLVED = true;\n  const REJECTED = false;\n  const REJECTED_NO_CATCH = 0;\n\n  function makeResolver(promise, state) {\n    return v => {\n      try {\n        resolvePromise(promise, state, v);\n      } catch (err) {\n        resolvePromise(promise, false, err);\n      } // Do not return value or you will break the Promise spec.\n\n    };\n  }\n\n  const once = function () {\n    let wasCalled = false;\n    return function wrapper(wrappedFunction) {\n      return function () {\n        if (wasCalled) {\n          return;\n        }\n\n        wasCalled = true;\n        wrappedFunction.apply(null, arguments);\n      };\n    };\n  };\n\n  const TYPE_ERROR = 'Promise resolved with itself';\n\n  const CURRENT_TASK_TRACE_SYMBOL = __symbol__('currentTaskTrace'); // Promise Resolution\n\n\n  function resolvePromise(promise, state, value) {\n    const onceWrapper = once();\n\n    if (promise === value) {\n      throw new TypeError(TYPE_ERROR);\n    }\n\n    if (promise[symbolState] === UNRESOLVED) {\n      // should only get value.then once based on promise spec.\n      let then = null;\n\n      try {\n        if (typeof value === 'object' || typeof value === 'function') {\n          then = value && value.then;\n        }\n      } catch (err) {\n        onceWrapper(() => {\n          resolvePromise(promise, false, err);\n        })();\n        return promise;\n      } // if (value instanceof ZoneAwarePromise) {\n\n\n      if (state !== REJECTED && value instanceof ZoneAwarePromise && value.hasOwnProperty(symbolState) && value.hasOwnProperty(symbolValue) && value[symbolState] !== UNRESOLVED) {\n        clearRejectedNoCatch(value);\n        resolvePromise(promise, value[symbolState], value[symbolValue]);\n      } else if (state !== REJECTED && typeof then === 'function') {\n        try {\n          then.call(value, onceWrapper(makeResolver(promise, state)), onceWrapper(makeResolver(promise, false)));\n        } catch (err) {\n          onceWrapper(() => {\n            resolvePromise(promise, false, err);\n          })();\n        }\n      } else {\n        promise[symbolState] = state;\n        const queue = promise[symbolValue];\n        promise[symbolValue] = value;\n\n        if (promise[symbolFinally] === symbolFinally) {\n          // the promise is generated by Promise.prototype.finally\n          if (state === RESOLVED) {\n            // the state is resolved, should ignore the value\n            // and use parent promise value\n            promise[symbolState] = promise[symbolParentPromiseState];\n            promise[symbolValue] = promise[symbolParentPromiseValue];\n          }\n        } // record task information in value when error occurs, so we can\n        // do some additional work such as render longStackTrace\n\n\n        if (state === REJECTED && value instanceof Error) {\n          // check if longStackTraceZone is here\n          const trace = Zone.currentTask && Zone.currentTask.data && Zone.currentTask.data[creationTrace];\n\n          if (trace) {\n            // only keep the long stack trace into error when in longStackTraceZone\n            ObjectDefineProperty(value, CURRENT_TASK_TRACE_SYMBOL, {\n              configurable: true,\n              enumerable: false,\n              writable: true,\n              value: trace\n            });\n          }\n        }\n\n        for (let i = 0; i < queue.length;) {\n          scheduleResolveOrReject(promise, queue[i++], queue[i++], queue[i++], queue[i++]);\n        }\n\n        if (queue.length == 0 && state == REJECTED) {\n          promise[symbolState] = REJECTED_NO_CATCH;\n          let uncaughtPromiseError = value;\n\n          try {\n            // Here we throws a new Error to print more readable error log\n            // and if the value is not an error, zone.js builds an `Error`\n            // Object here to attach the stack information.\n            throw new Error('Uncaught (in promise): ' + readableObjectToString(value) + (value && value.stack ? '\\n' + value.stack : ''));\n          } catch (err) {\n            uncaughtPromiseError = err;\n          }\n\n          if (isDisableWrappingUncaughtPromiseRejection) {\n            // If disable wrapping uncaught promise reject\n            // use the value instead of wrapping it.\n            uncaughtPromiseError.throwOriginal = true;\n          }\n\n          uncaughtPromiseError.rejection = value;\n          uncaughtPromiseError.promise = promise;\n          uncaughtPromiseError.zone = Zone.current;\n          uncaughtPromiseError.task = Zone.currentTask;\n\n          _uncaughtPromiseErrors.push(uncaughtPromiseError);\n\n          api.scheduleMicroTask(); // to make sure that it is running\n        }\n      }\n    } // Resolving an already resolved promise is a noop.\n\n\n    return promise;\n  }\n\n  const REJECTION_HANDLED_HANDLER = __symbol__('rejectionHandledHandler');\n\n  function clearRejectedNoCatch(promise) {\n    if (promise[symbolState] === REJECTED_NO_CATCH) {\n      // if the promise is rejected no catch status\n      // and queue.length > 0, means there is a error handler\n      // here to handle the rejected promise, we should trigger\n      // windows.rejectionhandled eventHandler or nodejs rejectionHandled\n      // eventHandler\n      try {\n        const handler = Zone[REJECTION_HANDLED_HANDLER];\n\n        if (handler && typeof handler === 'function') {\n          handler.call(this, {\n            rejection: promise[symbolValue],\n            promise: promise\n          });\n        }\n      } catch (err) {}\n\n      promise[symbolState] = REJECTED;\n\n      for (let i = 0; i < _uncaughtPromiseErrors.length; i++) {\n        if (promise === _uncaughtPromiseErrors[i].promise) {\n          _uncaughtPromiseErrors.splice(i, 1);\n        }\n      }\n    }\n  }\n\n  function scheduleResolveOrReject(promise, zone, chainPromise, onFulfilled, onRejected) {\n    clearRejectedNoCatch(promise);\n    const promiseState = promise[symbolState];\n    const delegate = promiseState ? typeof onFulfilled === 'function' ? onFulfilled : forwardResolution : typeof onRejected === 'function' ? onRejected : forwardRejection;\n    zone.scheduleMicroTask(source, () => {\n      try {\n        const parentPromiseValue = promise[symbolValue];\n        const isFinallyPromise = !!chainPromise && symbolFinally === chainPromise[symbolFinally];\n\n        if (isFinallyPromise) {\n          // if the promise is generated from finally call, keep parent promise's state and value\n          chainPromise[symbolParentPromiseValue] = parentPromiseValue;\n          chainPromise[symbolParentPromiseState] = promiseState;\n        } // should not pass value to finally callback\n\n\n        const value = zone.run(delegate, undefined, isFinallyPromise && delegate !== forwardRejection && delegate !== forwardResolution ? [] : [parentPromiseValue]);\n        resolvePromise(chainPromise, true, value);\n      } catch (error) {\n        // if error occurs, should always return this error\n        resolvePromise(chainPromise, false, error);\n      }\n    }, chainPromise);\n  }\n\n  const ZONE_AWARE_PROMISE_TO_STRING = 'function ZoneAwarePromise() { [native code] }';\n\n  const noop = function () {};\n\n  const AggregateError = global.AggregateError;\n\n  class ZoneAwarePromise {\n    static toString() {\n      return ZONE_AWARE_PROMISE_TO_STRING;\n    }\n\n    static resolve(value) {\n      return resolvePromise(new this(null), RESOLVED, value);\n    }\n\n    static reject(error) {\n      return resolvePromise(new this(null), REJECTED, error);\n    }\n\n    static any(values) {\n      if (!values || typeof values[Symbol.iterator] !== 'function') {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      const promises = [];\n      let count = 0;\n\n      try {\n        for (let v of values) {\n          count++;\n          promises.push(ZoneAwarePromise.resolve(v));\n        }\n      } catch (err) {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      if (count === 0) {\n        return Promise.reject(new AggregateError([], 'All promises were rejected'));\n      }\n\n      let finished = false;\n      const errors = [];\n      return new ZoneAwarePromise((resolve, reject) => {\n        for (let i = 0; i < promises.length; i++) {\n          promises[i].then(v => {\n            if (finished) {\n              return;\n            }\n\n            finished = true;\n            resolve(v);\n          }, err => {\n            errors.push(err);\n            count--;\n\n            if (count === 0) {\n              finished = true;\n              reject(new AggregateError(errors, 'All promises were rejected'));\n            }\n          });\n        }\n      });\n    }\n\n    static race(values) {\n      let resolve;\n      let reject;\n      let promise = new this((res, rej) => {\n        resolve = res;\n        reject = rej;\n      });\n\n      function onResolve(value) {\n        resolve(value);\n      }\n\n      function onReject(error) {\n        reject(error);\n      }\n\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n\n        value.then(onResolve, onReject);\n      }\n\n      return promise;\n    }\n\n    static all(values) {\n      return ZoneAwarePromise.allWithCallback(values);\n    }\n\n    static allSettled(values) {\n      const P = this && this.prototype instanceof ZoneAwarePromise ? this : ZoneAwarePromise;\n      return P.allWithCallback(values, {\n        thenCallback: value => ({\n          status: 'fulfilled',\n          value\n        }),\n        errorCallback: err => ({\n          status: 'rejected',\n          reason: err\n        })\n      });\n    }\n\n    static allWithCallback(values, callback) {\n      let resolve;\n      let reject;\n      let promise = new this((res, rej) => {\n        resolve = res;\n        reject = rej;\n      }); // Start at 2 to prevent prematurely resolving if .then is called immediately.\n\n      let unresolvedCount = 2;\n      let valueIndex = 0;\n      const resolvedValues = [];\n\n      for (let value of values) {\n        if (!isThenable(value)) {\n          value = this.resolve(value);\n        }\n\n        const curValueIndex = valueIndex;\n\n        try {\n          value.then(value => {\n            resolvedValues[curValueIndex] = callback ? callback.thenCallback(value) : value;\n            unresolvedCount--;\n\n            if (unresolvedCount === 0) {\n              resolve(resolvedValues);\n            }\n          }, err => {\n            if (!callback) {\n              reject(err);\n            } else {\n              resolvedValues[curValueIndex] = callback.errorCallback(err);\n              unresolvedCount--;\n\n              if (unresolvedCount === 0) {\n                resolve(resolvedValues);\n              }\n            }\n          });\n        } catch (thenErr) {\n          reject(thenErr);\n        }\n\n        unresolvedCount++;\n        valueIndex++;\n      } // Make the unresolvedCount zero-based again.\n\n\n      unresolvedCount -= 2;\n\n      if (unresolvedCount === 0) {\n        resolve(resolvedValues);\n      }\n\n      return promise;\n    }\n\n    constructor(executor) {\n      const promise = this;\n\n      if (!(promise instanceof ZoneAwarePromise)) {\n        throw new Error('Must be an instanceof Promise.');\n      }\n\n      promise[symbolState] = UNRESOLVED;\n      promise[symbolValue] = []; // queue;\n\n      try {\n        const onceWrapper = once();\n        executor && executor(onceWrapper(makeResolver(promise, RESOLVED)), onceWrapper(makeResolver(promise, REJECTED)));\n      } catch (error) {\n        resolvePromise(promise, false, error);\n      }\n    }\n\n    get [Symbol.toStringTag]() {\n      return 'Promise';\n    }\n\n    get [Symbol.species]() {\n      return ZoneAwarePromise;\n    }\n\n    then(onFulfilled, onRejected) {\n      var _a; // We must read `Symbol.species` safely because `this` may be anything. For instance, `this`\n      // may be an object without a prototype (created through `Object.create(null)`); thus\n      // `this.constructor` will be undefined. One of the use cases is SystemJS creating\n      // prototype-less objects (modules) via `Object.create(null)`. The SystemJS creates an empty\n      // object and copies promise properties into that object (within the `getOrCreateLoad`\n      // function). The zone.js then checks if the resolved value has the `then` method and invokes\n      // it with the `value` context. Otherwise, this will throw an error: `TypeError: Cannot read\n      // properties of undefined (reading 'Symbol(Symbol.species)')`.\n\n\n      let C = (_a = this.constructor) === null || _a === void 0 ? void 0 : _a[Symbol.species];\n\n      if (!C || typeof C !== 'function') {\n        C = this.constructor || ZoneAwarePromise;\n      }\n\n      const chainPromise = new C(noop);\n      const zone = Zone.current;\n\n      if (this[symbolState] == UNRESOLVED) {\n        this[symbolValue].push(zone, chainPromise, onFulfilled, onRejected);\n      } else {\n        scheduleResolveOrReject(this, zone, chainPromise, onFulfilled, onRejected);\n      }\n\n      return chainPromise;\n    }\n\n    catch(onRejected) {\n      return this.then(null, onRejected);\n    }\n\n    finally(onFinally) {\n      var _a; // See comment on the call to `then` about why thee `Symbol.species` is safely accessed.\n\n\n      let C = (_a = this.constructor) === null || _a === void 0 ? void 0 : _a[Symbol.species];\n\n      if (!C || typeof C !== 'function') {\n        C = ZoneAwarePromise;\n      }\n\n      const chainPromise = new C(noop);\n      chainPromise[symbolFinally] = symbolFinally;\n      const zone = Zone.current;\n\n      if (this[symbolState] == UNRESOLVED) {\n        this[symbolValue].push(zone, chainPromise, onFinally, onFinally);\n      } else {\n        scheduleResolveOrReject(this, zone, chainPromise, onFinally, onFinally);\n      }\n\n      return chainPromise;\n    }\n\n  } // Protect against aggressive optimizers dropping seemingly unused properties.\n  // E.g. Closure Compiler in advanced mode.\n\n\n  ZoneAwarePromise['resolve'] = ZoneAwarePromise.resolve;\n  ZoneAwarePromise['reject'] = ZoneAwarePromise.reject;\n  ZoneAwarePromise['race'] = ZoneAwarePromise.race;\n  ZoneAwarePromise['all'] = ZoneAwarePromise.all;\n  const NativePromise = global[symbolPromise] = global['Promise'];\n  global['Promise'] = ZoneAwarePromise;\n\n  const symbolThenPatched = __symbol__('thenPatched');\n\n  function patchThen(Ctor) {\n    const proto = Ctor.prototype;\n    const prop = ObjectGetOwnPropertyDescriptor(proto, 'then');\n\n    if (prop && (prop.writable === false || !prop.configurable)) {\n      // check Ctor.prototype.then propertyDescriptor is writable or not\n      // in meteor env, writable is false, we should ignore such case\n      return;\n    }\n\n    const originalThen = proto.then; // Keep a reference to the original method.\n\n    proto[symbolThen] = originalThen;\n\n    Ctor.prototype.then = function (onResolve, onReject) {\n      const wrapped = new ZoneAwarePromise((resolve, reject) => {\n        originalThen.call(this, resolve, reject);\n      });\n      return wrapped.then(onResolve, onReject);\n    };\n\n    Ctor[symbolThenPatched] = true;\n  }\n\n  api.patchThen = patchThen;\n\n  function zoneify(fn) {\n    return function (self, args) {\n      let resultPromise = fn.apply(self, args);\n\n      if (resultPromise instanceof ZoneAwarePromise) {\n        return resultPromise;\n      }\n\n      let ctor = resultPromise.constructor;\n\n      if (!ctor[symbolThenPatched]) {\n        patchThen(ctor);\n      }\n\n      return resultPromise;\n    };\n  }\n\n  if (NativePromise) {\n    patchThen(NativePromise);\n    patchMethod(global, 'fetch', delegate => zoneify(delegate));\n  } // This is not part of public API, but it is useful for tests, so we expose it.\n\n\n  Promise[Zone.__symbol__('uncaughtPromiseErrors')] = _uncaughtPromiseErrors;\n  return ZoneAwarePromise;\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// override Function.prototype.toString to make zone.js patched function\n// look like native function\n\n\nZone.__load_patch('toString', global => {\n  // patch Func.prototype.toString to let them look like native\n  const originalFunctionToString = Function.prototype.toString;\n  const ORIGINAL_DELEGATE_SYMBOL = zoneSymbol('OriginalDelegate');\n  const PROMISE_SYMBOL = zoneSymbol('Promise');\n  const ERROR_SYMBOL = zoneSymbol('Error');\n\n  const newFunctionToString = function toString() {\n    if (typeof this === 'function') {\n      const originalDelegate = this[ORIGINAL_DELEGATE_SYMBOL];\n\n      if (originalDelegate) {\n        if (typeof originalDelegate === 'function') {\n          return originalFunctionToString.call(originalDelegate);\n        } else {\n          return Object.prototype.toString.call(originalDelegate);\n        }\n      }\n\n      if (this === Promise) {\n        const nativePromise = global[PROMISE_SYMBOL];\n\n        if (nativePromise) {\n          return originalFunctionToString.call(nativePromise);\n        }\n      }\n\n      if (this === Error) {\n        const nativeError = global[ERROR_SYMBOL];\n\n        if (nativeError) {\n          return originalFunctionToString.call(nativeError);\n        }\n      }\n    }\n\n    return originalFunctionToString.call(this);\n  };\n\n  newFunctionToString[ORIGINAL_DELEGATE_SYMBOL] = originalFunctionToString;\n  Function.prototype.toString = newFunctionToString; // patch Object.prototype.toString to let them look like native\n\n  const originalObjectToString = Object.prototype.toString;\n  const PROMISE_OBJECT_TO_STRING = '[object Promise]';\n\n  Object.prototype.toString = function () {\n    if (typeof Promise === 'function' && this instanceof Promise) {\n      return PROMISE_OBJECT_TO_STRING;\n    }\n\n    return originalObjectToString.call(this);\n  };\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nlet passiveSupported = false;\n\nif (typeof window !== 'undefined') {\n  try {\n    const options = Object.defineProperty({}, 'passive', {\n      get: function () {\n        passiveSupported = true;\n      }\n    }); // Note: We pass the `options` object as the event handler too. This is not compatible with the\n    // signature of `addEventListener` or `removeEventListener` but enables us to remove the handler\n    // without an actual handler.\n\n    window.addEventListener('test', options, options);\n    window.removeEventListener('test', options, options);\n  } catch (err) {\n    passiveSupported = false;\n  }\n} // an identifier to tell ZoneTask do not create a new invoke closure\n\n\nconst OPTIMIZED_ZONE_EVENT_TASK_DATA = {\n  useG: true\n};\nconst zoneSymbolEventNames = {};\nconst globalSources = {};\nconst EVENT_NAME_SYMBOL_REGX = new RegExp('^' + ZONE_SYMBOL_PREFIX + '(\\\\w+)(true|false)$');\nconst IMMEDIATE_PROPAGATION_SYMBOL = zoneSymbol('propagationStopped');\n\nfunction prepareEventNames(eventName, eventNameToString) {\n  const falseEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + FALSE_STR;\n  const trueEventName = (eventNameToString ? eventNameToString(eventName) : eventName) + TRUE_STR;\n  const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n  const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n  zoneSymbolEventNames[eventName] = {};\n  zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n  zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n}\n\nfunction patchEventTarget(_global, api, apis, patchOptions) {\n  const ADD_EVENT_LISTENER = patchOptions && patchOptions.add || ADD_EVENT_LISTENER_STR;\n  const REMOVE_EVENT_LISTENER = patchOptions && patchOptions.rm || REMOVE_EVENT_LISTENER_STR;\n  const LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.listeners || 'eventListeners';\n  const REMOVE_ALL_LISTENERS_EVENT_LISTENER = patchOptions && patchOptions.rmAll || 'removeAllListeners';\n  const zoneSymbolAddEventListener = zoneSymbol(ADD_EVENT_LISTENER);\n  const ADD_EVENT_LISTENER_SOURCE = '.' + ADD_EVENT_LISTENER + ':';\n  const PREPEND_EVENT_LISTENER = 'prependListener';\n  const PREPEND_EVENT_LISTENER_SOURCE = '.' + PREPEND_EVENT_LISTENER + ':';\n\n  const invokeTask = function (task, target, event) {\n    // for better performance, check isRemoved which is set\n    // by removeEventListener\n    if (task.isRemoved) {\n      return;\n    }\n\n    const delegate = task.callback;\n\n    if (typeof delegate === 'object' && delegate.handleEvent) {\n      // create the bind version of handleEvent when invoke\n      task.callback = event => delegate.handleEvent(event);\n\n      task.originalDelegate = delegate;\n    } // invoke static task.invoke\n    // need to try/catch error here, otherwise, the error in one event listener\n    // will break the executions of the other event listeners. Also error will\n    // not remove the event listener when `once` options is true.\n\n\n    let error;\n\n    try {\n      task.invoke(task, target, [event]);\n    } catch (err) {\n      error = err;\n    }\n\n    const options = task.options;\n\n    if (options && typeof options === 'object' && options.once) {\n      // if options.once is true, after invoke once remove listener here\n      // only browser need to do this, nodejs eventEmitter will cal removeListener\n      // inside EventEmitter.once\n      const delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n      target[REMOVE_EVENT_LISTENER].call(target, event.type, delegate, options);\n    }\n\n    return error;\n  };\n\n  function globalCallback(context, event, isCapture) {\n    // https://github.com/angular/zone.js/issues/911, in IE, sometimes\n    // event will be undefined, so we need to use window.event\n    event = event || _global.event;\n\n    if (!event) {\n      return;\n    } // event.target is needed for Samsung TV and SourceBuffer\n    // || global is needed https://github.com/angular/zone.js/issues/190\n\n\n    const target = context || event.target || _global;\n    const tasks = target[zoneSymbolEventNames[event.type][isCapture ? TRUE_STR : FALSE_STR]];\n\n    if (tasks) {\n      const errors = []; // invoke all tasks which attached to current target with given event.type and capture = false\n      // for performance concern, if task.length === 1, just invoke\n\n      if (tasks.length === 1) {\n        const err = invokeTask(tasks[0], target, event);\n        err && errors.push(err);\n      } else {\n        // https://github.com/angular/zone.js/issues/836\n        // copy the tasks array before invoke, to avoid\n        // the callback will remove itself or other listener\n        const copyTasks = tasks.slice();\n\n        for (let i = 0; i < copyTasks.length; i++) {\n          if (event && event[IMMEDIATE_PROPAGATION_SYMBOL] === true) {\n            break;\n          }\n\n          const err = invokeTask(copyTasks[i], target, event);\n          err && errors.push(err);\n        }\n      } // Since there is only one error, we don't need to schedule microTask\n      // to throw the error.\n\n\n      if (errors.length === 1) {\n        throw errors[0];\n      } else {\n        for (let i = 0; i < errors.length; i++) {\n          const err = errors[i];\n          api.nativeScheduleMicroTask(() => {\n            throw err;\n          });\n        }\n      }\n    }\n  } // global shared zoneAwareCallback to handle all event callback with capture = false\n\n\n  const globalZoneAwareCallback = function (event) {\n    return globalCallback(this, event, false);\n  }; // global shared zoneAwareCallback to handle all event callback with capture = true\n\n\n  const globalZoneAwareCaptureCallback = function (event) {\n    return globalCallback(this, event, true);\n  };\n\n  function patchEventTargetMethods(obj, patchOptions) {\n    if (!obj) {\n      return false;\n    }\n\n    let useGlobalCallback = true;\n\n    if (patchOptions && patchOptions.useG !== undefined) {\n      useGlobalCallback = patchOptions.useG;\n    }\n\n    const validateHandler = patchOptions && patchOptions.vh;\n    let checkDuplicate = true;\n\n    if (patchOptions && patchOptions.chkDup !== undefined) {\n      checkDuplicate = patchOptions.chkDup;\n    }\n\n    let returnTarget = false;\n\n    if (patchOptions && patchOptions.rt !== undefined) {\n      returnTarget = patchOptions.rt;\n    }\n\n    let proto = obj;\n\n    while (proto && !proto.hasOwnProperty(ADD_EVENT_LISTENER)) {\n      proto = ObjectGetPrototypeOf(proto);\n    }\n\n    if (!proto && obj[ADD_EVENT_LISTENER]) {\n      // somehow we did not find it, but we can see it. This happens on IE for Window properties.\n      proto = obj;\n    }\n\n    if (!proto) {\n      return false;\n    }\n\n    if (proto[zoneSymbolAddEventListener]) {\n      return false;\n    }\n\n    const eventNameToString = patchOptions && patchOptions.eventNameToString; // a shared global taskData to pass data for scheduleEventTask\n    // so we do not need to create a new object just for pass some data\n\n    const taskData = {};\n    const nativeAddEventListener = proto[zoneSymbolAddEventListener] = proto[ADD_EVENT_LISTENER];\n    const nativeRemoveEventListener = proto[zoneSymbol(REMOVE_EVENT_LISTENER)] = proto[REMOVE_EVENT_LISTENER];\n    const nativeListeners = proto[zoneSymbol(LISTENERS_EVENT_LISTENER)] = proto[LISTENERS_EVENT_LISTENER];\n    const nativeRemoveAllListeners = proto[zoneSymbol(REMOVE_ALL_LISTENERS_EVENT_LISTENER)] = proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER];\n    let nativePrependEventListener;\n\n    if (patchOptions && patchOptions.prepend) {\n      nativePrependEventListener = proto[zoneSymbol(patchOptions.prepend)] = proto[patchOptions.prepend];\n    }\n    /**\n     * This util function will build an option object with passive option\n     * to handle all possible input from the user.\n     */\n\n\n    function buildEventListenerOptions(options, passive) {\n      if (!passiveSupported && typeof options === 'object' && options) {\n        // doesn't support passive but user want to pass an object as options.\n        // this will not work on some old browser, so we just pass a boolean\n        // as useCapture parameter\n        return !!options.capture;\n      }\n\n      if (!passiveSupported || !passive) {\n        return options;\n      }\n\n      if (typeof options === 'boolean') {\n        return {\n          capture: options,\n          passive: true\n        };\n      }\n\n      if (!options) {\n        return {\n          passive: true\n        };\n      }\n\n      if (typeof options === 'object' && options.passive !== false) {\n        return Object.assign(Object.assign({}, options), {\n          passive: true\n        });\n      }\n\n      return options;\n    }\n\n    const customScheduleGlobal = function (task) {\n      // if there is already a task for the eventName + capture,\n      // just return, because we use the shared globalZoneAwareCallback here.\n      if (taskData.isExisting) {\n        return;\n      }\n\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, taskData.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, taskData.options);\n    };\n\n    const customCancelGlobal = function (task) {\n      // if task is not marked as isRemoved, this call is directly\n      // from Zone.prototype.cancelTask, we should remove the task\n      // from tasksList of target first\n      if (!task.isRemoved) {\n        const symbolEventNames = zoneSymbolEventNames[task.eventName];\n        let symbolEventName;\n\n        if (symbolEventNames) {\n          symbolEventName = symbolEventNames[task.capture ? TRUE_STR : FALSE_STR];\n        }\n\n        const existingTasks = symbolEventName && task.target[symbolEventName];\n\n        if (existingTasks) {\n          for (let i = 0; i < existingTasks.length; i++) {\n            const existingTask = existingTasks[i];\n\n            if (existingTask === task) {\n              existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check\n\n              task.isRemoved = true;\n\n              if (existingTasks.length === 0) {\n                // all tasks for the eventName + capture have gone,\n                // remove globalZoneAwareCallback and remove the task cache from target\n                task.allRemoved = true;\n                task.target[symbolEventName] = null;\n              }\n\n              break;\n            }\n          }\n        }\n      } // if all tasks for the eventName + capture have gone,\n      // we will really remove the global event callback,\n      // if not, return\n\n\n      if (!task.allRemoved) {\n        return;\n      }\n\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.capture ? globalZoneAwareCaptureCallback : globalZoneAwareCallback, task.options);\n    };\n\n    const customScheduleNonGlobal = function (task) {\n      return nativeAddEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n\n    const customSchedulePrepend = function (task) {\n      return nativePrependEventListener.call(taskData.target, taskData.eventName, task.invoke, taskData.options);\n    };\n\n    const customCancelNonGlobal = function (task) {\n      return nativeRemoveEventListener.call(task.target, task.eventName, task.invoke, task.options);\n    };\n\n    const customSchedule = useGlobalCallback ? customScheduleGlobal : customScheduleNonGlobal;\n    const customCancel = useGlobalCallback ? customCancelGlobal : customCancelNonGlobal;\n\n    const compareTaskCallbackVsDelegate = function (task, delegate) {\n      const typeOfDelegate = typeof delegate;\n      return typeOfDelegate === 'function' && task.callback === delegate || typeOfDelegate === 'object' && task.originalDelegate === delegate;\n    };\n\n    const compare = patchOptions && patchOptions.diff ? patchOptions.diff : compareTaskCallbackVsDelegate;\n    const unpatchedEvents = Zone[zoneSymbol('UNPATCHED_EVENTS')];\n\n    const passiveEvents = _global[zoneSymbol('PASSIVE_EVENTS')];\n\n    const makeAddListener = function (nativeListener, addSource, customScheduleFn, customCancelFn, returnTarget = false, prepend = false) {\n      return function () {\n        const target = this || _global;\n        let eventName = arguments[0];\n\n        if (patchOptions && patchOptions.transferEventName) {\n          eventName = patchOptions.transferEventName(eventName);\n        }\n\n        let delegate = arguments[1];\n\n        if (!delegate) {\n          return nativeListener.apply(this, arguments);\n        }\n\n        if (isNode && eventName === 'uncaughtException') {\n          // don't patch uncaughtException of nodejs to prevent endless loop\n          return nativeListener.apply(this, arguments);\n        } // don't create the bind delegate function for handleEvent\n        // case here to improve addEventListener performance\n        // we will create the bind delegate when invoke\n\n\n        let isHandleEvent = false;\n\n        if (typeof delegate !== 'function') {\n          if (!delegate.handleEvent) {\n            return nativeListener.apply(this, arguments);\n          }\n\n          isHandleEvent = true;\n        }\n\n        if (validateHandler && !validateHandler(nativeListener, delegate, target, arguments)) {\n          return;\n        }\n\n        const passive = passiveSupported && !!passiveEvents && passiveEvents.indexOf(eventName) !== -1;\n        const options = buildEventListenerOptions(arguments[2], passive);\n\n        if (unpatchedEvents) {\n          // check unpatched list\n          for (let i = 0; i < unpatchedEvents.length; i++) {\n            if (eventName === unpatchedEvents[i]) {\n              if (passive) {\n                return nativeListener.call(target, eventName, delegate, options);\n              } else {\n                return nativeListener.apply(this, arguments);\n              }\n            }\n          }\n        }\n\n        const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n        const once = options && typeof options === 'object' ? options.once : false;\n        const zone = Zone.current;\n        let symbolEventNames = zoneSymbolEventNames[eventName];\n\n        if (!symbolEventNames) {\n          prepareEventNames(eventName, eventNameToString);\n          symbolEventNames = zoneSymbolEventNames[eventName];\n        }\n\n        const symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n        let existingTasks = target[symbolEventName];\n        let isExisting = false;\n\n        if (existingTasks) {\n          // already have task registered\n          isExisting = true;\n\n          if (checkDuplicate) {\n            for (let i = 0; i < existingTasks.length; i++) {\n              if (compare(existingTasks[i], delegate)) {\n                // same callback, same capture, same event name, just return\n                return;\n              }\n            }\n          }\n        } else {\n          existingTasks = target[symbolEventName] = [];\n        }\n\n        let source;\n        const constructorName = target.constructor['name'];\n        const targetSource = globalSources[constructorName];\n\n        if (targetSource) {\n          source = targetSource[eventName];\n        }\n\n        if (!source) {\n          source = constructorName + addSource + (eventNameToString ? eventNameToString(eventName) : eventName);\n        } // do not create a new object as task.data to pass those things\n        // just use the global shared one\n\n\n        taskData.options = options;\n\n        if (once) {\n          // if addEventListener with once options, we don't pass it to\n          // native addEventListener, instead we keep the once setting\n          // and handle ourselves.\n          taskData.options.once = false;\n        }\n\n        taskData.target = target;\n        taskData.capture = capture;\n        taskData.eventName = eventName;\n        taskData.isExisting = isExisting;\n        const data = useGlobalCallback ? OPTIMIZED_ZONE_EVENT_TASK_DATA : undefined; // keep taskData into data to allow onScheduleEventTask to access the task information\n\n        if (data) {\n          data.taskData = taskData;\n        }\n\n        const task = zone.scheduleEventTask(source, delegate, data, customScheduleFn, customCancelFn); // should clear taskData.target to avoid memory leak\n        // issue, https://github.com/angular/angular/issues/20442\n\n        taskData.target = null; // need to clear up taskData because it is a global object\n\n        if (data) {\n          data.taskData = null;\n        } // have to save those information to task in case\n        // application may call task.zone.cancelTask() directly\n\n\n        if (once) {\n          options.once = true;\n        }\n\n        if (!(!passiveSupported && typeof task.options === 'boolean')) {\n          // if not support passive, and we pass an option object\n          // to addEventListener, we should save the options to task\n          task.options = options;\n        }\n\n        task.target = target;\n        task.capture = capture;\n        task.eventName = eventName;\n\n        if (isHandleEvent) {\n          // save original delegate for compare to check duplicate\n          task.originalDelegate = delegate;\n        }\n\n        if (!prepend) {\n          existingTasks.push(task);\n        } else {\n          existingTasks.unshift(task);\n        }\n\n        if (returnTarget) {\n          return target;\n        }\n      };\n    };\n\n    proto[ADD_EVENT_LISTENER] = makeAddListener(nativeAddEventListener, ADD_EVENT_LISTENER_SOURCE, customSchedule, customCancel, returnTarget);\n\n    if (nativePrependEventListener) {\n      proto[PREPEND_EVENT_LISTENER] = makeAddListener(nativePrependEventListener, PREPEND_EVENT_LISTENER_SOURCE, customSchedulePrepend, customCancel, returnTarget, true);\n    }\n\n    proto[REMOVE_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (patchOptions && patchOptions.transferEventName) {\n        eventName = patchOptions.transferEventName(eventName);\n      }\n\n      const options = arguments[2];\n      const capture = !options ? false : typeof options === 'boolean' ? true : options.capture;\n      const delegate = arguments[1];\n\n      if (!delegate) {\n        return nativeRemoveEventListener.apply(this, arguments);\n      }\n\n      if (validateHandler && !validateHandler(nativeRemoveEventListener, delegate, target, arguments)) {\n        return;\n      }\n\n      const symbolEventNames = zoneSymbolEventNames[eventName];\n      let symbolEventName;\n\n      if (symbolEventNames) {\n        symbolEventName = symbolEventNames[capture ? TRUE_STR : FALSE_STR];\n      }\n\n      const existingTasks = symbolEventName && target[symbolEventName];\n\n      if (existingTasks) {\n        for (let i = 0; i < existingTasks.length; i++) {\n          const existingTask = existingTasks[i];\n\n          if (compare(existingTask, delegate)) {\n            existingTasks.splice(i, 1); // set isRemoved to data for faster invokeTask check\n\n            existingTask.isRemoved = true;\n\n            if (existingTasks.length === 0) {\n              // all tasks for the eventName + capture have gone,\n              // remove globalZoneAwareCallback and remove the task cache from target\n              existingTask.allRemoved = true;\n              target[symbolEventName] = null; // in the target, we have an event listener which is added by on_property\n              // such as target.onclick = function() {}, so we need to clear this internal\n              // property too if all delegates all removed\n\n              if (typeof eventName === 'string') {\n                const onPropertySymbol = ZONE_SYMBOL_PREFIX + 'ON_PROPERTY' + eventName;\n                target[onPropertySymbol] = null;\n              }\n            }\n\n            existingTask.zone.cancelTask(existingTask);\n\n            if (returnTarget) {\n              return target;\n            }\n\n            return;\n          }\n        }\n      } // issue 930, didn't find the event name or callback\n      // from zone kept existingTasks, the callback maybe\n      // added outside of zone, we need to call native removeEventListener\n      // to try to remove it.\n\n\n      return nativeRemoveEventListener.apply(this, arguments);\n    };\n\n    proto[LISTENERS_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (patchOptions && patchOptions.transferEventName) {\n        eventName = patchOptions.transferEventName(eventName);\n      }\n\n      const listeners = [];\n      const tasks = findEventTasks(target, eventNameToString ? eventNameToString(eventName) : eventName);\n\n      for (let i = 0; i < tasks.length; i++) {\n        const task = tasks[i];\n        let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n        listeners.push(delegate);\n      }\n\n      return listeners;\n    };\n\n    proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER] = function () {\n      const target = this || _global;\n      let eventName = arguments[0];\n\n      if (!eventName) {\n        const keys = Object.keys(target);\n\n        for (let i = 0; i < keys.length; i++) {\n          const prop = keys[i];\n          const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n          let evtName = match && match[1]; // in nodejs EventEmitter, removeListener event is\n          // used for monitoring the removeListener call,\n          // so just keep removeListener eventListener until\n          // all other eventListeners are removed\n\n          if (evtName && evtName !== 'removeListener') {\n            this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, evtName);\n          }\n        } // remove removeListener listener finally\n\n\n        this[REMOVE_ALL_LISTENERS_EVENT_LISTENER].call(this, 'removeListener');\n      } else {\n        if (patchOptions && patchOptions.transferEventName) {\n          eventName = patchOptions.transferEventName(eventName);\n        }\n\n        const symbolEventNames = zoneSymbolEventNames[eventName];\n\n        if (symbolEventNames) {\n          const symbolEventName = symbolEventNames[FALSE_STR];\n          const symbolCaptureEventName = symbolEventNames[TRUE_STR];\n          const tasks = target[symbolEventName];\n          const captureTasks = target[symbolCaptureEventName];\n\n          if (tasks) {\n            const removeTasks = tasks.slice();\n\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n\n          if (captureTasks) {\n            const removeTasks = captureTasks.slice();\n\n            for (let i = 0; i < removeTasks.length; i++) {\n              const task = removeTasks[i];\n              let delegate = task.originalDelegate ? task.originalDelegate : task.callback;\n              this[REMOVE_EVENT_LISTENER].call(this, eventName, delegate, task.options);\n            }\n          }\n        }\n      }\n\n      if (returnTarget) {\n        return this;\n      }\n    }; // for native toString patch\n\n\n    attachOriginToPatched(proto[ADD_EVENT_LISTENER], nativeAddEventListener);\n    attachOriginToPatched(proto[REMOVE_EVENT_LISTENER], nativeRemoveEventListener);\n\n    if (nativeRemoveAllListeners) {\n      attachOriginToPatched(proto[REMOVE_ALL_LISTENERS_EVENT_LISTENER], nativeRemoveAllListeners);\n    }\n\n    if (nativeListeners) {\n      attachOriginToPatched(proto[LISTENERS_EVENT_LISTENER], nativeListeners);\n    }\n\n    return true;\n  }\n\n  let results = [];\n\n  for (let i = 0; i < apis.length; i++) {\n    results[i] = patchEventTargetMethods(apis[i], patchOptions);\n  }\n\n  return results;\n}\n\nfunction findEventTasks(target, eventName) {\n  if (!eventName) {\n    const foundTasks = [];\n\n    for (let prop in target) {\n      const match = EVENT_NAME_SYMBOL_REGX.exec(prop);\n      let evtName = match && match[1];\n\n      if (evtName && (!eventName || evtName === eventName)) {\n        const tasks = target[prop];\n\n        if (tasks) {\n          for (let i = 0; i < tasks.length; i++) {\n            foundTasks.push(tasks[i]);\n          }\n        }\n      }\n    }\n\n    return foundTasks;\n  }\n\n  let symbolEventName = zoneSymbolEventNames[eventName];\n\n  if (!symbolEventName) {\n    prepareEventNames(eventName);\n    symbolEventName = zoneSymbolEventNames[eventName];\n  }\n\n  const captureFalseTasks = target[symbolEventName[FALSE_STR]];\n  const captureTrueTasks = target[symbolEventName[TRUE_STR]];\n\n  if (!captureFalseTasks) {\n    return captureTrueTasks ? captureTrueTasks.slice() : [];\n  } else {\n    return captureTrueTasks ? captureFalseTasks.concat(captureTrueTasks) : captureFalseTasks.slice();\n  }\n}\n\nfunction patchEventPrototype(global, api) {\n  const Event = global['Event'];\n\n  if (Event && Event.prototype) {\n    api.patchMethod(Event.prototype, 'stopImmediatePropagation', delegate => function (self, args) {\n      self[IMMEDIATE_PROPAGATION_SYMBOL] = true; // we need to call the native stopImmediatePropagation\n      // in case in some hybrid application, some part of\n      // application will be controlled by zone, some are not\n\n      delegate && delegate.apply(self, args);\n    });\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction patchCallbacks(api, target, targetName, method, callbacks) {\n  const symbol = Zone.__symbol__(method);\n\n  if (target[symbol]) {\n    return;\n  }\n\n  const nativeDelegate = target[symbol] = target[method];\n\n  target[method] = function (name, opts, options) {\n    if (opts && opts.prototype) {\n      callbacks.forEach(function (callback) {\n        const source = `${targetName}.${method}::` + callback;\n        const prototype = opts.prototype; // Note: the `patchCallbacks` is used for patching the `document.registerElement` and\n        // `customElements.define`. We explicitly wrap the patching code into try-catch since\n        // callbacks may be already patched by other web components frameworks (e.g. LWC), and they\n        // make those properties non-writable. This means that patching callback will throw an error\n        // `cannot assign to read-only property`. See this code as an example:\n        // https://github.com/salesforce/lwc/blob/master/packages/@lwc/engine-core/src/framework/base-bridge-element.ts#L180-L186\n        // We don't want to stop the application rendering if we couldn't patch some\n        // callback, e.g. `attributeChangedCallback`.\n\n        try {\n          if (prototype.hasOwnProperty(callback)) {\n            const descriptor = api.ObjectGetOwnPropertyDescriptor(prototype, callback);\n\n            if (descriptor && descriptor.value) {\n              descriptor.value = api.wrapWithCurrentZone(descriptor.value, source);\n\n              api._redefineProperty(opts.prototype, callback, descriptor);\n            } else if (prototype[callback]) {\n              prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n            }\n          } else if (prototype[callback]) {\n            prototype[callback] = api.wrapWithCurrentZone(prototype[callback], source);\n          }\n        } catch (_a) {// Note: we leave the catch block empty since there's no way to handle the error related\n          // to non-writable property.\n        }\n      });\n    }\n\n    return nativeDelegate.call(target, name, opts, options);\n  };\n\n  api.attachOriginToPatched(target[method], nativeDelegate);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction filterProperties(target, onProperties, ignoreProperties) {\n  if (!ignoreProperties || ignoreProperties.length === 0) {\n    return onProperties;\n  }\n\n  const tip = ignoreProperties.filter(ip => ip.target === target);\n\n  if (!tip || tip.length === 0) {\n    return onProperties;\n  }\n\n  const targetIgnoreProperties = tip[0].ignoreProperties;\n  return onProperties.filter(op => targetIgnoreProperties.indexOf(op) === -1);\n}\n\nfunction patchFilteredProperties(target, onProperties, ignoreProperties, prototype) {\n  // check whether target is available, sometimes target will be undefined\n  // because different browser or some 3rd party plugin.\n  if (!target) {\n    return;\n  }\n\n  const filteredProperties = filterProperties(target, onProperties, ignoreProperties);\n  patchOnProperties(target, filteredProperties, prototype);\n}\n/**\n * Get all event name properties which the event name startsWith `on`\n * from the target object itself, inherited properties are not considered.\n */\n\n\nfunction getOnEventNames(target) {\n  return Object.getOwnPropertyNames(target).filter(name => name.startsWith('on') && name.length > 2).map(name => name.substring(2));\n}\n\nfunction propertyDescriptorPatch(api, _global) {\n  if (isNode && !isMix) {\n    return;\n  }\n\n  if (Zone[api.symbol('patchEvents')]) {\n    // events are already been patched by legacy patch.\n    return;\n  }\n\n  const ignoreProperties = _global['__Zone_ignore_on_properties']; // for browsers that we can patch the descriptor:  Chrome & Firefox\n\n  let patchTargets = [];\n\n  if (isBrowser) {\n    const internalWindow = window;\n    patchTargets = patchTargets.concat(['Document', 'SVGElement', 'Element', 'HTMLElement', 'HTMLBodyElement', 'HTMLMediaElement', 'HTMLFrameSetElement', 'HTMLFrameElement', 'HTMLIFrameElement', 'HTMLMarqueeElement', 'Worker']);\n    const ignoreErrorProperties = isIE() ? [{\n      target: internalWindow,\n      ignoreProperties: ['error']\n    }] : []; // in IE/Edge, onProp not exist in window object, but in WindowPrototype\n    // so we need to pass WindowPrototype to check onProp exist or not\n\n    patchFilteredProperties(internalWindow, getOnEventNames(internalWindow), ignoreProperties ? ignoreProperties.concat(ignoreErrorProperties) : ignoreProperties, ObjectGetPrototypeOf(internalWindow));\n  }\n\n  patchTargets = patchTargets.concat(['XMLHttpRequest', 'XMLHttpRequestEventTarget', 'IDBIndex', 'IDBRequest', 'IDBOpenDBRequest', 'IDBDatabase', 'IDBTransaction', 'IDBCursor', 'WebSocket']);\n\n  for (let i = 0; i < patchTargets.length; i++) {\n    const target = _global[patchTargets[i]];\n    target && target.prototype && patchFilteredProperties(target.prototype, getOnEventNames(target.prototype), ignoreProperties);\n  }\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('util', (global, Zone, api) => {\n  // Collect native event names by looking at properties\n  // on the global namespace, e.g. 'onclick'.\n  const eventNames = getOnEventNames(global);\n  api.patchOnProperties = patchOnProperties;\n  api.patchMethod = patchMethod;\n  api.bindArguments = bindArguments;\n  api.patchMacroTask = patchMacroTask; // In earlier version of zone.js (<0.9.0), we use env name `__zone_symbol__BLACK_LISTED_EVENTS` to\n  // define which events will not be patched by `Zone.js`.\n  // In newer version (>=0.9.0), we change the env name to `__zone_symbol__UNPATCHED_EVENTS` to keep\n  // the name consistent with angular repo.\n  // The  `__zone_symbol__BLACK_LISTED_EVENTS` is deprecated, but it is still be supported for\n  // backwards compatibility.\n\n  const SYMBOL_BLACK_LISTED_EVENTS = Zone.__symbol__('BLACK_LISTED_EVENTS');\n\n  const SYMBOL_UNPATCHED_EVENTS = Zone.__symbol__('UNPATCHED_EVENTS');\n\n  if (global[SYMBOL_UNPATCHED_EVENTS]) {\n    global[SYMBOL_BLACK_LISTED_EVENTS] = global[SYMBOL_UNPATCHED_EVENTS];\n  }\n\n  if (global[SYMBOL_BLACK_LISTED_EVENTS]) {\n    Zone[SYMBOL_BLACK_LISTED_EVENTS] = Zone[SYMBOL_UNPATCHED_EVENTS] = global[SYMBOL_BLACK_LISTED_EVENTS];\n  }\n\n  api.patchEventPrototype = patchEventPrototype;\n  api.patchEventTarget = patchEventTarget;\n  api.isIEOrEdge = isIEOrEdge;\n  api.ObjectDefineProperty = ObjectDefineProperty;\n  api.ObjectGetOwnPropertyDescriptor = ObjectGetOwnPropertyDescriptor;\n  api.ObjectCreate = ObjectCreate;\n  api.ArraySlice = ArraySlice;\n  api.patchClass = patchClass;\n  api.wrapWithCurrentZone = wrapWithCurrentZone;\n  api.filterProperties = filterProperties;\n  api.attachOriginToPatched = attachOriginToPatched;\n  api._redefineProperty = Object.defineProperty;\n  api.patchCallbacks = patchCallbacks;\n\n  api.getGlobalObjects = () => ({\n    globalSources,\n    zoneSymbolEventNames,\n    eventNames,\n    isBrowser,\n    isMix,\n    isNode,\n    TRUE_STR,\n    FALSE_STR,\n    ZONE_SYMBOL_PREFIX,\n    ADD_EVENT_LISTENER_STR,\n    REMOVE_EVENT_LISTENER_STR\n  });\n});\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nconst taskSymbol = zoneSymbol('zoneTask');\n\nfunction patchTimer(window, setName, cancelName, nameSuffix) {\n  let setNative = null;\n  let clearNative = null;\n  setName += nameSuffix;\n  cancelName += nameSuffix;\n  const tasksByHandleId = {};\n\n  function scheduleTask(task) {\n    const data = task.data;\n\n    data.args[0] = function () {\n      return task.invoke.apply(this, arguments);\n    };\n\n    data.handleId = setNative.apply(window, data.args);\n    return task;\n  }\n\n  function clearTask(task) {\n    return clearNative.call(window, task.data.handleId);\n  }\n\n  setNative = patchMethod(window, setName, delegate => function (self, args) {\n    if (typeof args[0] === 'function') {\n      const options = {\n        isPeriodic: nameSuffix === 'Interval',\n        delay: nameSuffix === 'Timeout' || nameSuffix === 'Interval' ? args[1] || 0 : undefined,\n        args: args\n      };\n      const callback = args[0];\n\n      args[0] = function timer() {\n        try {\n          return callback.apply(this, arguments);\n        } finally {\n          // issue-934, task will be cancelled\n          // even it is a periodic task such as\n          // setInterval\n          // https://github.com/angular/angular/issues/40387\n          // Cleanup tasksByHandleId should be handled before scheduleTask\n          // Since some zoneSpec may intercept and doesn't trigger\n          // scheduleFn(scheduleTask) provided here.\n          if (!options.isPeriodic) {\n            if (typeof options.handleId === 'number') {\n              // in non-nodejs env, we remove timerId\n              // from local cache\n              delete tasksByHandleId[options.handleId];\n            } else if (options.handleId) {\n              // Node returns complex objects as handleIds\n              // we remove task reference from timer object\n              options.handleId[taskSymbol] = null;\n            }\n          }\n        }\n      };\n\n      const task = scheduleMacroTaskWithCurrentZone(setName, args[0], options, scheduleTask, clearTask);\n\n      if (!task) {\n        return task;\n      } // Node.js must additionally support the ref and unref functions.\n\n\n      const handle = task.data.handleId;\n\n      if (typeof handle === 'number') {\n        // for non nodejs env, we save handleId: task\n        // mapping in local cache for clearTimeout\n        tasksByHandleId[handle] = task;\n      } else if (handle) {\n        // for nodejs env, we save task\n        // reference in timerId Object for clearTimeout\n        handle[taskSymbol] = task;\n      } // check whether handle is null, because some polyfill or browser\n      // may return undefined from setTimeout/setInterval/setImmediate/requestAnimationFrame\n\n\n      if (handle && handle.ref && handle.unref && typeof handle.ref === 'function' && typeof handle.unref === 'function') {\n        task.ref = handle.ref.bind(handle);\n        task.unref = handle.unref.bind(handle);\n      }\n\n      if (typeof handle === 'number' || handle) {\n        return handle;\n      }\n\n      return task;\n    } else {\n      // cause an error by calling it directly.\n      return delegate.apply(window, args);\n    }\n  });\n  clearNative = patchMethod(window, cancelName, delegate => function (self, args) {\n    const id = args[0];\n    let task;\n\n    if (typeof id === 'number') {\n      // non nodejs env.\n      task = tasksByHandleId[id];\n    } else {\n      // nodejs env.\n      task = id && id[taskSymbol]; // other environments.\n\n      if (!task) {\n        task = id;\n      }\n    }\n\n    if (task && typeof task.type === 'string') {\n      if (task.state !== 'notScheduled' && (task.cancelFn && task.data.isPeriodic || task.runCount === 0)) {\n        if (typeof id === 'number') {\n          delete tasksByHandleId[id];\n        } else if (id) {\n          id[taskSymbol] = null;\n        } // Do not cancel already canceled functions\n\n\n        task.zone.cancelTask(task);\n      }\n    } else {\n      // cause an error by calling it directly.\n      delegate.apply(window, args);\n    }\n  });\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction patchCustomElements(_global, api) {\n  const {\n    isBrowser,\n    isMix\n  } = api.getGlobalObjects();\n\n  if (!isBrowser && !isMix || !_global['customElements'] || !('customElements' in _global)) {\n    return;\n  }\n\n  const callbacks = ['connectedCallback', 'disconnectedCallback', 'adoptedCallback', 'attributeChangedCallback'];\n  api.patchCallbacks(api, _global.customElements, 'customElements', 'define', callbacks);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nfunction eventTargetPatch(_global, api) {\n  if (Zone[api.symbol('patchEventTarget')]) {\n    // EventTarget is already patched.\n    return;\n  }\n\n  const {\n    eventNames,\n    zoneSymbolEventNames,\n    TRUE_STR,\n    FALSE_STR,\n    ZONE_SYMBOL_PREFIX\n  } = api.getGlobalObjects(); //  predefine all __zone_symbol__ + eventName + true/false string\n\n  for (let i = 0; i < eventNames.length; i++) {\n    const eventName = eventNames[i];\n    const falseEventName = eventName + FALSE_STR;\n    const trueEventName = eventName + TRUE_STR;\n    const symbol = ZONE_SYMBOL_PREFIX + falseEventName;\n    const symbolCapture = ZONE_SYMBOL_PREFIX + trueEventName;\n    zoneSymbolEventNames[eventName] = {};\n    zoneSymbolEventNames[eventName][FALSE_STR] = symbol;\n    zoneSymbolEventNames[eventName][TRUE_STR] = symbolCapture;\n  }\n\n  const EVENT_TARGET = _global['EventTarget'];\n\n  if (!EVENT_TARGET || !EVENT_TARGET.prototype) {\n    return;\n  }\n\n  api.patchEventTarget(_global, api, [EVENT_TARGET && EVENT_TARGET.prototype]);\n  return true;\n}\n\nfunction patchEvent(global, api) {\n  api.patchEventPrototype(global, api);\n}\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nZone.__load_patch('legacy', global => {\n  const legacyPatch = global[Zone.__symbol__('legacyPatch')];\n\n  if (legacyPatch) {\n    legacyPatch();\n  }\n});\n\nZone.__load_patch('queueMicrotask', (global, Zone, api) => {\n  api.patchMethod(global, 'queueMicrotask', delegate => {\n    return function (self, args) {\n      Zone.current.scheduleMicroTask('queueMicrotask', args[0]);\n    };\n  });\n});\n\nZone.__load_patch('timers', global => {\n  const set = 'set';\n  const clear = 'clear';\n  patchTimer(global, set, clear, 'Timeout');\n  patchTimer(global, set, clear, 'Interval');\n  patchTimer(global, set, clear, 'Immediate');\n});\n\nZone.__load_patch('requestAnimationFrame', global => {\n  patchTimer(global, 'request', 'cancel', 'AnimationFrame');\n  patchTimer(global, 'mozRequest', 'mozCancel', 'AnimationFrame');\n  patchTimer(global, 'webkitRequest', 'webkitCancel', 'AnimationFrame');\n});\n\nZone.__load_patch('blocking', (global, Zone) => {\n  const blockingMethods = ['alert', 'prompt', 'confirm'];\n\n  for (let i = 0; i < blockingMethods.length; i++) {\n    const name = blockingMethods[i];\n    patchMethod(global, name, (delegate, symbol, name) => {\n      return function (s, args) {\n        return Zone.current.run(delegate, global, args, name);\n      };\n    });\n  }\n});\n\nZone.__load_patch('EventTarget', (global, Zone, api) => {\n  patchEvent(global, api);\n  eventTargetPatch(global, api); // patch XMLHttpRequestEventTarget's addEventListener/removeEventListener\n\n  const XMLHttpRequestEventTarget = global['XMLHttpRequestEventTarget'];\n\n  if (XMLHttpRequestEventTarget && XMLHttpRequestEventTarget.prototype) {\n    api.patchEventTarget(global, api, [XMLHttpRequestEventTarget.prototype]);\n  }\n});\n\nZone.__load_patch('MutationObserver', (global, Zone, api) => {\n  patchClass('MutationObserver');\n  patchClass('WebKitMutationObserver');\n});\n\nZone.__load_patch('IntersectionObserver', (global, Zone, api) => {\n  patchClass('IntersectionObserver');\n});\n\nZone.__load_patch('FileReader', (global, Zone, api) => {\n  patchClass('FileReader');\n});\n\nZone.__load_patch('on_property', (global, Zone, api) => {\n  propertyDescriptorPatch(api, global);\n});\n\nZone.__load_patch('customElements', (global, Zone, api) => {\n  patchCustomElements(global, api);\n});\n\nZone.__load_patch('XHR', (global, Zone) => {\n  // Treat XMLHttpRequest as a macrotask.\n  patchXHR(global);\n  const XHR_TASK = zoneSymbol('xhrTask');\n  const XHR_SYNC = zoneSymbol('xhrSync');\n  const XHR_LISTENER = zoneSymbol('xhrListener');\n  const XHR_SCHEDULED = zoneSymbol('xhrScheduled');\n  const XHR_URL = zoneSymbol('xhrURL');\n  const XHR_ERROR_BEFORE_SCHEDULED = zoneSymbol('xhrErrorBeforeScheduled');\n\n  function patchXHR(window) {\n    const XMLHttpRequest = window['XMLHttpRequest'];\n\n    if (!XMLHttpRequest) {\n      // XMLHttpRequest is not available in service worker\n      return;\n    }\n\n    const XMLHttpRequestPrototype = XMLHttpRequest.prototype;\n\n    function findPendingTask(target) {\n      return target[XHR_TASK];\n    }\n\n    let oriAddListener = XMLHttpRequestPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n    let oriRemoveListener = XMLHttpRequestPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n\n    if (!oriAddListener) {\n      const XMLHttpRequestEventTarget = window['XMLHttpRequestEventTarget'];\n\n      if (XMLHttpRequestEventTarget) {\n        const XMLHttpRequestEventTargetPrototype = XMLHttpRequestEventTarget.prototype;\n        oriAddListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        oriRemoveListener = XMLHttpRequestEventTargetPrototype[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n      }\n    }\n\n    const READY_STATE_CHANGE = 'readystatechange';\n    const SCHEDULED = 'scheduled';\n\n    function scheduleTask(task) {\n      const data = task.data;\n      const target = data.target;\n      target[XHR_SCHEDULED] = false;\n      target[XHR_ERROR_BEFORE_SCHEDULED] = false; // remove existing event listener\n\n      const listener = target[XHR_LISTENER];\n\n      if (!oriAddListener) {\n        oriAddListener = target[ZONE_SYMBOL_ADD_EVENT_LISTENER];\n        oriRemoveListener = target[ZONE_SYMBOL_REMOVE_EVENT_LISTENER];\n      }\n\n      if (listener) {\n        oriRemoveListener.call(target, READY_STATE_CHANGE, listener);\n      }\n\n      const newListener = target[XHR_LISTENER] = () => {\n        if (target.readyState === target.DONE) {\n          // sometimes on some browsers XMLHttpRequest will fire onreadystatechange with\n          // readyState=4 multiple times, so we need to check task state here\n          if (!data.aborted && target[XHR_SCHEDULED] && task.state === SCHEDULED) {\n            // check whether the xhr has registered onload listener\n            // if that is the case, the task should invoke after all\n            // onload listeners finish.\n            // Also if the request failed without response (status = 0), the load event handler\n            // will not be triggered, in that case, we should also invoke the placeholder callback\n            // to close the XMLHttpRequest::send macroTask.\n            // https://github.com/angular/angular/issues/38795\n            const loadTasks = target[Zone.__symbol__('loadfalse')];\n\n            if (target.status !== 0 && loadTasks && loadTasks.length > 0) {\n              const oriInvoke = task.invoke;\n\n              task.invoke = function () {\n                // need to load the tasks again, because in other\n                // load listener, they may remove themselves\n                const loadTasks = target[Zone.__symbol__('loadfalse')];\n\n                for (let i = 0; i < loadTasks.length; i++) {\n                  if (loadTasks[i] === task) {\n                    loadTasks.splice(i, 1);\n                  }\n                }\n\n                if (!data.aborted && task.state === SCHEDULED) {\n                  oriInvoke.call(task);\n                }\n              };\n\n              loadTasks.push(task);\n            } else {\n              task.invoke();\n            }\n          } else if (!data.aborted && target[XHR_SCHEDULED] === false) {\n            // error occurs when xhr.send()\n            target[XHR_ERROR_BEFORE_SCHEDULED] = true;\n          }\n        }\n      };\n\n      oriAddListener.call(target, READY_STATE_CHANGE, newListener);\n      const storedTask = target[XHR_TASK];\n\n      if (!storedTask) {\n        target[XHR_TASK] = task;\n      }\n\n      sendNative.apply(target, data.args);\n      target[XHR_SCHEDULED] = true;\n      return task;\n    }\n\n    function placeholderCallback() {}\n\n    function clearTask(task) {\n      const data = task.data; // Note - ideally, we would call data.target.removeEventListener here, but it's too late\n      // to prevent it from firing. So instead, we store info for the event listener.\n\n      data.aborted = true;\n      return abortNative.apply(data.target, data.args);\n    }\n\n    const openNative = patchMethod(XMLHttpRequestPrototype, 'open', () => function (self, args) {\n      self[XHR_SYNC] = args[2] == false;\n      self[XHR_URL] = args[1];\n      return openNative.apply(self, args);\n    });\n    const XMLHTTPREQUEST_SOURCE = 'XMLHttpRequest.send';\n    const fetchTaskAborting = zoneSymbol('fetchTaskAborting');\n    const fetchTaskScheduling = zoneSymbol('fetchTaskScheduling');\n    const sendNative = patchMethod(XMLHttpRequestPrototype, 'send', () => function (self, args) {\n      if (Zone.current[fetchTaskScheduling] === true) {\n        // a fetch is scheduling, so we are using xhr to polyfill fetch\n        // and because we already schedule macroTask for fetch, we should\n        // not schedule a macroTask for xhr again\n        return sendNative.apply(self, args);\n      }\n\n      if (self[XHR_SYNC]) {\n        // if the XHR is sync there is no task to schedule, just execute the code.\n        return sendNative.apply(self, args);\n      } else {\n        const options = {\n          target: self,\n          url: self[XHR_URL],\n          isPeriodic: false,\n          args: args,\n          aborted: false\n        };\n        const task = scheduleMacroTaskWithCurrentZone(XMLHTTPREQUEST_SOURCE, placeholderCallback, options, scheduleTask, clearTask);\n\n        if (self && self[XHR_ERROR_BEFORE_SCHEDULED] === true && !options.aborted && task.state === SCHEDULED) {\n          // xhr request throw error when send\n          // we should invoke task instead of leaving a scheduled\n          // pending macroTask\n          task.invoke();\n        }\n      }\n    });\n    const abortNative = patchMethod(XMLHttpRequestPrototype, 'abort', () => function (self, args) {\n      const task = findPendingTask(self);\n\n      if (task && typeof task.type == 'string') {\n        // If the XHR has already completed, do nothing.\n        // If the XHR has already been aborted, do nothing.\n        // Fix #569, call abort multiple times before done will cause\n        // macroTask task count be negative number\n        if (task.cancelFn == null || task.data && task.data.aborted) {\n          return;\n        }\n\n        task.zone.cancelTask(task);\n      } else if (Zone.current[fetchTaskAborting] === true) {\n        // the abort is called from fetch polyfill, we need to call native abort of XHR.\n        return abortNative.apply(self, args);\n      } // Otherwise, we are trying to abort an XHR which has not yet been sent, so there is no\n      // task\n      // to cancel. Do nothing.\n\n    });\n  }\n});\n\nZone.__load_patch('geolocation', global => {\n  /// GEO_LOCATION\n  if (global['navigator'] && global['navigator'].geolocation) {\n    patchPrototype(global['navigator'].geolocation, ['getCurrentPosition', 'watchPosition']);\n  }\n});\n\nZone.__load_patch('PromiseRejectionEvent', (global, Zone) => {\n  // handle unhandled promise rejection\n  function findPromiseRejectionHandler(evtName) {\n    return function (e) {\n      const eventTasks = findEventTasks(global, evtName);\n      eventTasks.forEach(eventTask => {\n        // windows has added unhandledrejection event listener\n        // trigger the event listener\n        const PromiseRejectionEvent = global['PromiseRejectionEvent'];\n\n        if (PromiseRejectionEvent) {\n          const evt = new PromiseRejectionEvent(evtName, {\n            promise: e.promise,\n            reason: e.rejection\n          });\n          eventTask.invoke(evt);\n        }\n      });\n    };\n  }\n\n  if (global['PromiseRejectionEvent']) {\n    Zone[zoneSymbol('unhandledPromiseRejectionHandler')] = findPromiseRejectionHandler('unhandledrejection');\n    Zone[zoneSymbol('rejectionHandledHandler')] = findPromiseRejectionHandler('rejectionhandled');\n  }\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxDQUFDLG9CQUFELEVBQXVCLGVBQXZCLENBQWxDLENBQWQ7RUFDSDtBQUNKLENBTEQ7O0FBTUFqakIsSUFBSSxDQUFDa0IsWUFBTCxDQUFrQix1QkFBbEIsRUFBMkMsQ0FBQzVCLE1BQUQsRUFBU1UsSUFBVCxLQUFrQjtFQUN6RDtFQUNBLFNBQVNrakIsMkJBQVQsQ0FBcUM1RixPQUFyQyxFQUE4QztJQUMxQyxPQUFPLFVBQVU1TCxDQUFWLEVBQWE7TUFDaEIsTUFBTXlSLFVBQVUsR0FBR2pHLGNBQWMsQ0FBQzVkLE1BQUQsRUFBU2dlLE9BQVQsQ0FBakM7TUFDQTZGLFVBQVUsQ0FBQzlFLE9BQVgsQ0FBbUJ0YixTQUFTLElBQUk7UUFDNUI7UUFDQTtRQUNBLE1BQU1xZ0IscUJBQXFCLEdBQUc5akIsTUFBTSxDQUFDLHVCQUFELENBQXBDOztRQUNBLElBQUk4akIscUJBQUosRUFBMkI7VUFDdkIsTUFBTUMsR0FBRyxHQUFHLElBQUlELHFCQUFKLENBQTBCOUYsT0FBMUIsRUFBbUM7WUFBRWxLLE9BQU8sRUFBRTFCLENBQUMsQ0FBQzBCLE9BQWI7WUFBc0I0QyxNQUFNLEVBQUV0RSxDQUFDLENBQUNDO1VBQWhDLENBQW5DLENBQVo7VUFDQTVPLFNBQVMsQ0FBQ1QsTUFBVixDQUFpQitnQixHQUFqQjtRQUNIO01BQ0osQ0FSRDtJQVNILENBWEQ7RUFZSDs7RUFDRCxJQUFJL2pCLE1BQU0sQ0FBQyx1QkFBRCxDQUFWLEVBQXFDO0lBQ2pDVSxJQUFJLENBQUM2TSxVQUFVLENBQUMsa0NBQUQsQ0FBWCxDQUFKLEdBQ0lxVywyQkFBMkIsQ0FBQyxvQkFBRCxDQUQvQjtJQUVBbGpCLElBQUksQ0FBQzZNLFVBQVUsQ0FBQyx5QkFBRCxDQUFYLENBQUosR0FDSXFXLDJCQUEyQixDQUFDLGtCQUFELENBRC9CO0VBRUg7QUFDSixDQXRCRCIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYnZpZXctdWkvLi9ub2RlX21vZHVsZXMvem9uZS5qcy9mZXNtMjAxNS96b25lLmpzPzUzY2UiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBAbGljZW5zZSBBbmd1bGFyIHYxNC4yLjAtbmV4dC4wXG4gKiAoYykgMjAxMC0yMDIyIEdvb2dsZSBMTEMuIGh0dHBzOi8vYW5ndWxhci5pby9cbiAqIExpY2Vuc2U6IE1JVFxuICovXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbigoZnVuY3Rpb24gKGdsb2JhbCkge1xuICAgIGNvbnN0IHBlcmZvcm1hbmNlID0gZ2xvYmFsWydwZXJmb3JtYW5jZSddO1xuICAgIGZ1bmN0aW9uIG1hcmsobmFtZSkge1xuICAgICAgICBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZVsnbWFyayddICYmIHBlcmZvcm1hbmNlWydtYXJrJ10obmFtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBlcmZvcm1hbmNlTWVhc3VyZShuYW1lLCBsYWJlbCkge1xuICAgICAgICBwZXJmb3JtYW5jZSAmJiBwZXJmb3JtYW5jZVsnbWVhc3VyZSddICYmIHBlcmZvcm1hbmNlWydtZWFzdXJlJ10obmFtZSwgbGFiZWwpO1xuICAgIH1cbiAgICBtYXJrKCdab25lJyk7XG4gICAgLy8gSW5pdGlhbGl6ZSBiZWZvcmUgaXQncyBhY2Nlc3NlZCBiZWxvdy5cbiAgICAvLyBfX1pvbmVfc3ltYm9sX3ByZWZpeCBnbG9iYWwgY2FuIGJlIHVzZWQgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgem9uZVxuICAgIC8vIHN5bWJvbCBwcmVmaXggd2l0aCBhIGN1c3RvbSBvbmUgaWYgbmVlZGVkLlxuICAgIGNvbnN0IHN5bWJvbFByZWZpeCA9IGdsb2JhbFsnX19ab25lX3N5bWJvbF9wcmVmaXgnXSB8fCAnX196b25lX3N5bWJvbF9fJztcbiAgICBmdW5jdGlvbiBfX3N5bWJvbF9fKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHN5bWJvbFByZWZpeCArIG5hbWU7XG4gICAgfVxuICAgIGNvbnN0IGNoZWNrRHVwbGljYXRlID0gZ2xvYmFsW19fc3ltYm9sX18oJ2ZvcmNlRHVwbGljYXRlWm9uZUNoZWNrJyldID09PSB0cnVlO1xuICAgIGlmIChnbG9iYWxbJ1pvbmUnXSkge1xuICAgICAgICAvLyBpZiBnbG9iYWxbJ1pvbmUnXSBhbHJlYWR5IGV4aXN0cyAobWF5YmUgem9uZS5qcyB3YXMgYWxyZWFkeSBsb2FkZWQgb3JcbiAgICAgICAgLy8gc29tZSBvdGhlciBsaWIgYWxzbyByZWdpc3RlcmVkIGEgZ2xvYmFsIG9iamVjdCBuYW1lZCBab25lKSwgd2UgbWF5IG5lZWRcbiAgICAgICAgLy8gdG8gdGhyb3cgYW4gZXJyb3IsIGJ1dCBzb21ldGltZXMgdXNlciBtYXkgbm90IHdhbnQgdGhpcyBlcnJvci5cbiAgICAgICAgLy8gRm9yIGV4YW1wbGUsXG4gICAgICAgIC8vIHdlIGhhdmUgdHdvIHdlYiBwYWdlcywgcGFnZTEgaW5jbHVkZXMgem9uZS5qcywgcGFnZTIgZG9lc24ndC5cbiAgICAgICAgLy8gYW5kIHRoZSAxc3QgdGltZSB1c2VyIGxvYWQgcGFnZTEgYW5kIHBhZ2UyLCBldmVyeXRoaW5nIHdvcmsgZmluZSxcbiAgICAgICAgLy8gYnV0IHdoZW4gdXNlciBsb2FkIHBhZ2UyIGFnYWluLCBlcnJvciBvY2N1cnMgYmVjYXVzZSBnbG9iYWxbJ1pvbmUnXSBhbHJlYWR5IGV4aXN0cy5cbiAgICAgICAgLy8gc28gd2UgYWRkIGEgZmxhZyB0byBsZXQgdXNlciBjaG9vc2Ugd2hldGhlciB0byB0aHJvdyB0aGlzIGVycm9yIG9yIG5vdC5cbiAgICAgICAgLy8gQnkgZGVmYXVsdCwgaWYgZXhpc3RpbmcgWm9uZSBpcyBmcm9tIHpvbmUuanMsIHdlIHdpbGwgbm90IHRocm93IHRoZSBlcnJvci5cbiAgICAgICAgaWYgKGNoZWNrRHVwbGljYXRlIHx8IHR5cGVvZiBnbG9iYWxbJ1pvbmUnXS5fX3N5bWJvbF9fICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmUgYWxyZWFkeSBsb2FkZWQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsWydab25lJ107XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xhc3MgWm9uZSB7XG4gICAgICAgIGNvbnN0cnVjdG9yKHBhcmVudCwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcbiAgICAgICAgICAgIHRoaXMuX25hbWUgPSB6b25lU3BlYyA/IHpvbmVTcGVjLm5hbWUgfHwgJ3VubmFtZWQnIDogJzxyb290Pic7XG4gICAgICAgICAgICB0aGlzLl9wcm9wZXJ0aWVzID0gem9uZVNwZWMgJiYgem9uZVNwZWMucHJvcGVydGllcyB8fCB7fTtcbiAgICAgICAgICAgIHRoaXMuX3pvbmVEZWxlZ2F0ZSA9XG4gICAgICAgICAgICAgICAgbmV3IF9ab25lRGVsZWdhdGUodGhpcywgdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fem9uZURlbGVnYXRlLCB6b25lU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFzc2VydFpvbmVQYXRjaGVkKCkge1xuICAgICAgICAgICAgaWYgKGdsb2JhbFsnUHJvbWlzZSddICE9PSBwYXRjaGVzWydab25lQXdhcmVQcm9taXNlJ10pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmUuanMgaGFzIGRldGVjdGVkIHRoYXQgWm9uZUF3YXJlUHJvbWlzZSBgKHdpbmRvd3xnbG9iYWwpLlByb21pc2VgICcgK1xuICAgICAgICAgICAgICAgICAgICAnaGFzIGJlZW4gb3ZlcndyaXR0ZW4uXFxuJyArXG4gICAgICAgICAgICAgICAgICAgICdNb3N0IGxpa2VseSBjYXVzZSBpcyB0aGF0IGEgUHJvbWlzZSBwb2x5ZmlsbCBoYXMgYmVlbiBsb2FkZWQgJyArXG4gICAgICAgICAgICAgICAgICAgICdhZnRlciBab25lLmpzIChQb2x5ZmlsbGluZyBQcm9taXNlIGFwaSBpcyBub3QgbmVjZXNzYXJ5IHdoZW4gem9uZS5qcyBpcyBsb2FkZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAnSWYgeW91IG11c3QgbG9hZCBvbmUsIGRvIHNvIGJlZm9yZSBsb2FkaW5nIHpvbmUuanMuKScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBnZXQgcm9vdCgpIHtcbiAgICAgICAgICAgIGxldCB6b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgd2hpbGUgKHpvbmUucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgem9uZSA9IHpvbmUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBjdXJyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIF9jdXJyZW50Wm9uZUZyYW1lLnpvbmU7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGdldCBjdXJyZW50VGFzaygpIHtcbiAgICAgICAgICAgIHJldHVybiBfY3VycmVudFRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnJlcXVpcmUtaW50ZXJuYWwtd2l0aC11bmRlcnNjb3JlXG4gICAgICAgIHN0YXRpYyBfX2xvYWRfcGF0Y2gobmFtZSwgZm4sIGlnbm9yZUR1cGxpY2F0ZSA9IGZhbHNlKSB7XG4gICAgICAgICAgICBpZiAocGF0Y2hlcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIGBjaGVja0R1cGxpY2F0ZWAgb3B0aW9uIGlzIGRlZmluZWQgZnJvbSBnbG9iYWwgdmFyaWFibGVcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCB3b3JrcyBmb3IgYWxsIG1vZHVsZXMuXG4gICAgICAgICAgICAgICAgLy8gYGlnbm9yZUR1cGxpY2F0ZWAgY2FuIHdvcmsgZm9yIHRoZSBzcGVjaWZpZWQgbW9kdWxlXG4gICAgICAgICAgICAgICAgaWYgKCFpZ25vcmVEdXBsaWNhdGUgJiYgY2hlY2tEdXBsaWNhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FscmVhZHkgbG9hZGVkIHBhdGNoOiAnICsgbmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWdsb2JhbFsnX19ab25lX2Rpc2FibGVfJyArIG5hbWVdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVyZk5hbWUgPSAnWm9uZTonICsgbmFtZTtcbiAgICAgICAgICAgICAgICBtYXJrKHBlcmZOYW1lKTtcbiAgICAgICAgICAgICAgICBwYXRjaGVzW25hbWVdID0gZm4oZ2xvYmFsLCBab25lLCBfYXBpKTtcbiAgICAgICAgICAgICAgICBwZXJmb3JtYW5jZU1lYXN1cmUocGVyZk5hbWUsIHBlcmZOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgcGFyZW50KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhcmVudDtcbiAgICAgICAgfVxuICAgICAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9uYW1lO1xuICAgICAgICB9XG4gICAgICAgIGdldChrZXkpIHtcbiAgICAgICAgICAgIGNvbnN0IHpvbmUgPSB0aGlzLmdldFpvbmVXaXRoKGtleSk7XG4gICAgICAgICAgICBpZiAoem9uZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gem9uZS5fcHJvcGVydGllc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGdldFpvbmVXaXRoKGtleSkge1xuICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudC5fcHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5fcGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgZm9yayh6b25lU3BlYykge1xuICAgICAgICAgICAgaWYgKCF6b25lU3BlYylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1pvbmVTcGVjIHJlcXVpcmVkIScpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmVEZWxlZ2F0ZS5mb3JrKHRoaXMsIHpvbmVTcGVjKTtcbiAgICAgICAgfVxuICAgICAgICB3cmFwKGNhbGxiYWNrLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGluZyBmdW5jdGlvbiBnb3Q6ICcgKyBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBfY2FsbGJhY2sgPSB0aGlzLl96b25lRGVsZWdhdGUuaW50ZXJjZXB0KHRoaXMsIGNhbGxiYWNrLCBzb3VyY2UpO1xuICAgICAgICAgICAgY29uc3Qgem9uZSA9IHRoaXM7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB6b25lLnJ1bkd1YXJkZWQoX2NhbGxiYWNrLCB0aGlzLCBhcmd1bWVudHMsIHNvdXJjZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJ1bihjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkge1xuICAgICAgICAgICAgX2N1cnJlbnRab25lRnJhbWUgPSB7IHBhcmVudDogX2N1cnJlbnRab25lRnJhbWUsIHpvbmU6IHRoaXMgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmVEZWxlZ2F0ZS5pbnZva2UodGhpcywgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICAgICAgX2N1cnJlbnRab25lRnJhbWUgPSBfY3VycmVudFpvbmVGcmFtZS5wYXJlbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcnVuR3VhcmRlZChjYWxsYmFjaywgYXBwbHlUaGlzID0gbnVsbCwgYXBwbHlBcmdzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIF9jdXJyZW50Wm9uZUZyYW1lID0geyBwYXJlbnQ6IF9jdXJyZW50Wm9uZUZyYW1lLCB6b25lOiB0aGlzIH07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuaW52b2tlKHRoaXMsIGNhbGxiYWNrLCBhcHBseVRoaXMsIGFwcGx5QXJncywgc291cmNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl96b25lRGVsZWdhdGUuaGFuZGxlRXJyb3IodGhpcywgZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIF9jdXJyZW50Wm9uZUZyYW1lID0gX2N1cnJlbnRab25lRnJhbWUucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJ1blRhc2sodGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIHtcbiAgICAgICAgICAgIGlmICh0YXNrLnpvbmUgIT0gdGhpcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQSB0YXNrIGNhbiBvbmx5IGJlIHJ1biBpbiB0aGUgem9uZSBvZiBjcmVhdGlvbiEgKENyZWF0aW9uOiAnICtcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suem9uZSB8fCBOT19aT05FKS5uYW1lICsgJzsgRXhlY3V0aW9uOiAnICsgdGhpcy5uYW1lICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzc3OCwgc29tZXRpbWVzIGV2ZW50VGFza1xuICAgICAgICAgICAgLy8gd2lsbCBydW4gaW4gbm90U2NoZWR1bGVkKGNhbmNlbGVkKSBzdGF0ZSwgd2Ugc2hvdWxkIG5vdCB0cnkgdG9cbiAgICAgICAgICAgIC8vIHJ1biBzdWNoIGtpbmQgb2YgdGFzayBidXQganVzdCByZXR1cm5cbiAgICAgICAgICAgIGlmICh0YXNrLnN0YXRlID09PSBub3RTY2hlZHVsZWQgJiYgKHRhc2sudHlwZSA9PT0gZXZlbnRUYXNrIHx8IHRhc2sudHlwZSA9PT0gbWFjcm9UYXNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlRW50cnlHdWFyZCA9IHRhc2suc3RhdGUgIT0gcnVubmluZztcbiAgICAgICAgICAgIHJlRW50cnlHdWFyZCAmJiB0YXNrLl90cmFuc2l0aW9uVG8ocnVubmluZywgc2NoZWR1bGVkKTtcbiAgICAgICAgICAgIHRhc2sucnVuQ291bnQrKztcbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVGFzayA9IF9jdXJyZW50VGFzaztcbiAgICAgICAgICAgIF9jdXJyZW50VGFzayA9IHRhc2s7XG4gICAgICAgICAgICBfY3VycmVudFpvbmVGcmFtZSA9IHsgcGFyZW50OiBfY3VycmVudFpvbmVGcmFtZSwgem9uZTogdGhpcyB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodGFzay50eXBlID09IG1hY3JvVGFzayAmJiB0YXNrLmRhdGEgJiYgIXRhc2suZGF0YS5pc1BlcmlvZGljKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suY2FuY2VsRm4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl96b25lRGVsZWdhdGUuaW52b2tlVGFzayh0aGlzLCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fem9uZURlbGVnYXRlLmhhbmRsZUVycm9yKHRoaXMsIGVycm9yKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgdGFzaydzIHN0YXRlIGlzIG5vdFNjaGVkdWxlZCBvciB1bmtub3duLCB0aGVuIGl0IGhhcyBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgICAgICAgICAgICAgLy8gd2Ugc2hvdWxkIG5vdCByZXNldCB0aGUgc3RhdGUgdG8gc2NoZWR1bGVkXG4gICAgICAgICAgICAgICAgaWYgKHRhc2suc3RhdGUgIT09IG5vdFNjaGVkdWxlZCAmJiB0YXNrLnN0YXRlICE9PSB1bmtub3duKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrLnR5cGUgPT0gZXZlbnRUYXNrIHx8ICh0YXNrLmRhdGEgJiYgdGFzay5kYXRhLmlzUGVyaW9kaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZUVudHJ5R3VhcmQgJiYgdGFzay5fdHJhbnNpdGlvblRvKHNjaGVkdWxlZCwgcnVubmluZyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnJ1bkNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRhc2tDb3VudCh0YXNrLCAtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZUVudHJ5R3VhcmQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8obm90U2NoZWR1bGVkLCBydW5uaW5nLCBub3RTY2hlZHVsZWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9jdXJyZW50Wm9uZUZyYW1lID0gX2N1cnJlbnRab25lRnJhbWUucGFyZW50O1xuICAgICAgICAgICAgICAgIF9jdXJyZW50VGFzayA9IHByZXZpb3VzVGFzaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZVRhc2sodGFzaykge1xuICAgICAgICAgICAgaWYgKHRhc2suem9uZSAmJiB0YXNrLnpvbmUgIT09IHRoaXMpIHtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiB0aGUgdGFzayB3YXMgcmVzY2hlZHVsZWQsIHRoZSBuZXdab25lXG4gICAgICAgICAgICAgICAgLy8gc2hvdWxkIG5vdCBiZSB0aGUgY2hpbGRyZW4gb2YgdGhlIG9yaWdpbmFsIHpvbmVcbiAgICAgICAgICAgICAgICBsZXQgbmV3Wm9uZSA9IHRoaXM7XG4gICAgICAgICAgICAgICAgd2hpbGUgKG5ld1pvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld1pvbmUgPT09IHRhc2suem9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoYGNhbiBub3QgcmVzY2hlZHVsZSB0YXNrIHRvICR7dGhpcy5uYW1lfSB3aGljaCBpcyBkZXNjZW5kYW50cyBvZiB0aGUgb3JpZ2luYWwgem9uZSAke3Rhc2suem9uZS5uYW1lfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5ld1pvbmUgPSBuZXdab25lLnBhcmVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8oc2NoZWR1bGluZywgbm90U2NoZWR1bGVkKTtcbiAgICAgICAgICAgIGNvbnN0IHpvbmVEZWxlZ2F0ZXMgPSBbXTtcbiAgICAgICAgICAgIHRhc2suX3pvbmVEZWxlZ2F0ZXMgPSB6b25lRGVsZWdhdGVzO1xuICAgICAgICAgICAgdGFzay5fem9uZSA9IHRoaXM7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzLl96b25lRGVsZWdhdGUuc2NoZWR1bGVUYXNrKHRoaXMsIHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBzZXQgdGFzaydzIHN0YXRlIHRvIHVua25vd24gd2hlbiBzY2hlZHVsZVRhc2sgdGhyb3cgZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBlcnIgbWF5IGZyb20gcmVzY2hlZHVsZSwgc28gdGhlIGZyb21TdGF0ZSBtYXliZSBub3RTY2hlZHVsZWRcbiAgICAgICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8odW5rbm93biwgc2NoZWR1bGluZywgbm90U2NoZWR1bGVkKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBASmlhTGlQYXNzaW9uLCBzaG91bGQgd2UgY2hlY2sgdGhlIHJlc3VsdCBmcm9tIGhhbmRsZUVycm9yP1xuICAgICAgICAgICAgICAgIHRoaXMuX3pvbmVEZWxlZ2F0ZS5oYW5kbGVFcnJvcih0aGlzLCBlcnIpO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXNrLl96b25lRGVsZWdhdGVzID09PSB6b25lRGVsZWdhdGVzKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjaGVjayBiZWNhdXNlIGludGVybmFsbHkgdGhlIGRlbGVnYXRlIGNhbiByZXNjaGVkdWxlIHRoZSB0YXNrLlxuICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVRhc2tDb3VudCh0YXNrLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0YXNrLnN0YXRlID09IHNjaGVkdWxpbmcpIHtcbiAgICAgICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8oc2NoZWR1bGVkLCBzY2hlZHVsaW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlTWljcm9UYXNrKHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zY2hlZHVsZVRhc2sobmV3IFpvbmVUYXNrKG1pY3JvVGFzaywgc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIHVuZGVmaW5lZCkpO1xuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlTWFjcm9UYXNrKHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNjaGVkdWxlVGFzayhuZXcgWm9uZVRhc2sobWFjcm9UYXNrLCBzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVFdmVudFRhc2soc291cmNlLCBjYWxsYmFjaywgZGF0YSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2NoZWR1bGVUYXNrKG5ldyBab25lVGFzayhldmVudFRhc2ssIHNvdXJjZSwgY2FsbGJhY2ssIGRhdGEsIGN1c3RvbVNjaGVkdWxlLCBjdXN0b21DYW5jZWwpKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxUYXNrKHRhc2spIHtcbiAgICAgICAgICAgIGlmICh0YXNrLnpvbmUgIT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgdGFzayBjYW4gb25seSBiZSBjYW5jZWxsZWQgaW4gdGhlIHpvbmUgb2YgY3JlYXRpb24hIChDcmVhdGlvbjogJyArXG4gICAgICAgICAgICAgICAgICAgICh0YXNrLnpvbmUgfHwgTk9fWk9ORSkubmFtZSArICc7IEV4ZWN1dGlvbjogJyArIHRoaXMubmFtZSArICcpJyk7XG4gICAgICAgICAgICB0YXNrLl90cmFuc2l0aW9uVG8oY2FuY2VsaW5nLCBzY2hlZHVsZWQsIHJ1bm5pbmcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl96b25lRGVsZWdhdGUuY2FuY2VsVGFzayh0aGlzLCB0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyBpZiBlcnJvciBvY2N1cnMgd2hlbiBjYW5jZWxUYXNrLCB0cmFuc2l0IHRoZSBzdGF0ZSB0byB1bmtub3duXG4gICAgICAgICAgICAgICAgdGFzay5fdHJhbnNpdGlvblRvKHVua25vd24sIGNhbmNlbGluZyk7XG4gICAgICAgICAgICAgICAgdGhpcy5fem9uZURlbGVnYXRlLmhhbmRsZUVycm9yKHRoaXMsIGVycik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFza0NvdW50KHRhc2ssIC0xKTtcbiAgICAgICAgICAgIHRhc2suX3RyYW5zaXRpb25Ubyhub3RTY2hlZHVsZWQsIGNhbmNlbGluZyk7XG4gICAgICAgICAgICB0YXNrLnJ1bkNvdW50ID0gMDtcbiAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICB9XG4gICAgICAgIF91cGRhdGVUYXNrQ291bnQodGFzaywgY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHpvbmVEZWxlZ2F0ZXMgPSB0YXNrLl96b25lRGVsZWdhdGVzO1xuICAgICAgICAgICAgaWYgKGNvdW50ID09IC0xKSB7XG4gICAgICAgICAgICAgICAgdGFzay5fem9uZURlbGVnYXRlcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHpvbmVEZWxlZ2F0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB6b25lRGVsZWdhdGVzW2ldLl91cGRhdGVUYXNrQ291bnQodGFzay50eXBlLCBjb3VudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnJlcXVpcmUtaW50ZXJuYWwtd2l0aC11bmRlcnNjb3JlXG4gICAgWm9uZS5fX3N5bWJvbF9fID0gX19zeW1ib2xfXztcbiAgICBjb25zdCBERUxFR0FURV9aUyA9IHtcbiAgICAgICAgbmFtZTogJycsXG4gICAgICAgIG9uSGFzVGFzazogKGRlbGVnYXRlLCBfLCB0YXJnZXQsIGhhc1Rhc2tTdGF0ZSkgPT4gZGVsZWdhdGUuaGFzVGFzayh0YXJnZXQsIGhhc1Rhc2tTdGF0ZSksXG4gICAgICAgIG9uU2NoZWR1bGVUYXNrOiAoZGVsZWdhdGUsIF8sIHRhcmdldCwgdGFzaykgPT4gZGVsZWdhdGUuc2NoZWR1bGVUYXNrKHRhcmdldCwgdGFzayksXG4gICAgICAgIG9uSW52b2tlVGFzazogKGRlbGVnYXRlLCBfLCB0YXJnZXQsIHRhc2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzKSA9PiBkZWxlZ2F0ZS5pbnZva2VUYXNrKHRhcmdldCwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpLFxuICAgICAgICBvbkNhbmNlbFRhc2s6IChkZWxlZ2F0ZSwgXywgdGFyZ2V0LCB0YXNrKSA9PiBkZWxlZ2F0ZS5jYW5jZWxUYXNrKHRhcmdldCwgdGFzaylcbiAgICB9O1xuICAgIGNsYXNzIF9ab25lRGVsZWdhdGUge1xuICAgICAgICBjb25zdHJ1Y3Rvcih6b25lLCBwYXJlbnREZWxlZ2F0ZSwgem9uZVNwZWMpIHtcbiAgICAgICAgICAgIHRoaXMuX3Rhc2tDb3VudHMgPSB7ICdtaWNyb1Rhc2snOiAwLCAnbWFjcm9UYXNrJzogMCwgJ2V2ZW50VGFzayc6IDAgfTtcbiAgICAgICAgICAgIHRoaXMuem9uZSA9IHpvbmU7XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnREZWxlZ2F0ZSA9IHBhcmVudERlbGVnYXRlO1xuICAgICAgICAgICAgdGhpcy5fZm9ya1pTID0gem9uZVNwZWMgJiYgKHpvbmVTcGVjICYmIHpvbmVTcGVjLm9uRm9yayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2ZvcmtaUyk7XG4gICAgICAgICAgICB0aGlzLl9mb3JrRGxndCA9IHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkZvcmsgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9mb3JrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9mb3JrQ3VyclpvbmUgPVxuICAgICAgICAgICAgICAgIHpvbmVTcGVjICYmICh6b25lU3BlYy5vbkZvcmsgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS5fZm9ya0N1cnJab25lKTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdFpTID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnRlcmNlcHQgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9pbnRlcmNlcHRaUyk7XG4gICAgICAgICAgICB0aGlzLl9pbnRlcmNlcHREbGd0ID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnRlcmNlcHQgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9pbnRlcmNlcHREbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVyY2VwdEN1cnJab25lID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnRlcmNlcHQgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS5faW50ZXJjZXB0Q3VyclpvbmUpO1xuICAgICAgICAgICAgdGhpcy5faW52b2tlWlMgPSB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnZva2UgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VaUyk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VEbGd0ID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnZva2UgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZUN1cnJab25lID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25JbnZva2UgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS5faW52b2tlQ3VyclpvbmUpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3JaUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSGFuZGxlRXJyb3IgPyB6b25lU3BlYyA6IHBhcmVudERlbGVnYXRlLl9oYW5kbGVFcnJvclpTKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSGFuZGxlRXJyb3IgPyBwYXJlbnREZWxlZ2F0ZSA6IHBhcmVudERlbGVnYXRlLl9oYW5kbGVFcnJvckRsZ3QpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlRXJyb3JDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSGFuZGxlRXJyb3IgPyB0aGlzLnpvbmUgOiBwYXJlbnREZWxlZ2F0ZS5faGFuZGxlRXJyb3JDdXJyWm9uZSk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRhc2taUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5fc2NoZWR1bGVUYXNrWlMpO1xuICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrRGxndCA9IHpvbmVTcGVjICYmXG4gICAgICAgICAgICAgICAgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5fc2NoZWR1bGVUYXNrRGxndCk7XG4gICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRhc2tDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uU2NoZWR1bGVUYXNrID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX3NjaGVkdWxlVGFza0N1cnJab25lKTtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2taUyA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlVGFzayA/IHpvbmVTcGVjIDogcGFyZW50RGVsZWdhdGUuX2ludm9rZVRhc2taUyk7XG4gICAgICAgICAgICB0aGlzLl9pbnZva2VUYXNrRGxndCA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlVGFzayA/IHBhcmVudERlbGVnYXRlIDogcGFyZW50RGVsZWdhdGUuX2ludm9rZVRhc2tEbGd0KTtcbiAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2tDdXJyWm9uZSA9XG4gICAgICAgICAgICAgICAgem9uZVNwZWMgJiYgKHpvbmVTcGVjLm9uSW52b2tlVGFzayA/IHRoaXMuem9uZSA6IHBhcmVudERlbGVnYXRlLl9pbnZva2VUYXNrQ3VyclpvbmUpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGFza1pTID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25DYW5jZWxUYXNrID8gem9uZVNwZWMgOiBwYXJlbnREZWxlZ2F0ZS5fY2FuY2VsVGFza1pTKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2tEbGd0ID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25DYW5jZWxUYXNrID8gcGFyZW50RGVsZWdhdGUgOiBwYXJlbnREZWxlZ2F0ZS5fY2FuY2VsVGFza0RsZ3QpO1xuICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGFza0N1cnJab25lID1cbiAgICAgICAgICAgICAgICB6b25lU3BlYyAmJiAoem9uZVNwZWMub25DYW5jZWxUYXNrID8gdGhpcy56b25lIDogcGFyZW50RGVsZWdhdGUuX2NhbmNlbFRhc2tDdXJyWm9uZSk7XG4gICAgICAgICAgICB0aGlzLl9oYXNUYXNrWlMgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGFzVGFza0RsZ3QgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5faGFzVGFza0RsZ3RPd25lciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9oYXNUYXNrQ3VyclpvbmUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qgem9uZVNwZWNIYXNUYXNrID0gem9uZVNwZWMgJiYgem9uZVNwZWMub25IYXNUYXNrO1xuICAgICAgICAgICAgY29uc3QgcGFyZW50SGFzVGFzayA9IHBhcmVudERlbGVnYXRlICYmIHBhcmVudERlbGVnYXRlLl9oYXNUYXNrWlM7XG4gICAgICAgICAgICBpZiAoem9uZVNwZWNIYXNUYXNrIHx8IHBhcmVudEhhc1Rhc2spIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBuZWVkIHRvIHJlcG9ydCBoYXNUYXNrLCB0aGFuIHRoaXMgWlMgbmVlZHMgdG8gZG8gcmVmIGNvdW50aW5nIG9uIHRhc2tzLiBJbiBzdWNoXG4gICAgICAgICAgICAgICAgLy8gYSBjYXNlIGFsbCB0YXNrIHJlbGF0ZWQgaW50ZXJjZXB0b3JzIG11c3QgZ28gdGhyb3VnaCB0aGlzIFpELiBXZSBjYW4ndCBzaG9ydCBjaXJjdWl0IGl0LlxuICAgICAgICAgICAgICAgIHRoaXMuX2hhc1Rhc2taUyA9IHpvbmVTcGVjSGFzVGFzayA/IHpvbmVTcGVjIDogREVMRUdBVEVfWlM7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFzVGFza0RsZ3QgPSBwYXJlbnREZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUYXNrRGxndE93bmVyID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUYXNrQ3VyclpvbmUgPSB6b25lO1xuICAgICAgICAgICAgICAgIGlmICghem9uZVNwZWMub25TY2hlZHVsZVRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrWlMgPSBERUxFR0FURV9aUztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2NoZWR1bGVUYXNrRGxndCA9IHBhcmVudERlbGVnYXRlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zY2hlZHVsZVRhc2tDdXJyWm9uZSA9IHRoaXMuem9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF6b25lU3BlYy5vbkludm9rZVRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faW52b2tlVGFza1pTID0gREVMRUdBVEVfWlM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2tEbGd0ID0gcGFyZW50RGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludm9rZVRhc2tDdXJyWm9uZSA9IHRoaXMuem9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF6b25lU3BlYy5vbkNhbmNlbFRhc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2FuY2VsVGFza1pTID0gREVMRUdBVEVfWlM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2tEbGd0ID0gcGFyZW50RGVsZWdhdGU7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NhbmNlbFRhc2tDdXJyWm9uZSA9IHRoaXMuem9uZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yayh0YXJnZXRab25lLCB6b25lU3BlYykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZvcmtaUyA/IHRoaXMuX2ZvcmtaUy5vbkZvcmsodGhpcy5fZm9ya0RsZ3QsIHRoaXMuem9uZSwgdGFyZ2V0Wm9uZSwgem9uZVNwZWMpIDpcbiAgICAgICAgICAgICAgICBuZXcgWm9uZSh0YXJnZXRab25lLCB6b25lU3BlYyk7XG4gICAgICAgIH1cbiAgICAgICAgaW50ZXJjZXB0KHRhcmdldFpvbmUsIGNhbGxiYWNrLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnRlcmNlcHRaUyA/XG4gICAgICAgICAgICAgICAgdGhpcy5faW50ZXJjZXB0WlMub25JbnRlcmNlcHQodGhpcy5faW50ZXJjZXB0RGxndCwgdGhpcy5faW50ZXJjZXB0Q3VyclpvbmUsIHRhcmdldFpvbmUsIGNhbGxiYWNrLCBzb3VyY2UpIDpcbiAgICAgICAgICAgICAgICBjYWxsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBpbnZva2UodGFyZ2V0Wm9uZSwgY2FsbGJhY2ssIGFwcGx5VGhpcywgYXBwbHlBcmdzLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbnZva2VaUyA/IHRoaXMuX2ludm9rZVpTLm9uSW52b2tlKHRoaXMuX2ludm9rZURsZ3QsIHRoaXMuX2ludm9rZUN1cnJab25lLCB0YXJnZXRab25lLCBjYWxsYmFjaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MsIHNvdXJjZSkgOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBoYW5kbGVFcnJvcih0YXJnZXRab25lLCBlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUVycm9yWlMgP1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZUVycm9yWlMub25IYW5kbGVFcnJvcih0aGlzLl9oYW5kbGVFcnJvckRsZ3QsIHRoaXMuX2hhbmRsZUVycm9yQ3VyclpvbmUsIHRhcmdldFpvbmUsIGVycm9yKSA6XG4gICAgICAgICAgICAgICAgdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZVRhc2sodGFyZ2V0Wm9uZSwgdGFzaykge1xuICAgICAgICAgICAgbGV0IHJldHVyblRhc2sgPSB0YXNrO1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NjaGVkdWxlVGFza1pTKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2hhc1Rhc2taUykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm5UYXNrLl96b25lRGVsZWdhdGVzLnB1c2godGhpcy5faGFzVGFza0RsZ3RPd25lcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNsYW5nLWZvcm1hdCBvZmZcbiAgICAgICAgICAgICAgICByZXR1cm5UYXNrID0gdGhpcy5fc2NoZWR1bGVUYXNrWlMub25TY2hlZHVsZVRhc2sodGhpcy5fc2NoZWR1bGVUYXNrRGxndCwgdGhpcy5fc2NoZWR1bGVUYXNrQ3VyclpvbmUsIHRhcmdldFpvbmUsIHRhc2spO1xuICAgICAgICAgICAgICAgIC8vIGNsYW5nLWZvcm1hdCBvblxuICAgICAgICAgICAgICAgIGlmICghcmV0dXJuVGFzaylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuVGFzayA9IHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGFzay5zY2hlZHVsZUZuKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2suc2NoZWR1bGVGbih0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFzay50eXBlID09IG1pY3JvVGFzaykge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZU1pY3JvVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGFzayBpcyBtaXNzaW5nIHNjaGVkdWxlRm4uJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldHVyblRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgaW52b2tlVGFzayh0YXJnZXRab25lLCB0YXNrLCBhcHBseVRoaXMsIGFwcGx5QXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ludm9rZVRhc2taUyA/IHRoaXMuX2ludm9rZVRhc2taUy5vbkludm9rZVRhc2sodGhpcy5faW52b2tlVGFza0RsZ3QsIHRoaXMuX2ludm9rZVRhc2tDdXJyWm9uZSwgdGFyZ2V0Wm9uZSwgdGFzaywgYXBwbHlUaGlzLCBhcHBseUFyZ3MpIDpcbiAgICAgICAgICAgICAgICB0YXNrLmNhbGxiYWNrLmFwcGx5KGFwcGx5VGhpcywgYXBwbHlBcmdzKTtcbiAgICAgICAgfVxuICAgICAgICBjYW5jZWxUYXNrKHRhcmdldFpvbmUsIHRhc2spIHtcbiAgICAgICAgICAgIGxldCB2YWx1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jYW5jZWxUYXNrWlMpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMuX2NhbmNlbFRhc2taUy5vbkNhbmNlbFRhc2sodGhpcy5fY2FuY2VsVGFza0RsZ3QsIHRoaXMuX2NhbmNlbFRhc2tDdXJyWm9uZSwgdGFyZ2V0Wm9uZSwgdGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRhc2suY2FuY2VsRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ1Rhc2sgaXMgbm90IGNhbmNlbGFibGUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSB0YXNrLmNhbmNlbEZuKHRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc1Rhc2sodGFyZ2V0Wm9uZSwgaXNFbXB0eSkge1xuICAgICAgICAgICAgLy8gaGFzVGFzayBzaG91bGQgbm90IHRocm93IGVycm9yIHNvIG90aGVyIFpvbmVEZWxlZ2F0ZVxuICAgICAgICAgICAgLy8gY2FuIHN0aWxsIHRyaWdnZXIgaGFzVGFzayBjYWxsYmFja1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9oYXNUYXNrWlMgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFzVGFza1pTLm9uSGFzVGFzayh0aGlzLl9oYXNUYXNrRGxndCwgdGhpcy5faGFzVGFza0N1cnJab25lLCB0YXJnZXRab25lLCBpc0VtcHR5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHRhcmdldFpvbmUsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnJlcXVpcmUtaW50ZXJuYWwtd2l0aC11bmRlcnNjb3JlXG4gICAgICAgIF91cGRhdGVUYXNrQ291bnQodHlwZSwgY291bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvdW50cyA9IHRoaXMuX3Rhc2tDb3VudHM7XG4gICAgICAgICAgICBjb25zdCBwcmV2ID0gY291bnRzW3R5cGVdO1xuICAgICAgICAgICAgY29uc3QgbmV4dCA9IGNvdW50c1t0eXBlXSA9IHByZXYgKyBjb3VudDtcbiAgICAgICAgICAgIGlmIChuZXh0IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTW9yZSB0YXNrcyBleGVjdXRlZCB0aGVuIHdlcmUgc2NoZWR1bGVkLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHByZXYgPT0gMCB8fCBuZXh0ID09IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0VtcHR5ID0ge1xuICAgICAgICAgICAgICAgICAgICBtaWNyb1Rhc2s6IGNvdW50c1snbWljcm9UYXNrJ10gPiAwLFxuICAgICAgICAgICAgICAgICAgICBtYWNyb1Rhc2s6IGNvdW50c1snbWFjcm9UYXNrJ10gPiAwLFxuICAgICAgICAgICAgICAgICAgICBldmVudFRhc2s6IGNvdW50c1snZXZlbnRUYXNrJ10gPiAwLFxuICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IHR5cGVcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzVGFzayh0aGlzLnpvbmUsIGlzRW1wdHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNsYXNzIFpvbmVUYXNrIHtcbiAgICAgICAgY29uc3RydWN0b3IodHlwZSwgc291cmNlLCBjYWxsYmFjaywgb3B0aW9ucywgc2NoZWR1bGVGbiwgY2FuY2VsRm4pIHtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICAgICAgdGhpcy5fem9uZSA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLnJ1bkNvdW50ID0gMDtcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICAgICAgdGhpcy5fem9uZURlbGVnYXRlcyA9IG51bGw7XG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6cmVxdWlyZS1pbnRlcm5hbC13aXRoLXVuZGVyc2NvcmVcbiAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gJ25vdFNjaGVkdWxlZCc7XG4gICAgICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBvcHRpb25zO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZUZuID0gc2NoZWR1bGVGbjtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsRm4gPSBjYW5jZWxGbjtcbiAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGxiYWNrIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIC8vIFRPRE86IEBKaWFMaVBhc3Npb24gb3B0aW9ucyBzaG91bGQgaGF2ZSBpbnRlcmZhY2VcbiAgICAgICAgICAgIGlmICh0eXBlID09PSBldmVudFRhc2sgJiYgb3B0aW9ucyAmJiBvcHRpb25zLnVzZUcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZSA9IFpvbmVUYXNrLmludm9rZVRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFpvbmVUYXNrLmludm9rZVRhc2suY2FsbChnbG9iYWwsIHNlbGYsIHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgaW52b2tlVGFzayh0YXNrLCB0YXJnZXQsIGFyZ3MpIHtcbiAgICAgICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgICAgIHRhc2sgPSB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcysrO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0YXNrLnJ1bkNvdW50Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2suem9uZS5ydW5UYXNrKHRhc2ssIHRhcmdldCwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBpZiAoX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcyA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWluTWljcm9UYXNrUXVldWUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGdldCB6b25lKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3pvbmU7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0IHN0YXRlKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3N0YXRlO1xuICAgICAgICB9XG4gICAgICAgIGNhbmNlbFNjaGVkdWxlUmVxdWVzdCgpIHtcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25Ubyhub3RTY2hlZHVsZWQsIHNjaGVkdWxpbmcpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpyZXF1aXJlLWludGVybmFsLXdpdGgtdW5kZXJzY29yZVxuICAgICAgICBfdHJhbnNpdGlvblRvKHRvU3RhdGUsIGZyb21TdGF0ZTEsIGZyb21TdGF0ZTIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zdGF0ZSA9PT0gZnJvbVN0YXRlMSB8fCB0aGlzLl9zdGF0ZSA9PT0gZnJvbVN0YXRlMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gdG9TdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAodG9TdGF0ZSA9PSBub3RTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fem9uZURlbGVnYXRlcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGAke3RoaXMudHlwZX0gJyR7dGhpcy5zb3VyY2V9JzogY2FuIG5vdCB0cmFuc2l0aW9uIHRvICcke3RvU3RhdGV9JywgZXhwZWN0aW5nIHN0YXRlICcke2Zyb21TdGF0ZTF9JyR7ZnJvbVN0YXRlMiA/ICcgb3IgXFwnJyArIGZyb21TdGF0ZTIgKyAnXFwnJyA6ICcnfSwgd2FzICcke3RoaXMuX3N0YXRlfScuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdG9TdHJpbmcoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhICYmIHR5cGVvZiB0aGlzLmRhdGEuaGFuZGxlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5oYW5kbGVJZC50b1N0cmluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBhZGQgdG9KU09OIG1ldGhvZCB0byBwcmV2ZW50IGN5Y2xpYyBlcnJvciB3aGVuXG4gICAgICAgIC8vIGNhbGwgSlNPTi5zdHJpbmdpZnkoem9uZVRhc2spXG4gICAgICAgIHRvSlNPTigpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgICAgICAgICAgIHN0YXRlOiB0aGlzLnN0YXRlLFxuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcy5zb3VyY2UsXG4gICAgICAgICAgICAgICAgem9uZTogdGhpcy56b25lLm5hbWUsXG4gICAgICAgICAgICAgICAgcnVuQ291bnQ6IHRoaXMucnVuQ291bnRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8vICBNSUNST1RBU0sgUVVFVUVcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICBjb25zdCBzeW1ib2xTZXRUaW1lb3V0ID0gX19zeW1ib2xfXygnc2V0VGltZW91dCcpO1xuICAgIGNvbnN0IHN5bWJvbFByb21pc2UgPSBfX3N5bWJvbF9fKCdQcm9taXNlJyk7XG4gICAgY29uc3Qgc3ltYm9sVGhlbiA9IF9fc3ltYm9sX18oJ3RoZW4nKTtcbiAgICBsZXQgX21pY3JvVGFza1F1ZXVlID0gW107XG4gICAgbGV0IF9pc0RyYWluaW5nTWljcm90YXNrUXVldWUgPSBmYWxzZTtcbiAgICBsZXQgbmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlO1xuICAgIGZ1bmN0aW9uIG5hdGl2ZVNjaGVkdWxlTWljcm9UYXNrKGZ1bmMpIHtcbiAgICAgICAgaWYgKCFuYXRpdmVNaWNyb1Rhc2tRdWV1ZVByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChnbG9iYWxbc3ltYm9sUHJvbWlzZV0pIHtcbiAgICAgICAgICAgICAgICBuYXRpdmVNaWNyb1Rhc2tRdWV1ZVByb21pc2UgPSBnbG9iYWxbc3ltYm9sUHJvbWlzZV0ucmVzb2x2ZSgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlKSB7XG4gICAgICAgICAgICBsZXQgbmF0aXZlVGhlbiA9IG5hdGl2ZU1pY3JvVGFza1F1ZXVlUHJvbWlzZVtzeW1ib2xUaGVuXTtcbiAgICAgICAgICAgIGlmICghbmF0aXZlVGhlbikge1xuICAgICAgICAgICAgICAgIC8vIG5hdGl2ZSBQcm9taXNlIGlzIG5vdCBwYXRjaGFibGUsIHdlIG5lZWQgdG8gdXNlIGB0aGVuYCBkaXJlY3RseVxuICAgICAgICAgICAgICAgIC8vIGlzc3VlIDEwNzhcbiAgICAgICAgICAgICAgICBuYXRpdmVUaGVuID0gbmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlWyd0aGVuJ107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuYXRpdmVUaGVuLmNhbGwobmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlLCBmdW5jKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbFtzeW1ib2xTZXRUaW1lb3V0XShmdW5jLCAwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZU1pY3JvVGFzayh0YXNrKSB7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBub3QgcnVubmluZyBpbiBhbnkgdGFzaywgYW5kIHRoZXJlIGhhcyBub3QgYmVlbiBhbnl0aGluZyBzY2hlZHVsZWRcbiAgICAgICAgLy8gd2UgbXVzdCBib290c3RyYXAgdGhlIGluaXRpYWwgdGFzayBjcmVhdGlvbiBieSBtYW51YWxseSBzY2hlZHVsaW5nIHRoZSBkcmFpblxuICAgICAgICBpZiAoX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcyA9PT0gMCAmJiBfbWljcm9UYXNrUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAvLyBXZSBhcmUgbm90IHJ1bm5pbmcgaW4gVGFzaywgc28gd2UgbmVlZCB0byBraWNrc3RhcnQgdGhlIG1pY3JvdGFzayBxdWV1ZS5cbiAgICAgICAgICAgIG5hdGl2ZVNjaGVkdWxlTWljcm9UYXNrKGRyYWluTWljcm9UYXNrUXVldWUpO1xuICAgICAgICB9XG4gICAgICAgIHRhc2sgJiYgX21pY3JvVGFza1F1ZXVlLnB1c2godGFzayk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRyYWluTWljcm9UYXNrUXVldWUoKSB7XG4gICAgICAgIGlmICghX2lzRHJhaW5pbmdNaWNyb3Rhc2tRdWV1ZSkge1xuICAgICAgICAgICAgX2lzRHJhaW5pbmdNaWNyb3Rhc2tRdWV1ZSA9IHRydWU7XG4gICAgICAgICAgICB3aGlsZSAoX21pY3JvVGFza1F1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gX21pY3JvVGFza1F1ZXVlO1xuICAgICAgICAgICAgICAgIF9taWNyb1Rhc2tRdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay56b25lLnJ1blRhc2sodGFzaywgbnVsbCwgbnVsbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfYXBpLm9uVW5oYW5kbGVkRXJyb3IoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX2FwaS5taWNyb3Rhc2tEcmFpbkRvbmUoKTtcbiAgICAgICAgICAgIF9pc0RyYWluaW5nTWljcm90YXNrUXVldWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLy8gIEJPT1RTVFJBUFxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIGNvbnN0IE5PX1pPTkUgPSB7IG5hbWU6ICdOTyBaT05FJyB9O1xuICAgIGNvbnN0IG5vdFNjaGVkdWxlZCA9ICdub3RTY2hlZHVsZWQnLCBzY2hlZHVsaW5nID0gJ3NjaGVkdWxpbmcnLCBzY2hlZHVsZWQgPSAnc2NoZWR1bGVkJywgcnVubmluZyA9ICdydW5uaW5nJywgY2FuY2VsaW5nID0gJ2NhbmNlbGluZycsIHVua25vd24gPSAndW5rbm93bic7XG4gICAgY29uc3QgbWljcm9UYXNrID0gJ21pY3JvVGFzaycsIG1hY3JvVGFzayA9ICdtYWNyb1Rhc2snLCBldmVudFRhc2sgPSAnZXZlbnRUYXNrJztcbiAgICBjb25zdCBwYXRjaGVzID0ge307XG4gICAgY29uc3QgX2FwaSA9IHtcbiAgICAgICAgc3ltYm9sOiBfX3N5bWJvbF9fLFxuICAgICAgICBjdXJyZW50Wm9uZUZyYW1lOiAoKSA9PiBfY3VycmVudFpvbmVGcmFtZSxcbiAgICAgICAgb25VbmhhbmRsZWRFcnJvcjogbm9vcCxcbiAgICAgICAgbWljcm90YXNrRHJhaW5Eb25lOiBub29wLFxuICAgICAgICBzY2hlZHVsZU1pY3JvVGFzazogc2NoZWR1bGVNaWNyb1Rhc2ssXG4gICAgICAgIHNob3dVbmNhdWdodEVycm9yOiAoKSA9PiAhWm9uZVtfX3N5bWJvbF9fKCdpZ25vcmVDb25zb2xlRXJyb3JVbmNhdWdodEVycm9yJyldLFxuICAgICAgICBwYXRjaEV2ZW50VGFyZ2V0OiAoKSA9PiBbXSxcbiAgICAgICAgcGF0Y2hPblByb3BlcnRpZXM6IG5vb3AsXG4gICAgICAgIHBhdGNoTWV0aG9kOiAoKSA9PiBub29wLFxuICAgICAgICBiaW5kQXJndW1lbnRzOiAoKSA9PiBbXSxcbiAgICAgICAgcGF0Y2hUaGVuOiAoKSA9PiBub29wLFxuICAgICAgICBwYXRjaE1hY3JvVGFzazogKCkgPT4gbm9vcCxcbiAgICAgICAgcGF0Y2hFdmVudFByb3RvdHlwZTogKCkgPT4gbm9vcCxcbiAgICAgICAgaXNJRU9yRWRnZTogKCkgPT4gZmFsc2UsXG4gICAgICAgIGdldEdsb2JhbE9iamVjdHM6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgT2JqZWN0RGVmaW5lUHJvcGVydHk6ICgpID0+IG5vb3AsXG4gICAgICAgIE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvcjogKCkgPT4gdW5kZWZpbmVkLFxuICAgICAgICBPYmplY3RDcmVhdGU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICAgICAgQXJyYXlTbGljZTogKCkgPT4gW10sXG4gICAgICAgIHBhdGNoQ2xhc3M6ICgpID0+IG5vb3AsXG4gICAgICAgIHdyYXBXaXRoQ3VycmVudFpvbmU6ICgpID0+IG5vb3AsXG4gICAgICAgIGZpbHRlclByb3BlcnRpZXM6ICgpID0+IFtdLFxuICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQ6ICgpID0+IG5vb3AsXG4gICAgICAgIF9yZWRlZmluZVByb3BlcnR5OiAoKSA9PiBub29wLFxuICAgICAgICBwYXRjaENhbGxiYWNrczogKCkgPT4gbm9vcCxcbiAgICAgICAgbmF0aXZlU2NoZWR1bGVNaWNyb1Rhc2s6IG5hdGl2ZVNjaGVkdWxlTWljcm9UYXNrXG4gICAgfTtcbiAgICBsZXQgX2N1cnJlbnRab25lRnJhbWUgPSB7IHBhcmVudDogbnVsbCwgem9uZTogbmV3IFpvbmUobnVsbCwgbnVsbCkgfTtcbiAgICBsZXQgX2N1cnJlbnRUYXNrID0gbnVsbDtcbiAgICBsZXQgX251bWJlck9mTmVzdGVkVGFza0ZyYW1lcyA9IDA7XG4gICAgZnVuY3Rpb24gbm9vcCgpIHsgfVxuICAgIHBlcmZvcm1hbmNlTWVhc3VyZSgnWm9uZScsICdab25lJyk7XG4gICAgcmV0dXJuIGdsb2JhbFsnWm9uZSddID0gWm9uZTtcbn0pKSh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cgfHwgdHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgfHwgZ2xvYmFsKTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG4vKipcbiAqIFN1cHByZXNzIGNsb3N1cmUgY29tcGlsZXIgZXJyb3JzIGFib3V0IHVua25vd24gJ1pvbmUnIHZhcmlhYmxlXG4gKiBAZmlsZW92ZXJ2aWV3XG4gKiBAc3VwcHJlc3Mge3VuZGVmaW5lZFZhcnMsZ2xvYmFsVGhpcyxtaXNzaW5nUmVxdWlyZX1cbiAqL1xuLy8vIDxyZWZlcmVuY2UgdHlwZXM9XCJub2RlXCIvPlxuLy8gaXNzdWUgIzk4OSwgdG8gcmVkdWNlIGJ1bmRsZSBzaXplLCB1c2Ugc2hvcnQgbmFtZVxuLyoqIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgKi9cbmNvbnN0IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4vKiogT2JqZWN0LmRlZmluZVByb3BlcnR5ICovXG5jb25zdCBPYmplY3REZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbi8qKiBPYmplY3QuZ2V0UHJvdG90eXBlT2YgKi9cbmNvbnN0IE9iamVjdEdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuLyoqIE9iamVjdC5jcmVhdGUgKi9cbmNvbnN0IE9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGU7XG4vKiogQXJyYXkucHJvdG90eXBlLnNsaWNlICovXG5jb25zdCBBcnJheVNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xuLyoqIGFkZEV2ZW50TGlzdGVuZXIgc3RyaW5nIGNvbnN0ICovXG5jb25zdCBBRERfRVZFTlRfTElTVEVORVJfU1RSID0gJ2FkZEV2ZW50TGlzdGVuZXInO1xuLyoqIHJlbW92ZUV2ZW50TGlzdGVuZXIgc3RyaW5nIGNvbnN0ICovXG5jb25zdCBSRU1PVkVfRVZFTlRfTElTVEVORVJfU1RSID0gJ3JlbW92ZUV2ZW50TGlzdGVuZXInO1xuLyoqIHpvbmVTeW1ib2wgYWRkRXZlbnRMaXN0ZW5lciAqL1xuY29uc3QgWk9ORV9TWU1CT0xfQUREX0VWRU5UX0xJU1RFTkVSID0gWm9uZS5fX3N5bWJvbF9fKEFERF9FVkVOVF9MSVNURU5FUl9TVFIpO1xuLyoqIHpvbmVTeW1ib2wgcmVtb3ZlRXZlbnRMaXN0ZW5lciAqL1xuY29uc3QgWk9ORV9TWU1CT0xfUkVNT1ZFX0VWRU5UX0xJU1RFTkVSID0gWm9uZS5fX3N5bWJvbF9fKFJFTU9WRV9FVkVOVF9MSVNURU5FUl9TVFIpO1xuLyoqIHRydWUgc3RyaW5nIGNvbnN0ICovXG5jb25zdCBUUlVFX1NUUiA9ICd0cnVlJztcbi8qKiBmYWxzZSBzdHJpbmcgY29uc3QgKi9cbmNvbnN0IEZBTFNFX1NUUiA9ICdmYWxzZSc7XG4vKiogWm9uZSBzeW1ib2wgcHJlZml4IHN0cmluZyBjb25zdC4gKi9cbmNvbnN0IFpPTkVfU1lNQk9MX1BSRUZJWCA9IFpvbmUuX19zeW1ib2xfXygnJyk7XG5mdW5jdGlvbiB3cmFwV2l0aEN1cnJlbnRab25lKGNhbGxiYWNrLCBzb3VyY2UpIHtcbiAgICByZXR1cm4gWm9uZS5jdXJyZW50LndyYXAoY2FsbGJhY2ssIHNvdXJjZSk7XG59XG5mdW5jdGlvbiBzY2hlZHVsZU1hY3JvVGFza1dpdGhDdXJyZW50Wm9uZShzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKSB7XG4gICAgcmV0dXJuIFpvbmUuY3VycmVudC5zY2hlZHVsZU1hY3JvVGFzayhzb3VyY2UsIGNhbGxiYWNrLCBkYXRhLCBjdXN0b21TY2hlZHVsZSwgY3VzdG9tQ2FuY2VsKTtcbn1cbmNvbnN0IHpvbmVTeW1ib2wgPSBab25lLl9fc3ltYm9sX187XG5jb25zdCBpc1dpbmRvd0V4aXN0cyA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnO1xuY29uc3QgaW50ZXJuYWxXaW5kb3cgPSBpc1dpbmRvd0V4aXN0cyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcbmNvbnN0IF9nbG9iYWwgPSBpc1dpbmRvd0V4aXN0cyAmJiBpbnRlcm5hbFdpbmRvdyB8fCB0eXBlb2Ygc2VsZiA9PT0gJ29iamVjdCcgJiYgc2VsZiB8fCBnbG9iYWw7XG5jb25zdCBSRU1PVkVfQVRUUklCVVRFID0gJ3JlbW92ZUF0dHJpYnV0ZSc7XG5mdW5jdGlvbiBiaW5kQXJndW1lbnRzKGFyZ3MsIHNvdXJjZSkge1xuICAgIGZvciAobGV0IGkgPSBhcmdzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1tpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJnc1tpXSA9IHdyYXBXaXRoQ3VycmVudFpvbmUoYXJnc1tpXSwgc291cmNlICsgJ18nICsgaSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59XG5mdW5jdGlvbiBwYXRjaFByb3RvdHlwZShwcm90b3R5cGUsIGZuTmFtZXMpIHtcbiAgICBjb25zdCBzb3VyY2UgPSBwcm90b3R5cGUuY29uc3RydWN0b3JbJ25hbWUnXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZuTmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IGZuTmFtZXNbaV07XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlID0gcHJvdG90eXBlW25hbWVdO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvdHlwZURlc2MgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBuYW1lKTtcbiAgICAgICAgICAgIGlmICghaXNQcm9wZXJ0eVdyaXRhYmxlKHByb3RvdHlwZURlc2MpKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwcm90b3R5cGVbbmFtZV0gPSAoKGRlbGVnYXRlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0Y2hlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlbGVnYXRlLmFwcGx5KHRoaXMsIGJpbmRBcmd1bWVudHMoYXJndW1lbnRzLCBzb3VyY2UgKyAnLicgKyBuYW1lKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQocGF0Y2hlZCwgZGVsZWdhdGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwYXRjaGVkO1xuICAgICAgICAgICAgfSkoZGVsZWdhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQcm9wZXJ0eVdyaXRhYmxlKHByb3BlcnR5RGVzYykge1xuICAgIGlmICghcHJvcGVydHlEZXNjKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAocHJvcGVydHlEZXNjLndyaXRhYmxlID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAhKHR5cGVvZiBwcm9wZXJ0eURlc2MuZ2V0ID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBwcm9wZXJ0eURlc2Muc2V0ID09PSAndW5kZWZpbmVkJyk7XG59XG5jb25zdCBpc1dlYldvcmtlciA9ICh0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgIT09ICd1bmRlZmluZWQnICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZSk7XG4vLyBNYWtlIHN1cmUgdG8gYWNjZXNzIGBwcm9jZXNzYCB0aHJvdWdoIGBfZ2xvYmFsYCBzbyB0aGF0IFdlYlBhY2sgZG9lcyBub3QgYWNjaWRlbnRhbGx5IGJyb3dzZXJpZnlcbi8vIHRoaXMgY29kZS5cbmNvbnN0IGlzTm9kZSA9ICghKCdudycgaW4gX2dsb2JhbCkgJiYgdHlwZW9mIF9nbG9iYWwucHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB7fS50b1N0cmluZy5jYWxsKF9nbG9iYWwucHJvY2VzcykgPT09ICdbb2JqZWN0IHByb2Nlc3NdJyk7XG5jb25zdCBpc0Jyb3dzZXIgPSAhaXNOb2RlICYmICFpc1dlYldvcmtlciAmJiAhIShpc1dpbmRvd0V4aXN0cyAmJiBpbnRlcm5hbFdpbmRvd1snSFRNTEVsZW1lbnQnXSk7XG4vLyB3ZSBhcmUgaW4gZWxlY3Ryb24gb2YgbncsIHNvIHdlIGFyZSBib3RoIGJyb3dzZXIgYW5kIG5vZGVqc1xuLy8gTWFrZSBzdXJlIHRvIGFjY2VzcyBgcHJvY2Vzc2AgdGhyb3VnaCBgX2dsb2JhbGAgc28gdGhhdCBXZWJQYWNrIGRvZXMgbm90IGFjY2lkZW50YWxseSBicm93c2VyaWZ5XG4vLyB0aGlzIGNvZGUuXG5jb25zdCBpc01peCA9IHR5cGVvZiBfZ2xvYmFsLnByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmXG4gICAge30udG9TdHJpbmcuY2FsbChfZ2xvYmFsLnByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScgJiYgIWlzV2ViV29ya2VyICYmXG4gICAgISEoaXNXaW5kb3dFeGlzdHMgJiYgaW50ZXJuYWxXaW5kb3dbJ0hUTUxFbGVtZW50J10pO1xuY29uc3Qgem9uZVN5bWJvbEV2ZW50TmFtZXMkMSA9IHt9O1xuY29uc3Qgd3JhcEZuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvem9uZS5qcy9pc3N1ZXMvOTExLCBpbiBJRSwgc29tZXRpbWVzXG4gICAgLy8gZXZlbnQgd2lsbCBiZSB1bmRlZmluZWQsIHNvIHdlIG5lZWQgdG8gdXNlIHdpbmRvdy5ldmVudFxuICAgIGV2ZW50ID0gZXZlbnQgfHwgX2dsb2JhbC5ldmVudDtcbiAgICBpZiAoIWV2ZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IGV2ZW50TmFtZVN5bWJvbCA9IHpvbmVTeW1ib2xFdmVudE5hbWVzJDFbZXZlbnQudHlwZV07XG4gICAgaWYgKCFldmVudE5hbWVTeW1ib2wpIHtcbiAgICAgICAgZXZlbnROYW1lU3ltYm9sID0gem9uZVN5bWJvbEV2ZW50TmFtZXMkMVtldmVudC50eXBlXSA9IHpvbmVTeW1ib2woJ09OX1BST1BFUlRZJyArIGV2ZW50LnR5cGUpO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzIHx8IGV2ZW50LnRhcmdldCB8fCBfZ2xvYmFsO1xuICAgIGNvbnN0IGxpc3RlbmVyID0gdGFyZ2V0W2V2ZW50TmFtZVN5bWJvbF07XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoaXNCcm93c2VyICYmIHRhcmdldCA9PT0gaW50ZXJuYWxXaW5kb3cgJiYgZXZlbnQudHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgICAvLyB3aW5kb3cub25lcnJvciBoYXZlIGRpZmZlcmVudCBzaWduYXR1cmVcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0dsb2JhbEV2ZW50SGFuZGxlcnMvb25lcnJvciN3aW5kb3cub25lcnJvclxuICAgICAgICAvLyBhbmQgb25lcnJvciBjYWxsYmFjayB3aWxsIHByZXZlbnQgZGVmYXVsdCB3aGVuIGNhbGxiYWNrIHJldHVybiB0cnVlXG4gICAgICAgIGNvbnN0IGVycm9yRXZlbnQgPSBldmVudDtcbiAgICAgICAgcmVzdWx0ID0gbGlzdGVuZXIgJiZcbiAgICAgICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXJyb3JFdmVudC5tZXNzYWdlLCBlcnJvckV2ZW50LmZpbGVuYW1lLCBlcnJvckV2ZW50LmxpbmVubywgZXJyb3JFdmVudC5jb2xubywgZXJyb3JFdmVudC5lcnJvcik7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IHRydWUpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGxpc3RlbmVyICYmIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChyZXN1bHQgIT0gdW5kZWZpbmVkICYmICFyZXN1bHQpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5mdW5jdGlvbiBwYXRjaFByb3BlcnR5KG9iaiwgcHJvcCwgcHJvdG90eXBlKSB7XG4gICAgbGV0IGRlc2MgPSBPYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqLCBwcm9wKTtcbiAgICBpZiAoIWRlc2MgJiYgcHJvdG90eXBlKSB7XG4gICAgICAgIC8vIHdoZW4gcGF0Y2ggd2luZG93IG9iamVjdCwgdXNlIHByb3RvdHlwZSB0byBjaGVjayBwcm9wIGV4aXN0IG9yIG5vdFxuICAgICAgICBjb25zdCBwcm90b3R5cGVEZXNjID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvdHlwZSwgcHJvcCk7XG4gICAgICAgIGlmIChwcm90b3R5cGVEZXNjKSB7XG4gICAgICAgICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiB0aGUgZGVzY3JpcHRvciBub3QgZXhpc3RzIG9yIGlzIG5vdCBjb25maWd1cmFibGVcbiAgICAvLyBqdXN0IHJldHVyblxuICAgIGlmICghZGVzYyB8fCAhZGVzYy5jb25maWd1cmFibGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBvblByb3BQYXRjaGVkU3ltYm9sID0gem9uZVN5bWJvbCgnb24nICsgcHJvcCArICdwYXRjaGVkJyk7XG4gICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShvblByb3BQYXRjaGVkU3ltYm9sKSAmJiBvYmpbb25Qcm9wUGF0Y2hlZFN5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvLyBBIHByb3BlcnR5IGRlc2NyaXB0b3IgY2Fubm90IGhhdmUgZ2V0dGVyL3NldHRlciBhbmQgYmUgd3JpdGFibGVcbiAgICAvLyBkZWxldGluZyB0aGUgd3JpdGFibGUgYW5kIHZhbHVlIHByb3BlcnRpZXMgYXZvaWRzIHRoaXMgZXJyb3I6XG4gICAgLy9cbiAgICAvLyBUeXBlRXJyb3I6IHByb3BlcnR5IGRlc2NyaXB0b3JzIG11c3Qgbm90IHNwZWNpZnkgYSB2YWx1ZSBvciBiZSB3cml0YWJsZSB3aGVuIGFcbiAgICAvLyBnZXR0ZXIgb3Igc2V0dGVyIGhhcyBiZWVuIHNwZWNpZmllZFxuICAgIGRlbGV0ZSBkZXNjLndyaXRhYmxlO1xuICAgIGRlbGV0ZSBkZXNjLnZhbHVlO1xuICAgIGNvbnN0IG9yaWdpbmFsRGVzY0dldCA9IGRlc2MuZ2V0O1xuICAgIGNvbnN0IG9yaWdpbmFsRGVzY1NldCA9IGRlc2Muc2V0O1xuICAgIC8vIHNsaWNlKDIpIGN1eiAnb25jbGljaycgLT4gJ2NsaWNrJywgZXRjXG4gICAgY29uc3QgZXZlbnROYW1lID0gcHJvcC5zbGljZSgyKTtcbiAgICBsZXQgZXZlbnROYW1lU3ltYm9sID0gem9uZVN5bWJvbEV2ZW50TmFtZXMkMVtldmVudE5hbWVdO1xuICAgIGlmICghZXZlbnROYW1lU3ltYm9sKSB7XG4gICAgICAgIGV2ZW50TmFtZVN5bWJvbCA9IHpvbmVTeW1ib2xFdmVudE5hbWVzJDFbZXZlbnROYW1lXSA9IHpvbmVTeW1ib2woJ09OX1BST1BFUlRZJyArIGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGRlc2Muc2V0ID0gZnVuY3Rpb24gKG5ld1ZhbHVlKSB7XG4gICAgICAgIC8vIGluIHNvbWUgb2Ygd2luZG93cydzIG9ucHJvcGVydHkgY2FsbGJhY2ssIHRoaXMgaXMgdW5kZWZpbmVkXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gY2hlY2sgaXRcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXM7XG4gICAgICAgIGlmICghdGFyZ2V0ICYmIG9iaiA9PT0gX2dsb2JhbCkge1xuICAgICAgICAgICAgdGFyZ2V0ID0gX2dsb2JhbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZXZpb3VzVmFsdWUgPSB0YXJnZXRbZXZlbnROYW1lU3ltYm9sXTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmV2aW91c1ZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHdyYXBGbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaXNzdWUgIzk3OCwgd2hlbiBvbmxvYWQgaGFuZGxlciB3YXMgYWRkZWQgYmVmb3JlIGxvYWRpbmcgem9uZS5qc1xuICAgICAgICAvLyB3ZSBzaG91bGQgcmVtb3ZlIGl0IHdpdGggb3JpZ2luYWxEZXNjU2V0XG4gICAgICAgIG9yaWdpbmFsRGVzY1NldCAmJiBvcmlnaW5hbERlc2NTZXQuY2FsbCh0YXJnZXQsIG51bGwpO1xuICAgICAgICB0YXJnZXRbZXZlbnROYW1lU3ltYm9sXSA9IG5ld1ZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIHdyYXBGbiwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBUaGUgZ2V0dGVyIHdvdWxkIHJldHVybiB1bmRlZmluZWQgZm9yIHVuYXNzaWduZWQgcHJvcGVydGllcyBidXQgdGhlIGRlZmF1bHQgdmFsdWUgb2YgYW5cbiAgICAvLyB1bmFzc2lnbmVkIHByb3BlcnR5IGlzIG51bGxcbiAgICBkZXNjLmdldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gaW4gc29tZSBvZiB3aW5kb3dzJ3Mgb25wcm9wZXJ0eSBjYWxsYmFjaywgdGhpcyBpcyB1bmRlZmluZWRcbiAgICAgICAgLy8gc28gd2UgbmVlZCB0byBjaGVjayBpdFxuICAgICAgICBsZXQgdGFyZ2V0ID0gdGhpcztcbiAgICAgICAgaWYgKCF0YXJnZXQgJiYgb2JqID09PSBfZ2xvYmFsKSB7XG4gICAgICAgICAgICB0YXJnZXQgPSBfZ2xvYmFsO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsaXN0ZW5lciA9IHRhcmdldFtldmVudE5hbWVTeW1ib2xdO1xuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvcmlnaW5hbERlc2NHZXQpIHtcbiAgICAgICAgICAgIC8vIHJlc3VsdCB3aWxsIGJlIG51bGwgd2hlbiB1c2UgaW5saW5lIGV2ZW50IGF0dHJpYnV0ZSxcbiAgICAgICAgICAgIC8vIHN1Y2ggYXMgPGJ1dHRvbiBvbmNsaWNrPVwiZnVuYygpO1wiPk9LPC9idXR0b24+XG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBvbmNsaWNrIGZ1bmN0aW9uIGlzIGludGVybmFsIHJhdyB1bmNvbXBpbGVkIGhhbmRsZXJcbiAgICAgICAgICAgIC8vIHRoZSBvbmNsaWNrIHdpbGwgYmUgZXZhbHVhdGVkIHdoZW4gZmlyc3QgdGltZSBldmVudCB3YXMgdHJpZ2dlcmVkIG9yXG4gICAgICAgICAgICAvLyB0aGUgcHJvcGVydHkgaXMgYWNjZXNzZWQsIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzUyNVxuICAgICAgICAgICAgLy8gc28gd2Ugc2hvdWxkIHVzZSBvcmlnaW5hbCBuYXRpdmUgZ2V0IHRvIHJldHJpZXZlIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSBvcmlnaW5hbERlc2NHZXQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGRlc2Muc2V0LmNhbGwodGhpcywgdmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W1JFTU9WRV9BVFRSSUJVVEVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUocHJvcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIE9iamVjdERlZmluZVByb3BlcnR5KG9iaiwgcHJvcCwgZGVzYyk7XG4gICAgb2JqW29uUHJvcFBhdGNoZWRTeW1ib2xdID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHBhdGNoT25Qcm9wZXJ0aWVzKG9iaiwgcHJvcGVydGllcywgcHJvdG90eXBlKSB7XG4gICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBwYXRjaFByb3BlcnR5KG9iaiwgJ29uJyArIHByb3BlcnRpZXNbaV0sIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IG9uUHJvcGVydGllcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5zbGljZSgwLCAyKSA9PSAnb24nKSB7XG4gICAgICAgICAgICAgICAgb25Qcm9wZXJ0aWVzLnB1c2gocHJvcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBvblByb3BlcnRpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHBhdGNoUHJvcGVydHkob2JqLCBvblByb3BlcnRpZXNbal0sIHByb3RvdHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5jb25zdCBvcmlnaW5hbEluc3RhbmNlS2V5ID0gem9uZVN5bWJvbCgnb3JpZ2luYWxJbnN0YW5jZScpO1xuLy8gd3JhcCBzb21lIG5hdGl2ZSBBUEkgb24gYHdpbmRvd2BcbmZ1bmN0aW9uIHBhdGNoQ2xhc3MoY2xhc3NOYW1lKSB7XG4gICAgY29uc3QgT3JpZ2luYWxDbGFzcyA9IF9nbG9iYWxbY2xhc3NOYW1lXTtcbiAgICBpZiAoIU9yaWdpbmFsQ2xhc3MpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBrZWVwIG9yaWdpbmFsIGNsYXNzIGluIGdsb2JhbFxuICAgIF9nbG9iYWxbem9uZVN5bWJvbChjbGFzc05hbWUpXSA9IE9yaWdpbmFsQ2xhc3M7XG4gICAgX2dsb2JhbFtjbGFzc05hbWVdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBhID0gYmluZEFyZ3VtZW50cyhhcmd1bWVudHMsIGNsYXNzTmFtZSk7XG4gICAgICAgIHN3aXRjaCAoYS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldID0gbmV3IE9yaWdpbmFsQ2xhc3MoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldID0gbmV3IE9yaWdpbmFsQ2xhc3MoYVswXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XSA9IG5ldyBPcmlnaW5hbENsYXNzKGFbMF0sIGFbMV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIHRoaXNbb3JpZ2luYWxJbnN0YW5jZUtleV0gPSBuZXcgT3JpZ2luYWxDbGFzcyhhWzBdLCBhWzFdLCBhWzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldID0gbmV3IE9yaWdpbmFsQ2xhc3MoYVswXSwgYVsxXSwgYVsyXSwgYVszXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXJnIGxpc3QgdG9vIGxvbmcuJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIGF0dGFjaCBvcmlnaW5hbCBkZWxlZ2F0ZSB0byBwYXRjaGVkIGZ1bmN0aW9uXG4gICAgYXR0YWNoT3JpZ2luVG9QYXRjaGVkKF9nbG9iYWxbY2xhc3NOYW1lXSwgT3JpZ2luYWxDbGFzcyk7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgT3JpZ2luYWxDbGFzcyhmdW5jdGlvbiAoKSB7IH0pO1xuICAgIGxldCBwcm9wO1xuICAgIGZvciAocHJvcCBpbiBpbnN0YW5jZSkge1xuICAgICAgICAvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9NDQ3MjFcbiAgICAgICAgaWYgKGNsYXNzTmFtZSA9PT0gJ1hNTEh0dHBSZXF1ZXN0JyAmJiBwcm9wID09PSAncmVzcG9uc2VCbG9iJylcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAoZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5zdGFuY2VbcHJvcF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBfZ2xvYmFsW2NsYXNzTmFtZV0ucHJvdG90eXBlW3Byb3BdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XVtwcm9wXS5hcHBseSh0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eShfZ2xvYmFsW2NsYXNzTmFtZV0ucHJvdG90eXBlLCBwcm9wLCB7XG4gICAgICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1tvcmlnaW5hbEluc3RhbmNlS2V5XVtwcm9wXSA9IHdyYXBXaXRoQ3VycmVudFpvbmUoZm4sIGNsYXNzTmFtZSArICcuJyArIHByb3ApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGtlZXAgY2FsbGJhY2sgaW4gd3JhcHBlZCBmdW5jdGlvbiBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgaXQgaW4gRnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nIHRvIHJldHVyblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBuYXRpdmUgb25lLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZCh0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldW3Byb3BdLCBmbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW29yaWdpbmFsSW5zdGFuY2VLZXldW3Byb3BdID0gZm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbb3JpZ2luYWxJbnN0YW5jZUtleV1bcHJvcF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfShwcm9wKSk7XG4gICAgfVxuICAgIGZvciAocHJvcCBpbiBPcmlnaW5hbENsYXNzKSB7XG4gICAgICAgIGlmIChwcm9wICE9PSAncHJvdG90eXBlJyAmJiBPcmlnaW5hbENsYXNzLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBfZ2xvYmFsW2NsYXNzTmFtZV1bcHJvcF0gPSBPcmlnaW5hbENsYXNzW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gcGF0Y2hNZXRob2QodGFyZ2V0LCBuYW1lLCBwYXRjaEZuKSB7XG4gICAgbGV0IHByb3RvID0gdGFyZ2V0O1xuICAgIHdoaWxlIChwcm90byAmJiAhcHJvdG8uaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgcHJvdG8gPSBPYmplY3RHZXRQcm90b3R5cGVPZihwcm90byk7XG4gICAgfVxuICAgIGlmICghcHJvdG8gJiYgdGFyZ2V0W25hbWVdKSB7XG4gICAgICAgIC8vIHNvbWVob3cgd2UgZGlkIG5vdCBmaW5kIGl0LCBidXQgd2UgY2FuIHNlZSBpdC4gVGhpcyBoYXBwZW5zIG9uIElFIGZvciBXaW5kb3cgcHJvcGVydGllcy5cbiAgICAgICAgcHJvdG8gPSB0YXJnZXQ7XG4gICAgfVxuICAgIGNvbnN0IGRlbGVnYXRlTmFtZSA9IHpvbmVTeW1ib2wobmFtZSk7XG4gICAgbGV0IGRlbGVnYXRlID0gbnVsbDtcbiAgICBpZiAocHJvdG8gJiYgKCEoZGVsZWdhdGUgPSBwcm90b1tkZWxlZ2F0ZU5hbWVdKSB8fCAhcHJvdG8uaGFzT3duUHJvcGVydHkoZGVsZWdhdGVOYW1lKSkpIHtcbiAgICAgICAgZGVsZWdhdGUgPSBwcm90b1tkZWxlZ2F0ZU5hbWVdID0gcHJvdG9bbmFtZV07XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgcHJvdG9bbmFtZV0gaXMgd3JpdGFibGVcbiAgICAgICAgLy8gc29tZSBwcm9wZXJ0eSBpcyByZWFkb25seSBpbiBzYWZhcmksIHN1Y2ggYXMgSHRtbENhbnZhc0VsZW1lbnQucHJvdG90eXBlLnRvQmxvYlxuICAgICAgICBjb25zdCBkZXNjID0gcHJvdG8gJiYgT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCBuYW1lKTtcbiAgICAgICAgaWYgKGlzUHJvcGVydHlXcml0YWJsZShkZXNjKSkge1xuICAgICAgICAgICAgY29uc3QgcGF0Y2hEZWxlZ2F0ZSA9IHBhdGNoRm4oZGVsZWdhdGUsIGRlbGVnYXRlTmFtZSwgbmFtZSk7XG4gICAgICAgICAgICBwcm90b1tuYW1lXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF0Y2hEZWxlZ2F0ZSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChwcm90b1tuYW1lXSwgZGVsZWdhdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkZWxlZ2F0ZTtcbn1cbi8vIFRPRE86IEBKaWFMaVBhc3Npb24sIHN1cHBvcnQgY2FuY2VsIHRhc2sgbGF0ZXIgaWYgbmVjZXNzYXJ5XG5mdW5jdGlvbiBwYXRjaE1hY3JvVGFzayhvYmosIGZ1bmNOYW1lLCBtZXRhQ3JlYXRvcikge1xuICAgIGxldCBzZXROYXRpdmUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayh0YXNrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0YXNrLmRhdGE7XG4gICAgICAgIGRhdGEuYXJnc1tkYXRhLmNiSWR4XSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRhc2suaW52b2tlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHNldE5hdGl2ZS5hcHBseShkYXRhLnRhcmdldCwgZGF0YS5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIHNldE5hdGl2ZSA9IHBhdGNoTWV0aG9kKG9iaiwgZnVuY05hbWUsIChkZWxlZ2F0ZSkgPT4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbWV0YSA9IG1ldGFDcmVhdG9yKHNlbGYsIGFyZ3MpO1xuICAgICAgICBpZiAobWV0YS5jYklkeCA+PSAwICYmIHR5cGVvZiBhcmdzW21ldGEuY2JJZHhdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gc2NoZWR1bGVNYWNyb1Rhc2tXaXRoQ3VycmVudFpvbmUobWV0YS5uYW1lLCBhcmdzW21ldGEuY2JJZHhdLCBtZXRhLCBzY2hlZHVsZVRhc2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gY2F1c2UgYW4gZXJyb3IgYnkgY2FsbGluZyBpdCBkaXJlY3RseS5cbiAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gYXR0YWNoT3JpZ2luVG9QYXRjaGVkKHBhdGNoZWQsIG9yaWdpbmFsKSB7XG4gICAgcGF0Y2hlZFt6b25lU3ltYm9sKCdPcmlnaW5hbERlbGVnYXRlJyldID0gb3JpZ2luYWw7XG59XG5sZXQgaXNEZXRlY3RlZElFT3JFZGdlID0gZmFsc2U7XG5sZXQgaWVPckVkZ2UgPSBmYWxzZTtcbmZ1bmN0aW9uIGlzSUUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdWEgPSBpbnRlcm5hbFdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50O1xuICAgICAgICBpZiAodWEuaW5kZXhPZignTVNJRSAnKSAhPT0gLTEgfHwgdWEuaW5kZXhPZignVHJpZGVudC8nKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0lFT3JFZGdlKCkge1xuICAgIGlmIChpc0RldGVjdGVkSUVPckVkZ2UpIHtcbiAgICAgICAgcmV0dXJuIGllT3JFZGdlO1xuICAgIH1cbiAgICBpc0RldGVjdGVkSUVPckVkZ2UgPSB0cnVlO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHVhID0gaW50ZXJuYWxXaW5kb3cubmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgaWYgKHVhLmluZGV4T2YoJ01TSUUgJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ1RyaWRlbnQvJykgIT09IC0xIHx8IHVhLmluZGV4T2YoJ0VkZ2UvJykgIT09IC0xKSB7XG4gICAgICAgICAgICBpZU9yRWRnZSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgfVxuICAgIHJldHVybiBpZU9yRWRnZTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5ab25lLl9fbG9hZF9wYXRjaCgnWm9uZUF3YXJlUHJvbWlzZScsIChnbG9iYWwsIFpvbmUsIGFwaSkgPT4ge1xuICAgIGNvbnN0IE9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG4gICAgY29uc3QgT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBPYmplY3QuZGVmaW5lUHJvcGVydHk7XG4gICAgZnVuY3Rpb24gcmVhZGFibGVPYmplY3RUb1N0cmluZyhvYmopIHtcbiAgICAgICAgaWYgKG9iaiAmJiBvYmoudG9TdHJpbmcgPT09IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IG9iai5jb25zdHJ1Y3RvciAmJiBvYmouY29uc3RydWN0b3IubmFtZTtcbiAgICAgICAgICAgIHJldHVybiAoY2xhc3NOYW1lID8gY2xhc3NOYW1lIDogJycpICsgJzogJyArIEpTT04uc3RyaW5naWZ5KG9iaik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iaiA/IG9iai50b1N0cmluZygpIDogT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaik7XG4gICAgfVxuICAgIGNvbnN0IF9fc3ltYm9sX18gPSBhcGkuc3ltYm9sO1xuICAgIGNvbnN0IF91bmNhdWdodFByb21pc2VFcnJvcnMgPSBbXTtcbiAgICBjb25zdCBpc0Rpc2FibGVXcmFwcGluZ1VuY2F1Z2h0UHJvbWlzZVJlamVjdGlvbiA9IGdsb2JhbFtfX3N5bWJvbF9fKCdESVNBQkxFX1dSQVBQSU5HX1VOQ0FVR0hUX1BST01JU0VfUkVKRUNUSU9OJyldID09PSB0cnVlO1xuICAgIGNvbnN0IHN5bWJvbFByb21pc2UgPSBfX3N5bWJvbF9fKCdQcm9taXNlJyk7XG4gICAgY29uc3Qgc3ltYm9sVGhlbiA9IF9fc3ltYm9sX18oJ3RoZW4nKTtcbiAgICBjb25zdCBjcmVhdGlvblRyYWNlID0gJ19fY3JlYXRpb25UcmFjZV9fJztcbiAgICBhcGkub25VbmhhbmRsZWRFcnJvciA9IChlKSA9PiB7XG4gICAgICAgIGlmIChhcGkuc2hvd1VuY2F1Z2h0RXJyb3IoKSkge1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0aW9uID0gZSAmJiBlLnJlamVjdGlvbjtcbiAgICAgICAgICAgIGlmIChyZWplY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdVbmhhbmRsZWQgUHJvbWlzZSByZWplY3Rpb246JywgcmVqZWN0aW9uIGluc3RhbmNlb2YgRXJyb3IgPyByZWplY3Rpb24ubWVzc2FnZSA6IHJlamVjdGlvbiwgJzsgWm9uZTonLCBlLnpvbmUubmFtZSwgJzsgVGFzazonLCBlLnRhc2sgJiYgZS50YXNrLnNvdXJjZSwgJzsgVmFsdWU6JywgcmVqZWN0aW9uLCByZWplY3Rpb24gaW5zdGFuY2VvZiBFcnJvciA/IHJlamVjdGlvbi5zdGFjayA6IHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBhcGkubWljcm90YXNrRHJhaW5Eb25lID0gKCkgPT4ge1xuICAgICAgICB3aGlsZSAoX3VuY2F1Z2h0UHJvbWlzZUVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVuY2F1Z2h0UHJvbWlzZUVycm9yID0gX3VuY2F1Z2h0UHJvbWlzZUVycm9ycy5zaGlmdCgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci56b25lLnJ1bkd1YXJkZWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAodW5jYXVnaHRQcm9taXNlRXJyb3IudGhyb3dPcmlnaW5hbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgdW5jYXVnaHRQcm9taXNlRXJyb3IucmVqZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IHVuY2F1Z2h0UHJvbWlzZUVycm9yO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlVW5oYW5kbGVkUmVqZWN0aW9uKGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgVU5IQU5ETEVEX1BST01JU0VfUkVKRUNUSU9OX0hBTkRMRVJfU1lNQk9MID0gX19zeW1ib2xfXygndW5oYW5kbGVkUHJvbWlzZVJlamVjdGlvbkhhbmRsZXInKTtcbiAgICBmdW5jdGlvbiBoYW5kbGVVbmhhbmRsZWRSZWplY3Rpb24oZSkge1xuICAgICAgICBhcGkub25VbmhhbmRsZWRFcnJvcihlKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSBab25lW1VOSEFORExFRF9QUk9NSVNFX1JFSkVDVElPTl9IQU5ETEVSX1NZTUJPTF07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzVGhlbmFibGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlLnRoZW47XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZvcndhcmRSZXNvbHV0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZm9yd2FyZFJlamVjdGlvbihyZWplY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIFpvbmVBd2FyZVByb21pc2UucmVqZWN0KHJlamVjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHN5bWJvbFN0YXRlID0gX19zeW1ib2xfXygnc3RhdGUnKTtcbiAgICBjb25zdCBzeW1ib2xWYWx1ZSA9IF9fc3ltYm9sX18oJ3ZhbHVlJyk7XG4gICAgY29uc3Qgc3ltYm9sRmluYWxseSA9IF9fc3ltYm9sX18oJ2ZpbmFsbHknKTtcbiAgICBjb25zdCBzeW1ib2xQYXJlbnRQcm9taXNlVmFsdWUgPSBfX3N5bWJvbF9fKCdwYXJlbnRQcm9taXNlVmFsdWUnKTtcbiAgICBjb25zdCBzeW1ib2xQYXJlbnRQcm9taXNlU3RhdGUgPSBfX3N5bWJvbF9fKCdwYXJlbnRQcm9taXNlU3RhdGUnKTtcbiAgICBjb25zdCBzb3VyY2UgPSAnUHJvbWlzZS50aGVuJztcbiAgICBjb25zdCBVTlJFU09MVkVEID0gbnVsbDtcbiAgICBjb25zdCBSRVNPTFZFRCA9IHRydWU7XG4gICAgY29uc3QgUkVKRUNURUQgPSBmYWxzZTtcbiAgICBjb25zdCBSRUpFQ1RFRF9OT19DQVRDSCA9IDA7XG4gICAgZnVuY3Rpb24gbWFrZVJlc29sdmVyKHByb21pc2UsIHN0YXRlKSB7XG4gICAgICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCBzdGF0ZSwgdik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgZmFsc2UsIGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBEbyBub3QgcmV0dXJuIHZhbHVlIG9yIHlvdSB3aWxsIGJyZWFrIHRoZSBQcm9taXNlIHNwZWMuXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG9uY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxldCB3YXNDYWxsZWQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIHdyYXBwZXIod3JhcHBlZEZ1bmN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICh3YXNDYWxsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB3YXNDYWxsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRGdW5jdGlvbi5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IFRZUEVfRVJST1IgPSAnUHJvbWlzZSByZXNvbHZlZCB3aXRoIGl0c2VsZic7XG4gICAgY29uc3QgQ1VSUkVOVF9UQVNLX1RSQUNFX1NZTUJPTCA9IF9fc3ltYm9sX18oJ2N1cnJlbnRUYXNrVHJhY2UnKTtcbiAgICAvLyBQcm9taXNlIFJlc29sdXRpb25cbiAgICBmdW5jdGlvbiByZXNvbHZlUHJvbWlzZShwcm9taXNlLCBzdGF0ZSwgdmFsdWUpIHtcbiAgICAgICAgY29uc3Qgb25jZVdyYXBwZXIgPSBvbmNlKCk7XG4gICAgICAgIGlmIChwcm9taXNlID09PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihUWVBFX0VSUk9SKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvbWlzZVtzeW1ib2xTdGF0ZV0gPT09IFVOUkVTT0xWRUQpIHtcbiAgICAgICAgICAgIC8vIHNob3VsZCBvbmx5IGdldCB2YWx1ZS50aGVuIG9uY2UgYmFzZWQgb24gcHJvbWlzZSBzcGVjLlxuICAgICAgICAgICAgbGV0IHRoZW4gPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhlbiA9IHZhbHVlICYmIHZhbHVlLnRoZW47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIG9uY2VXcmFwcGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgZmFsc2UsIGVycik7XG4gICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFpvbmVBd2FyZVByb21pc2UpIHtcbiAgICAgICAgICAgIGlmIChzdGF0ZSAhPT0gUkVKRUNURUQgJiYgdmFsdWUgaW5zdGFuY2VvZiBab25lQXdhcmVQcm9taXNlICYmXG4gICAgICAgICAgICAgICAgdmFsdWUuaGFzT3duUHJvcGVydHkoc3ltYm9sU3RhdGUpICYmIHZhbHVlLmhhc093blByb3BlcnR5KHN5bWJvbFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgIHZhbHVlW3N5bWJvbFN0YXRlXSAhPT0gVU5SRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgIGNsZWFyUmVqZWN0ZWROb0NhdGNoKHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvbWlzZShwcm9taXNlLCB2YWx1ZVtzeW1ib2xTdGF0ZV0sIHZhbHVlW3N5bWJvbFZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0ZSAhPT0gUkVKRUNURUQgJiYgdHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB0aGVuLmNhbGwodmFsdWUsIG9uY2VXcmFwcGVyKG1ha2VSZXNvbHZlcihwcm9taXNlLCBzdGF0ZSkpLCBvbmNlV3JhcHBlcihtYWtlUmVzb2x2ZXIocHJvbWlzZSwgZmFsc2UpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgb25jZVdyYXBwZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgZmFsc2UsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvbWlzZVtzeW1ib2xTdGF0ZV0gPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IHByb21pc2Vbc3ltYm9sVmFsdWVdO1xuICAgICAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sVmFsdWVdID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgaWYgKHByb21pc2Vbc3ltYm9sRmluYWxseV0gPT09IHN5bWJvbEZpbmFsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHByb21pc2UgaXMgZ2VuZXJhdGVkIGJ5IFByb21pc2UucHJvdG90eXBlLmZpbmFsbHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlID09PSBSRVNPTFZFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdGhlIHN0YXRlIGlzIHJlc29sdmVkLCBzaG91bGQgaWdub3JlIHRoZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHVzZSBwYXJlbnQgcHJvbWlzZSB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZVtzeW1ib2xTdGF0ZV0gPSBwcm9taXNlW3N5bWJvbFBhcmVudFByb21pc2VTdGF0ZV07XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9taXNlW3N5bWJvbFZhbHVlXSA9IHByb21pc2Vbc3ltYm9sUGFyZW50UHJvbWlzZVZhbHVlXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyByZWNvcmQgdGFzayBpbmZvcm1hdGlvbiBpbiB2YWx1ZSB3aGVuIGVycm9yIG9jY3Vycywgc28gd2UgY2FuXG4gICAgICAgICAgICAgICAgLy8gZG8gc29tZSBhZGRpdGlvbmFsIHdvcmsgc3VjaCBhcyByZW5kZXIgbG9uZ1N0YWNrVHJhY2VcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUgPT09IFJFSkVDVEVEICYmIHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgbG9uZ1N0YWNrVHJhY2Vab25lIGlzIGhlcmVcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHJhY2UgPSBab25lLmN1cnJlbnRUYXNrICYmIFpvbmUuY3VycmVudFRhc2suZGF0YSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgWm9uZS5jdXJyZW50VGFzay5kYXRhW2NyZWF0aW9uVHJhY2VdO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkga2VlcCB0aGUgbG9uZyBzdGFjayB0cmFjZSBpbnRvIGVycm9yIHdoZW4gaW4gbG9uZ1N0YWNrVHJhY2Vab25lXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3REZWZpbmVQcm9wZXJ0eSh2YWx1ZSwgQ1VSUkVOVF9UQVNLX1RSQUNFX1NZTUJPTCwgeyBjb25maWd1cmFibGU6IHRydWUsIGVudW1lcmFibGU6IGZhbHNlLCB3cml0YWJsZTogdHJ1ZSwgdmFsdWU6IHRyYWNlIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcXVldWUubGVuZ3RoOykge1xuICAgICAgICAgICAgICAgICAgICBzY2hlZHVsZVJlc29sdmVPclJlamVjdChwcm9taXNlLCBxdWV1ZVtpKytdLCBxdWV1ZVtpKytdLCBxdWV1ZVtpKytdLCBxdWV1ZVtpKytdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PSAwICYmIHN0YXRlID09IFJFSkVDVEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gUkVKRUNURURfTk9fQ0FUQ0g7XG4gICAgICAgICAgICAgICAgICAgIGxldCB1bmNhdWdodFByb21pc2VFcnJvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGVyZSB3ZSB0aHJvd3MgYSBuZXcgRXJyb3IgdG8gcHJpbnQgbW9yZSByZWFkYWJsZSBlcnJvciBsb2dcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiB0aGUgdmFsdWUgaXMgbm90IGFuIGVycm9yLCB6b25lLmpzIGJ1aWxkcyBhbiBgRXJyb3JgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBPYmplY3QgaGVyZSB0byBhdHRhY2ggdGhlIHN0YWNrIGluZm9ybWF0aW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNhdWdodCAoaW4gcHJvbWlzZSk6ICcgKyByZWFkYWJsZU9iamVjdFRvU3RyaW5nKHZhbHVlKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHZhbHVlICYmIHZhbHVlLnN0YWNrID8gJ1xcbicgKyB2YWx1ZS5zdGFjayA6ICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5jYXVnaHRQcm9taXNlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzRGlzYWJsZVdyYXBwaW5nVW5jYXVnaHRQcm9taXNlUmVqZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJZiBkaXNhYmxlIHdyYXBwaW5nIHVuY2F1Z2h0IHByb21pc2UgcmVqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdGhlIHZhbHVlIGluc3RlYWQgb2Ygd3JhcHBpbmcgaXQuXG4gICAgICAgICAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci50aHJvd09yaWdpbmFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB1bmNhdWdodFByb21pc2VFcnJvci5yZWplY3Rpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgdW5jYXVnaHRQcm9taXNlRXJyb3IucHJvbWlzZSA9IHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIHVuY2F1Z2h0UHJvbWlzZUVycm9yLnpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHVuY2F1Z2h0UHJvbWlzZUVycm9yLnRhc2sgPSBab25lLmN1cnJlbnRUYXNrO1xuICAgICAgICAgICAgICAgICAgICBfdW5jYXVnaHRQcm9taXNlRXJyb3JzLnB1c2godW5jYXVnaHRQcm9taXNlRXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBhcGkuc2NoZWR1bGVNaWNyb1Rhc2soKTsgLy8gdG8gbWFrZSBzdXJlIHRoYXQgaXQgaXMgcnVubmluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBSZXNvbHZpbmcgYW4gYWxyZWFkeSByZXNvbHZlZCBwcm9taXNlIGlzIGEgbm9vcC5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IFJFSkVDVElPTl9IQU5ETEVEX0hBTkRMRVIgPSBfX3N5bWJvbF9fKCdyZWplY3Rpb25IYW5kbGVkSGFuZGxlcicpO1xuICAgIGZ1bmN0aW9uIGNsZWFyUmVqZWN0ZWROb0NhdGNoKHByb21pc2UpIHtcbiAgICAgICAgaWYgKHByb21pc2Vbc3ltYm9sU3RhdGVdID09PSBSRUpFQ1RFRF9OT19DQVRDSCkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHByb21pc2UgaXMgcmVqZWN0ZWQgbm8gY2F0Y2ggc3RhdHVzXG4gICAgICAgICAgICAvLyBhbmQgcXVldWUubGVuZ3RoID4gMCwgbWVhbnMgdGhlcmUgaXMgYSBlcnJvciBoYW5kbGVyXG4gICAgICAgICAgICAvLyBoZXJlIHRvIGhhbmRsZSB0aGUgcmVqZWN0ZWQgcHJvbWlzZSwgd2Ugc2hvdWxkIHRyaWdnZXJcbiAgICAgICAgICAgIC8vIHdpbmRvd3MucmVqZWN0aW9uaGFuZGxlZCBldmVudEhhbmRsZXIgb3Igbm9kZWpzIHJlamVjdGlvbkhhbmRsZWRcbiAgICAgICAgICAgIC8vIGV2ZW50SGFuZGxlclxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVyID0gWm9uZVtSRUpFQ1RJT05fSEFORExFRF9IQU5ETEVSXTtcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlciAmJiB0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgeyByZWplY3Rpb246IHByb21pc2Vbc3ltYm9sVmFsdWVdLCBwcm9taXNlOiBwcm9taXNlIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gUkVKRUNURUQ7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IF91bmNhdWdodFByb21pc2VFcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAocHJvbWlzZSA9PT0gX3VuY2F1Z2h0UHJvbWlzZUVycm9yc1tpXS5wcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIF91bmNhdWdodFByb21pc2VFcnJvcnMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzY2hlZHVsZVJlc29sdmVPclJlamVjdChwcm9taXNlLCB6b25lLCBjaGFpblByb21pc2UsIG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gICAgICAgIGNsZWFyUmVqZWN0ZWROb0NhdGNoKHByb21pc2UpO1xuICAgICAgICBjb25zdCBwcm9taXNlU3RhdGUgPSBwcm9taXNlW3N5bWJvbFN0YXRlXTtcbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSBwcm9taXNlU3RhdGUgP1xuICAgICAgICAgICAgKHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJykgPyBvbkZ1bGZpbGxlZCA6IGZvcndhcmRSZXNvbHV0aW9uIDpcbiAgICAgICAgICAgICh0eXBlb2Ygb25SZWplY3RlZCA9PT0gJ2Z1bmN0aW9uJykgPyBvblJlamVjdGVkIDpcbiAgICAgICAgICAgICAgICBmb3J3YXJkUmVqZWN0aW9uO1xuICAgICAgICB6b25lLnNjaGVkdWxlTWljcm9UYXNrKHNvdXJjZSwgKCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJlbnRQcm9taXNlVmFsdWUgPSBwcm9taXNlW3N5bWJvbFZhbHVlXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpc0ZpbmFsbHlQcm9taXNlID0gISFjaGFpblByb21pc2UgJiYgc3ltYm9sRmluYWxseSA9PT0gY2hhaW5Qcm9taXNlW3N5bWJvbEZpbmFsbHldO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpbmFsbHlQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBwcm9taXNlIGlzIGdlbmVyYXRlZCBmcm9tIGZpbmFsbHkgY2FsbCwga2VlcCBwYXJlbnQgcHJvbWlzZSdzIHN0YXRlIGFuZCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBjaGFpblByb21pc2Vbc3ltYm9sUGFyZW50UHJvbWlzZVZhbHVlXSA9IHBhcmVudFByb21pc2VWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5Qcm9taXNlW3N5bWJvbFBhcmVudFByb21pc2VTdGF0ZV0gPSBwcm9taXNlU3RhdGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHNob3VsZCBub3QgcGFzcyB2YWx1ZSB0byBmaW5hbGx5IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB6b25lLnJ1bihkZWxlZ2F0ZSwgdW5kZWZpbmVkLCBpc0ZpbmFsbHlQcm9taXNlICYmIGRlbGVnYXRlICE9PSBmb3J3YXJkUmVqZWN0aW9uICYmIGRlbGVnYXRlICE9PSBmb3J3YXJkUmVzb2x1dGlvbiA/XG4gICAgICAgICAgICAgICAgICAgIFtdIDpcbiAgICAgICAgICAgICAgICAgICAgW3BhcmVudFByb21pc2VWYWx1ZV0pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVQcm9taXNlKGNoYWluUHJvbWlzZSwgdHJ1ZSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgZXJyb3Igb2NjdXJzLCBzaG91bGQgYWx3YXlzIHJldHVybiB0aGlzIGVycm9yXG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UoY2hhaW5Qcm9taXNlLCBmYWxzZSwgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBjaGFpblByb21pc2UpO1xuICAgIH1cbiAgICBjb25zdCBaT05FX0FXQVJFX1BST01JU0VfVE9fU1RSSU5HID0gJ2Z1bmN0aW9uIFpvbmVBd2FyZVByb21pc2UoKSB7IFtuYXRpdmUgY29kZV0gfSc7XG4gICAgY29uc3Qgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBjb25zdCBBZ2dyZWdhdGVFcnJvciA9IGdsb2JhbC5BZ2dyZWdhdGVFcnJvcjtcbiAgICBjbGFzcyBab25lQXdhcmVQcm9taXNlIHtcbiAgICAgICAgc3RhdGljIHRvU3RyaW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIFpPTkVfQVdBUkVfUFJPTUlTRV9UT19TVFJJTkc7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIHJlc29sdmUodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiByZXNvbHZlUHJvbWlzZShuZXcgdGhpcyhudWxsKSwgUkVTT0xWRUQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgcmVqZWN0KGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzb2x2ZVByb21pc2UobmV3IHRoaXMobnVsbCksIFJFSkVDVEVELCBlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGljIGFueSh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGlmICghdmFsdWVzIHx8IHR5cGVvZiB2YWx1ZXNbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10sICdBbGwgcHJvbWlzZXMgd2VyZSByZWplY3RlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICBsZXQgY291bnQgPSAwO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCB2IG9mIHZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICBwcm9taXNlcy5wdXNoKFpvbmVBd2FyZVByb21pc2UucmVzb2x2ZSh2KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10sICdBbGwgcHJvbWlzZXMgd2VyZSByZWplY3RlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWdncmVnYXRlRXJyb3IoW10sICdBbGwgcHJvbWlzZXMgd2VyZSByZWplY3RlZCcpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBmaW5pc2hlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gW107XG4gICAgICAgICAgICByZXR1cm4gbmV3IFpvbmVBd2FyZVByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJvbWlzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXNbaV0udGhlbih2ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaW5pc2hlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodik7XG4gICAgICAgICAgICAgICAgICAgIH0sIGVyciA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY291bnQtLTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEFnZ3JlZ2F0ZUVycm9yKGVycm9ycywgJ0FsbCBwcm9taXNlcyB3ZXJlIHJlamVjdGVkJykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIHN0YXRpYyByYWNlKHZhbHVlcykge1xuICAgICAgICAgICAgbGV0IHJlc29sdmU7XG4gICAgICAgICAgICBsZXQgcmVqZWN0O1xuICAgICAgICAgICAgbGV0IHByb21pc2UgPSBuZXcgdGhpcygocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZnVuY3Rpb24gb25SZXNvbHZlKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBvblJlamVjdChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCB2YWx1ZSBvZiB2YWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVGhlbmFibGUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy5yZXNvbHZlKHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRpYyBhbGwodmFsdWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gWm9uZUF3YXJlUHJvbWlzZS5hbGxXaXRoQ2FsbGJhY2sodmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWxsU2V0dGxlZCh2YWx1ZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IFAgPSB0aGlzICYmIHRoaXMucHJvdG90eXBlIGluc3RhbmNlb2YgWm9uZUF3YXJlUHJvbWlzZSA/IHRoaXMgOiBab25lQXdhcmVQcm9taXNlO1xuICAgICAgICAgICAgcmV0dXJuIFAuYWxsV2l0aENhbGxiYWNrKHZhbHVlcywge1xuICAgICAgICAgICAgICAgIHRoZW5DYWxsYmFjazogKHZhbHVlKSA9PiAoeyBzdGF0dXM6ICdmdWxmaWxsZWQnLCB2YWx1ZSB9KSxcbiAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrOiAoZXJyKSA9PiAoeyBzdGF0dXM6ICdyZWplY3RlZCcsIHJlYXNvbjogZXJyIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0aWMgYWxsV2l0aENhbGxiYWNrKHZhbHVlcywgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGxldCBwcm9taXNlID0gbmV3IHRoaXMoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSA9IHJlcztcbiAgICAgICAgICAgICAgICByZWplY3QgPSByZWo7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGF0IDIgdG8gcHJldmVudCBwcmVtYXR1cmVseSByZXNvbHZpbmcgaWYgLnRoZW4gaXMgY2FsbGVkIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgbGV0IHVucmVzb2x2ZWRDb3VudCA9IDI7XG4gICAgICAgICAgICBsZXQgdmFsdWVJbmRleCA9IDA7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlZFZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgdmFsdWUgb2YgdmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1RoZW5hYmxlKHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMucmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGN1clZhbHVlSW5kZXggPSB2YWx1ZUluZGV4O1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlLnRoZW4oKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlc1tjdXJWYWx1ZUluZGV4XSA9IGNhbGxiYWNrID8gY2FsbGJhY2sudGhlbkNhbGxiYWNrKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZENvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodW5yZXNvbHZlZENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmVkVmFsdWVzW2N1clZhbHVlSW5kZXhdID0gY2FsbGJhY2suZXJyb3JDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkQ291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShyZXNvbHZlZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKHRoZW5FcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KHRoZW5FcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bnJlc29sdmVkQ291bnQrKztcbiAgICAgICAgICAgICAgICB2YWx1ZUluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHRoZSB1bnJlc29sdmVkQ291bnQgemVyby1iYXNlZCBhZ2Fpbi5cbiAgICAgICAgICAgIHVucmVzb2x2ZWRDb3VudCAtPSAyO1xuICAgICAgICAgICAgaWYgKHVucmVzb2x2ZWRDb3VudCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJlc29sdmUocmVzb2x2ZWRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3RydWN0b3IoZXhlY3V0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKCEocHJvbWlzZSBpbnN0YW5jZW9mIFpvbmVBd2FyZVByb21pc2UpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdNdXN0IGJlIGFuIGluc3RhbmNlb2YgUHJvbWlzZS4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sU3RhdGVdID0gVU5SRVNPTFZFRDtcbiAgICAgICAgICAgIHByb21pc2Vbc3ltYm9sVmFsdWVdID0gW107IC8vIHF1ZXVlO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBvbmNlV3JhcHBlciA9IG9uY2UoKTtcbiAgICAgICAgICAgICAgICBleGVjdXRvciAmJlxuICAgICAgICAgICAgICAgICAgICBleGVjdXRvcihvbmNlV3JhcHBlcihtYWtlUmVzb2x2ZXIocHJvbWlzZSwgUkVTT0xWRUQpKSwgb25jZVdyYXBwZXIobWFrZVJlc29sdmVyKHByb21pc2UsIFJFSkVDVEVEKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVByb21pc2UocHJvbWlzZSwgZmFsc2UsIGVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBnZXQgW1N5bWJvbC50b1N0cmluZ1RhZ10oKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1Byb21pc2UnO1xuICAgICAgICB9XG4gICAgICAgIGdldCBbU3ltYm9sLnNwZWNpZXNdKCkge1xuICAgICAgICAgICAgcmV0dXJuIFpvbmVBd2FyZVByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhlbihvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLy8gV2UgbXVzdCByZWFkIGBTeW1ib2wuc3BlY2llc2Agc2FmZWx5IGJlY2F1c2UgYHRoaXNgIG1heSBiZSBhbnl0aGluZy4gRm9yIGluc3RhbmNlLCBgdGhpc2BcbiAgICAgICAgICAgIC8vIG1heSBiZSBhbiBvYmplY3Qgd2l0aG91dCBhIHByb3RvdHlwZSAoY3JlYXRlZCB0aHJvdWdoIGBPYmplY3QuY3JlYXRlKG51bGwpYCk7IHRodXNcbiAgICAgICAgICAgIC8vIGB0aGlzLmNvbnN0cnVjdG9yYCB3aWxsIGJlIHVuZGVmaW5lZC4gT25lIG9mIHRoZSB1c2UgY2FzZXMgaXMgU3lzdGVtSlMgY3JlYXRpbmdcbiAgICAgICAgICAgIC8vIHByb3RvdHlwZS1sZXNzIG9iamVjdHMgKG1vZHVsZXMpIHZpYSBgT2JqZWN0LmNyZWF0ZShudWxsKWAuIFRoZSBTeXN0ZW1KUyBjcmVhdGVzIGFuIGVtcHR5XG4gICAgICAgICAgICAvLyBvYmplY3QgYW5kIGNvcGllcyBwcm9taXNlIHByb3BlcnRpZXMgaW50byB0aGF0IG9iamVjdCAod2l0aGluIHRoZSBgZ2V0T3JDcmVhdGVMb2FkYFxuICAgICAgICAgICAgLy8gZnVuY3Rpb24pLiBUaGUgem9uZS5qcyB0aGVuIGNoZWNrcyBpZiB0aGUgcmVzb2x2ZWQgdmFsdWUgaGFzIHRoZSBgdGhlbmAgbWV0aG9kIGFuZCBpbnZva2VzXG4gICAgICAgICAgICAvLyBpdCB3aXRoIHRoZSBgdmFsdWVgIGNvbnRleHQuIE90aGVyd2lzZSwgdGhpcyB3aWxsIHRocm93IGFuIGVycm9yOiBgVHlwZUVycm9yOiBDYW5ub3QgcmVhZFxuICAgICAgICAgICAgLy8gcHJvcGVydGllcyBvZiB1bmRlZmluZWQgKHJlYWRpbmcgJ1N5bWJvbChTeW1ib2wuc3BlY2llcyknKWAuXG4gICAgICAgICAgICBsZXQgQyA9IChfYSA9IHRoaXMuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVtTeW1ib2wuc3BlY2llc107XG4gICAgICAgICAgICBpZiAoIUMgfHwgdHlwZW9mIEMgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBDID0gdGhpcy5jb25zdHJ1Y3RvciB8fCBab25lQXdhcmVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhaW5Qcm9taXNlID0gbmV3IEMobm9vcCk7XG4gICAgICAgICAgICBjb25zdCB6b25lID0gWm9uZS5jdXJyZW50O1xuICAgICAgICAgICAgaWYgKHRoaXNbc3ltYm9sU3RhdGVdID09IFVOUkVTT0xWRUQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW3N5bWJvbFZhbHVlXS5wdXNoKHpvbmUsIGNoYWluUHJvbWlzZSwgb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NoZWR1bGVSZXNvbHZlT3JSZWplY3QodGhpcywgem9uZSwgY2hhaW5Qcm9taXNlLCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY2hhaW5Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoKG9uUmVqZWN0ZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRoZW4obnVsbCwgb25SZWplY3RlZCk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseShvbkZpbmFsbHkpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIC8vIFNlZSBjb21tZW50IG9uIHRoZSBjYWxsIHRvIGB0aGVuYCBhYm91dCB3aHkgdGhlZSBgU3ltYm9sLnNwZWNpZXNgIGlzIHNhZmVseSBhY2Nlc3NlZC5cbiAgICAgICAgICAgIGxldCBDID0gKF9hID0gdGhpcy5jb25zdHJ1Y3RvcikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hW1N5bWJvbC5zcGVjaWVzXTtcbiAgICAgICAgICAgIGlmICghQyB8fCB0eXBlb2YgQyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIEMgPSBab25lQXdhcmVQcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2hhaW5Qcm9taXNlID0gbmV3IEMobm9vcCk7XG4gICAgICAgICAgICBjaGFpblByb21pc2Vbc3ltYm9sRmluYWxseV0gPSBzeW1ib2xGaW5hbGx5O1xuICAgICAgICAgICAgY29uc3Qgem9uZSA9IFpvbmUuY3VycmVudDtcbiAgICAgICAgICAgIGlmICh0aGlzW3N5bWJvbFN0YXRlXSA9PSBVTlJFU09MVkVEKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tzeW1ib2xWYWx1ZV0ucHVzaCh6b25lLCBjaGFpblByb21pc2UsIG9uRmluYWxseSwgb25GaW5hbGx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHNjaGVkdWxlUmVzb2x2ZU9yUmVqZWN0KHRoaXMsIHpvbmUsIGNoYWluUHJvbWlzZSwgb25GaW5hbGx5LCBvbkZpbmFsbHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNoYWluUHJvbWlzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBQcm90ZWN0IGFnYWluc3QgYWdncmVzc2l2ZSBvcHRpbWl6ZXJzIGRyb3BwaW5nIHNlZW1pbmdseSB1bnVzZWQgcHJvcGVydGllcy5cbiAgICAvLyBFLmcuIENsb3N1cmUgQ29tcGlsZXIgaW4gYWR2YW5jZWQgbW9kZS5cbiAgICBab25lQXdhcmVQcm9taXNlWydyZXNvbHZlJ10gPSBab25lQXdhcmVQcm9taXNlLnJlc29sdmU7XG4gICAgWm9uZUF3YXJlUHJvbWlzZVsncmVqZWN0J10gPSBab25lQXdhcmVQcm9taXNlLnJlamVjdDtcbiAgICBab25lQXdhcmVQcm9taXNlWydyYWNlJ10gPSBab25lQXdhcmVQcm9taXNlLnJhY2U7XG4gICAgWm9uZUF3YXJlUHJvbWlzZVsnYWxsJ10gPSBab25lQXdhcmVQcm9taXNlLmFsbDtcbiAgICBjb25zdCBOYXRpdmVQcm9taXNlID0gZ2xvYmFsW3N5bWJvbFByb21pc2VdID0gZ2xvYmFsWydQcm9taXNlJ107XG4gICAgZ2xvYmFsWydQcm9taXNlJ10gPSBab25lQXdhcmVQcm9taXNlO1xuICAgIGNvbnN0IHN5bWJvbFRoZW5QYXRjaGVkID0gX19zeW1ib2xfXygndGhlblBhdGNoZWQnKTtcbiAgICBmdW5jdGlvbiBwYXRjaFRoZW4oQ3Rvcikge1xuICAgICAgICBjb25zdCBwcm90byA9IEN0b3IucHJvdG90eXBlO1xuICAgICAgICBjb25zdCBwcm9wID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHByb3RvLCAndGhlbicpO1xuICAgICAgICBpZiAocHJvcCAmJiAocHJvcC53cml0YWJsZSA9PT0gZmFsc2UgfHwgIXByb3AuY29uZmlndXJhYmxlKSkge1xuICAgICAgICAgICAgLy8gY2hlY2sgQ3Rvci5wcm90b3R5cGUudGhlbiBwcm9wZXJ0eURlc2NyaXB0b3IgaXMgd3JpdGFibGUgb3Igbm90XG4gICAgICAgICAgICAvLyBpbiBtZXRlb3IgZW52LCB3cml0YWJsZSBpcyBmYWxzZSwgd2Ugc2hvdWxkIGlnbm9yZSBzdWNoIGNhc2VcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFRoZW4gPSBwcm90by50aGVuO1xuICAgICAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBvcmlnaW5hbCBtZXRob2QuXG4gICAgICAgIHByb3RvW3N5bWJvbFRoZW5dID0gb3JpZ2luYWxUaGVuO1xuICAgICAgICBDdG9yLnByb3RvdHlwZS50aGVuID0gZnVuY3Rpb24gKG9uUmVzb2x2ZSwgb25SZWplY3QpIHtcbiAgICAgICAgICAgIGNvbnN0IHdyYXBwZWQgPSBuZXcgWm9uZUF3YXJlUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgb3JpZ2luYWxUaGVuLmNhbGwodGhpcywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZWQudGhlbihvblJlc29sdmUsIG9uUmVqZWN0KTtcbiAgICAgICAgfTtcbiAgICAgICAgQ3RvcltzeW1ib2xUaGVuUGF0Y2hlZF0gPSB0cnVlO1xuICAgIH1cbiAgICBhcGkucGF0Y2hUaGVuID0gcGF0Y2hUaGVuO1xuICAgIGZ1bmN0aW9uIHpvbmVpZnkoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBsZXQgcmVzdWx0UHJvbWlzZSA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdFByb21pc2UgaW5zdGFuY2VvZiBab25lQXdhcmVQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY3RvciA9IHJlc3VsdFByb21pc2UuY29uc3RydWN0b3I7XG4gICAgICAgICAgICBpZiAoIWN0b3Jbc3ltYm9sVGhlblBhdGNoZWRdKSB7XG4gICAgICAgICAgICAgICAgcGF0Y2hUaGVuKGN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdFByb21pc2U7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChOYXRpdmVQcm9taXNlKSB7XG4gICAgICAgIHBhdGNoVGhlbihOYXRpdmVQcm9taXNlKTtcbiAgICAgICAgcGF0Y2hNZXRob2QoZ2xvYmFsLCAnZmV0Y2gnLCBkZWxlZ2F0ZSA9PiB6b25laWZ5KGRlbGVnYXRlKSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXMgbm90IHBhcnQgb2YgcHVibGljIEFQSSwgYnV0IGl0IGlzIHVzZWZ1bCBmb3IgdGVzdHMsIHNvIHdlIGV4cG9zZSBpdC5cbiAgICBQcm9taXNlW1pvbmUuX19zeW1ib2xfXygndW5jYXVnaHRQcm9taXNlRXJyb3JzJyldID0gX3VuY2F1Z2h0UHJvbWlzZUVycm9ycztcbiAgICByZXR1cm4gWm9uZUF3YXJlUHJvbWlzZTtcbn0pO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbi8vIG92ZXJyaWRlIEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyB0byBtYWtlIHpvbmUuanMgcGF0Y2hlZCBmdW5jdGlvblxuLy8gbG9vayBsaWtlIG5hdGl2ZSBmdW5jdGlvblxuWm9uZS5fX2xvYWRfcGF0Y2goJ3RvU3RyaW5nJywgKGdsb2JhbCkgPT4ge1xuICAgIC8vIHBhdGNoIEZ1bmMucHJvdG90eXBlLnRvU3RyaW5nIHRvIGxldCB0aGVtIGxvb2sgbGlrZSBuYXRpdmVcbiAgICBjb25zdCBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcgPSBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmc7XG4gICAgY29uc3QgT1JJR0lOQUxfREVMRUdBVEVfU1lNQk9MID0gem9uZVN5bWJvbCgnT3JpZ2luYWxEZWxlZ2F0ZScpO1xuICAgIGNvbnN0IFBST01JU0VfU1lNQk9MID0gem9uZVN5bWJvbCgnUHJvbWlzZScpO1xuICAgIGNvbnN0IEVSUk9SX1NZTUJPTCA9IHpvbmVTeW1ib2woJ0Vycm9yJyk7XG4gICAgY29uc3QgbmV3RnVuY3Rpb25Ub1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbmFsRGVsZWdhdGUgPSB0aGlzW09SSUdJTkFMX0RFTEVHQVRFX1NZTUJPTF07XG4gICAgICAgICAgICBpZiAob3JpZ2luYWxEZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxEZWxlZ2F0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nLmNhbGwob3JpZ2luYWxEZWxlZ2F0ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9yaWdpbmFsRGVsZWdhdGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzID09PSBQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmF0aXZlUHJvbWlzZSA9IGdsb2JhbFtQUk9NSVNFX1NZTUJPTF07XG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZVByb21pc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZy5jYWxsKG5hdGl2ZVByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzID09PSBFcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5hdGl2ZUVycm9yID0gZ2xvYmFsW0VSUk9SX1NZTUJPTF07XG4gICAgICAgICAgICAgICAgaWYgKG5hdGl2ZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuY2FsbChuYXRpdmVFcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEZ1bmN0aW9uVG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICB9O1xuICAgIG5ld0Z1bmN0aW9uVG9TdHJpbmdbT1JJR0lOQUxfREVMRUdBVEVfU1lNQk9MXSA9IG9yaWdpbmFsRnVuY3Rpb25Ub1N0cmluZztcbiAgICBGdW5jdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBuZXdGdW5jdGlvblRvU3RyaW5nO1xuICAgIC8vIHBhdGNoIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcgdG8gbGV0IHRoZW0gbG9vayBsaWtlIG5hdGl2ZVxuICAgIGNvbnN0IG9yaWdpbmFsT2JqZWN0VG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICAgIGNvbnN0IFBST01JU0VfT0JKRUNUX1RPX1NUUklORyA9ICdbb2JqZWN0IFByb21pc2VdJztcbiAgICBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIFByb21pc2UgPT09ICdmdW5jdGlvbicgJiYgdGhpcyBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBQUk9NSVNFX09CSkVDVF9UT19TVFJJTkc7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsT2JqZWN0VG9TdHJpbmcuY2FsbCh0aGlzKTtcbiAgICB9O1xufSk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xubGV0IHBhc3NpdmVTdXBwb3J0ZWQgPSBmYWxzZTtcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sICdwYXNzaXZlJywge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcGFzc2l2ZVN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOb3RlOiBXZSBwYXNzIHRoZSBgb3B0aW9uc2Agb2JqZWN0IGFzIHRoZSBldmVudCBoYW5kbGVyIHRvby4gVGhpcyBpcyBub3QgY29tcGF0aWJsZSB3aXRoIHRoZVxuICAgICAgICAvLyBzaWduYXR1cmUgb2YgYGFkZEV2ZW50TGlzdGVuZXJgIG9yIGByZW1vdmVFdmVudExpc3RlbmVyYCBidXQgZW5hYmxlcyB1cyB0byByZW1vdmUgdGhlIGhhbmRsZXJcbiAgICAgICAgLy8gd2l0aG91dCBhbiBhY3R1YWwgaGFuZGxlci5cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBvcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBwYXNzaXZlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgfVxufVxuLy8gYW4gaWRlbnRpZmllciB0byB0ZWxsIFpvbmVUYXNrIGRvIG5vdCBjcmVhdGUgYSBuZXcgaW52b2tlIGNsb3N1cmVcbmNvbnN0IE9QVElNSVpFRF9aT05FX0VWRU5UX1RBU0tfREFUQSA9IHtcbiAgICB1c2VHOiB0cnVlXG59O1xuY29uc3Qgem9uZVN5bWJvbEV2ZW50TmFtZXMgPSB7fTtcbmNvbnN0IGdsb2JhbFNvdXJjZXMgPSB7fTtcbmNvbnN0IEVWRU5UX05BTUVfU1lNQk9MX1JFR1ggPSBuZXcgUmVnRXhwKCdeJyArIFpPTkVfU1lNQk9MX1BSRUZJWCArICcoXFxcXHcrKSh0cnVlfGZhbHNlKSQnKTtcbmNvbnN0IElNTUVESUFURV9QUk9QQUdBVElPTl9TWU1CT0wgPSB6b25lU3ltYm9sKCdwcm9wYWdhdGlvblN0b3BwZWQnKTtcbmZ1bmN0aW9uIHByZXBhcmVFdmVudE5hbWVzKGV2ZW50TmFtZSwgZXZlbnROYW1lVG9TdHJpbmcpIHtcbiAgICBjb25zdCBmYWxzZUV2ZW50TmFtZSA9IChldmVudE5hbWVUb1N0cmluZyA/IGV2ZW50TmFtZVRvU3RyaW5nKGV2ZW50TmFtZSkgOiBldmVudE5hbWUpICsgRkFMU0VfU1RSO1xuICAgIGNvbnN0IHRydWVFdmVudE5hbWUgPSAoZXZlbnROYW1lVG9TdHJpbmcgPyBldmVudE5hbWVUb1N0cmluZyhldmVudE5hbWUpIDogZXZlbnROYW1lKSArIFRSVUVfU1RSO1xuICAgIGNvbnN0IHN5bWJvbCA9IFpPTkVfU1lNQk9MX1BSRUZJWCArIGZhbHNlRXZlbnROYW1lO1xuICAgIGNvbnN0IHN5bWJvbENhcHR1cmUgPSBaT05FX1NZTUJPTF9QUkVGSVggKyB0cnVlRXZlbnROYW1lO1xuICAgIHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV0gPSB7fTtcbiAgICB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdW0ZBTFNFX1NUUl0gPSBzeW1ib2w7XG4gICAgem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXVtUUlVFX1NUUl0gPSBzeW1ib2xDYXB0dXJlO1xufVxuZnVuY3Rpb24gcGF0Y2hFdmVudFRhcmdldChfZ2xvYmFsLCBhcGksIGFwaXMsIHBhdGNoT3B0aW9ucykge1xuICAgIGNvbnN0IEFERF9FVkVOVF9MSVNURU5FUiA9IChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLmFkZCkgfHwgQUREX0VWRU5UX0xJU1RFTkVSX1NUUjtcbiAgICBjb25zdCBSRU1PVkVfRVZFTlRfTElTVEVORVIgPSAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy5ybSkgfHwgUkVNT1ZFX0VWRU5UX0xJU1RFTkVSX1NUUjtcbiAgICBjb25zdCBMSVNURU5FUlNfRVZFTlRfTElTVEVORVIgPSAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy5saXN0ZW5lcnMpIHx8ICdldmVudExpc3RlbmVycyc7XG4gICAgY29uc3QgUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVIgPSAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy5ybUFsbCkgfHwgJ3JlbW92ZUFsbExpc3RlbmVycyc7XG4gICAgY29uc3Qgem9uZVN5bWJvbEFkZEV2ZW50TGlzdGVuZXIgPSB6b25lU3ltYm9sKEFERF9FVkVOVF9MSVNURU5FUik7XG4gICAgY29uc3QgQUREX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSA9ICcuJyArIEFERF9FVkVOVF9MSVNURU5FUiArICc6JztcbiAgICBjb25zdCBQUkVQRU5EX0VWRU5UX0xJU1RFTkVSID0gJ3ByZXBlbmRMaXN0ZW5lcic7XG4gICAgY29uc3QgUFJFUEVORF9FVkVOVF9MSVNURU5FUl9TT1VSQ0UgPSAnLicgKyBQUkVQRU5EX0VWRU5UX0xJU1RFTkVSICsgJzonO1xuICAgIGNvbnN0IGludm9rZVRhc2sgPSBmdW5jdGlvbiAodGFzaywgdGFyZ2V0LCBldmVudCkge1xuICAgICAgICAvLyBmb3IgYmV0dGVyIHBlcmZvcm1hbmNlLCBjaGVjayBpc1JlbW92ZWQgd2hpY2ggaXMgc2V0XG4gICAgICAgIC8vIGJ5IHJlbW92ZUV2ZW50TGlzdGVuZXJcbiAgICAgICAgaWYgKHRhc2suaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0YXNrLmNhbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIGRlbGVnYXRlID09PSAnb2JqZWN0JyAmJiBkZWxlZ2F0ZS5oYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIHRoZSBiaW5kIHZlcnNpb24gb2YgaGFuZGxlRXZlbnQgd2hlbiBpbnZva2VcbiAgICAgICAgICAgIHRhc2suY2FsbGJhY2sgPSAoZXZlbnQpID0+IGRlbGVnYXRlLmhhbmRsZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgICAgIHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA9IGRlbGVnYXRlO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludm9rZSBzdGF0aWMgdGFzay5pbnZva2VcbiAgICAgICAgLy8gbmVlZCB0byB0cnkvY2F0Y2ggZXJyb3IgaGVyZSwgb3RoZXJ3aXNlLCB0aGUgZXJyb3IgaW4gb25lIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIC8vIHdpbGwgYnJlYWsgdGhlIGV4ZWN1dGlvbnMgb2YgdGhlIG90aGVyIGV2ZW50IGxpc3RlbmVycy4gQWxzbyBlcnJvciB3aWxsXG4gICAgICAgIC8vIG5vdCByZW1vdmUgdGhlIGV2ZW50IGxpc3RlbmVyIHdoZW4gYG9uY2VgIG9wdGlvbnMgaXMgdHJ1ZS5cbiAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGFzay5pbnZva2UodGFzaywgdGFyZ2V0LCBbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBlcnJvciA9IGVycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0gdGFzay5vcHRpb25zO1xuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcgJiYgb3B0aW9ucy5vbmNlKSB7XG4gICAgICAgICAgICAvLyBpZiBvcHRpb25zLm9uY2UgaXMgdHJ1ZSwgYWZ0ZXIgaW52b2tlIG9uY2UgcmVtb3ZlIGxpc3RlbmVyIGhlcmVcbiAgICAgICAgICAgIC8vIG9ubHkgYnJvd3NlciBuZWVkIHRvIGRvIHRoaXMsIG5vZGVqcyBldmVudEVtaXR0ZXIgd2lsbCBjYWwgcmVtb3ZlTGlzdGVuZXJcbiAgICAgICAgICAgIC8vIGluc2lkZSBFdmVudEVtaXR0ZXIub25jZVxuICAgICAgICAgICAgY29uc3QgZGVsZWdhdGUgPSB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgPyB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgOiB0YXNrLmNhbGxiYWNrO1xuICAgICAgICAgICAgdGFyZ2V0W1JFTU9WRV9FVkVOVF9MSVNURU5FUl0uY2FsbCh0YXJnZXQsIGV2ZW50LnR5cGUsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnbG9iYWxDYWxsYmFjayhjb250ZXh0LCBldmVudCwgaXNDYXB0dXJlKSB7XG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzkxMSwgaW4gSUUsIHNvbWV0aW1lc1xuICAgICAgICAvLyBldmVudCB3aWxsIGJlIHVuZGVmaW5lZCwgc28gd2UgbmVlZCB0byB1c2Ugd2luZG93LmV2ZW50XG4gICAgICAgIGV2ZW50ID0gZXZlbnQgfHwgX2dsb2JhbC5ldmVudDtcbiAgICAgICAgaWYgKCFldmVudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGV2ZW50LnRhcmdldCBpcyBuZWVkZWQgZm9yIFNhbXN1bmcgVFYgYW5kIFNvdXJjZUJ1ZmZlclxuICAgICAgICAvLyB8fCBnbG9iYWwgaXMgbmVlZGVkIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL3pvbmUuanMvaXNzdWVzLzE5MFxuICAgICAgICBjb25zdCB0YXJnZXQgPSBjb250ZXh0IHx8IGV2ZW50LnRhcmdldCB8fCBfZ2xvYmFsO1xuICAgICAgICBjb25zdCB0YXNrcyA9IHRhcmdldFt6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudC50eXBlXVtpc0NhcHR1cmUgPyBUUlVFX1NUUiA6IEZBTFNFX1NUUl1dO1xuICAgICAgICBpZiAodGFza3MpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFtdO1xuICAgICAgICAgICAgLy8gaW52b2tlIGFsbCB0YXNrcyB3aGljaCBhdHRhY2hlZCB0byBjdXJyZW50IHRhcmdldCB3aXRoIGdpdmVuIGV2ZW50LnR5cGUgYW5kIGNhcHR1cmUgPSBmYWxzZVxuICAgICAgICAgICAgLy8gZm9yIHBlcmZvcm1hbmNlIGNvbmNlcm4sIGlmIHRhc2subGVuZ3RoID09PSAxLCBqdXN0IGludm9rZVxuICAgICAgICAgICAgaWYgKHRhc2tzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGludm9rZVRhc2sodGFza3NbMF0sIHRhcmdldCwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIGVyciAmJiBlcnJvcnMucHVzaChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvem9uZS5qcy9pc3N1ZXMvODM2XG4gICAgICAgICAgICAgICAgLy8gY29weSB0aGUgdGFza3MgYXJyYXkgYmVmb3JlIGludm9rZSwgdG8gYXZvaWRcbiAgICAgICAgICAgICAgICAvLyB0aGUgY2FsbGJhY2sgd2lsbCByZW1vdmUgaXRzZWxmIG9yIG90aGVyIGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgY29uc3QgY29weVRhc2tzID0gdGFza3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvcHlUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQgJiYgZXZlbnRbSU1NRURJQVRFX1BST1BBR0FUSU9OX1NZTUJPTF0gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGludm9rZVRhc2soY29weVRhc2tzW2ldLCB0YXJnZXQsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZXJyICYmIGVycm9ycy5wdXNoKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgdGhlcmUgaXMgb25seSBvbmUgZXJyb3IsIHdlIGRvbid0IG5lZWQgdG8gc2NoZWR1bGUgbWljcm9UYXNrXG4gICAgICAgICAgICAvLyB0byB0aHJvdyB0aGUgZXJyb3IuXG4gICAgICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXJyb3JzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IGVycm9yc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgYXBpLm5hdGl2ZVNjaGVkdWxlTWljcm9UYXNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGdsb2JhbCBzaGFyZWQgem9uZUF3YXJlQ2FsbGJhY2sgdG8gaGFuZGxlIGFsbCBldmVudCBjYWxsYmFjayB3aXRoIGNhcHR1cmUgPSBmYWxzZVxuICAgIGNvbnN0IGdsb2JhbFpvbmVBd2FyZUNhbGxiYWNrID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBnbG9iYWxDYWxsYmFjayh0aGlzLCBldmVudCwgZmFsc2UpO1xuICAgIH07XG4gICAgLy8gZ2xvYmFsIHNoYXJlZCB6b25lQXdhcmVDYWxsYmFjayB0byBoYW5kbGUgYWxsIGV2ZW50IGNhbGxiYWNrIHdpdGggY2FwdHVyZSA9IHRydWVcbiAgICBjb25zdCBnbG9iYWxab25lQXdhcmVDYXB0dXJlQ2FsbGJhY2sgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdsb2JhbENhbGxiYWNrKHRoaXMsIGV2ZW50LCB0cnVlKTtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHBhdGNoRXZlbnRUYXJnZXRNZXRob2RzKG9iaiwgcGF0Y2hPcHRpb25zKSB7XG4gICAgICAgIGlmICghb2JqKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVzZUdsb2JhbENhbGxiYWNrID0gdHJ1ZTtcbiAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudXNlRyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB1c2VHbG9iYWxDYWxsYmFjayA9IHBhdGNoT3B0aW9ucy51c2VHO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbGlkYXRlSGFuZGxlciA9IHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudmg7XG4gICAgICAgIGxldCBjaGVja0R1cGxpY2F0ZSA9IHRydWU7XG4gICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLmNoa0R1cCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjaGVja0R1cGxpY2F0ZSA9IHBhdGNoT3B0aW9ucy5jaGtEdXA7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldHVyblRhcmdldCA9IGZhbHNlO1xuICAgICAgICBpZiAocGF0Y2hPcHRpb25zICYmIHBhdGNoT3B0aW9ucy5ydCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm5UYXJnZXQgPSBwYXRjaE9wdGlvbnMucnQ7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHByb3RvID0gb2JqO1xuICAgICAgICB3aGlsZSAocHJvdG8gJiYgIXByb3RvLmhhc093blByb3BlcnR5KEFERF9FVkVOVF9MSVNURU5FUikpIHtcbiAgICAgICAgICAgIHByb3RvID0gT2JqZWN0R2V0UHJvdG90eXBlT2YocHJvdG8pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdG8gJiYgb2JqW0FERF9FVkVOVF9MSVNURU5FUl0pIHtcbiAgICAgICAgICAgIC8vIHNvbWVob3cgd2UgZGlkIG5vdCBmaW5kIGl0LCBidXQgd2UgY2FuIHNlZSBpdC4gVGhpcyBoYXBwZW5zIG9uIElFIGZvciBXaW5kb3cgcHJvcGVydGllcy5cbiAgICAgICAgICAgIHByb3RvID0gb2JqO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcHJvdG8pIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdG9bem9uZVN5bWJvbEFkZEV2ZW50TGlzdGVuZXJdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXZlbnROYW1lVG9TdHJpbmcgPSBwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLmV2ZW50TmFtZVRvU3RyaW5nO1xuICAgICAgICAvLyBhIHNoYXJlZCBnbG9iYWwgdGFza0RhdGEgdG8gcGFzcyBkYXRhIGZvciBzY2hlZHVsZUV2ZW50VGFza1xuICAgICAgICAvLyBzbyB3ZSBkbyBub3QgbmVlZCB0byBjcmVhdGUgYSBuZXcgb2JqZWN0IGp1c3QgZm9yIHBhc3Mgc29tZSBkYXRhXG4gICAgICAgIGNvbnN0IHRhc2tEYXRhID0ge307XG4gICAgICAgIGNvbnN0IG5hdGl2ZUFkZEV2ZW50TGlzdGVuZXIgPSBwcm90b1t6b25lU3ltYm9sQWRkRXZlbnRMaXN0ZW5lcl0gPSBwcm90b1tBRERfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICBjb25zdCBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyID0gcHJvdG9bem9uZVN5bWJvbChSRU1PVkVfRVZFTlRfTElTVEVORVIpXSA9XG4gICAgICAgICAgICBwcm90b1tSRU1PVkVfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICBjb25zdCBuYXRpdmVMaXN0ZW5lcnMgPSBwcm90b1t6b25lU3ltYm9sKExJU1RFTkVSU19FVkVOVF9MSVNURU5FUildID1cbiAgICAgICAgICAgIHByb3RvW0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGNvbnN0IG5hdGl2ZVJlbW92ZUFsbExpc3RlbmVycyA9IHByb3RvW3pvbmVTeW1ib2woUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVIpXSA9XG4gICAgICAgICAgICBwcm90b1tSRU1PVkVfQUxMX0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUl07XG4gICAgICAgIGxldCBuYXRpdmVQcmVwZW5kRXZlbnRMaXN0ZW5lcjtcbiAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMucHJlcGVuZCkge1xuICAgICAgICAgICAgbmF0aXZlUHJlcGVuZEV2ZW50TGlzdGVuZXIgPSBwcm90b1t6b25lU3ltYm9sKHBhdGNoT3B0aW9ucy5wcmVwZW5kKV0gPVxuICAgICAgICAgICAgICAgIHByb3RvW3BhdGNoT3B0aW9ucy5wcmVwZW5kXTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogVGhpcyB1dGlsIGZ1bmN0aW9uIHdpbGwgYnVpbGQgYW4gb3B0aW9uIG9iamVjdCB3aXRoIHBhc3NpdmUgb3B0aW9uXG4gICAgICAgICAqIHRvIGhhbmRsZSBhbGwgcG9zc2libGUgaW5wdXQgZnJvbSB0aGUgdXNlci5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGJ1aWxkRXZlbnRMaXN0ZW5lck9wdGlvbnMob3B0aW9ucywgcGFzc2l2ZSkge1xuICAgICAgICAgICAgaWYgKCFwYXNzaXZlU3VwcG9ydGVkICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgLy8gZG9lc24ndCBzdXBwb3J0IHBhc3NpdmUgYnV0IHVzZXIgd2FudCB0byBwYXNzIGFuIG9iamVjdCBhcyBvcHRpb25zLlxuICAgICAgICAgICAgICAgIC8vIHRoaXMgd2lsbCBub3Qgd29yayBvbiBzb21lIG9sZCBicm93c2VyLCBzbyB3ZSBqdXN0IHBhc3MgYSBib29sZWFuXG4gICAgICAgICAgICAgICAgLy8gYXMgdXNlQ2FwdHVyZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICByZXR1cm4gISFvcHRpb25zLmNhcHR1cmU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXBhc3NpdmVTdXBwb3J0ZWQgfHwgIXBhc3NpdmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgY2FwdHVyZTogb3B0aW9ucywgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgcGFzc2l2ZTogdHJ1ZSB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyAmJiBvcHRpb25zLnBhc3NpdmUgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucyksIHsgcGFzc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGN1c3RvbVNjaGVkdWxlR2xvYmFsID0gZnVuY3Rpb24gKHRhc2spIHtcbiAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGFscmVhZHkgYSB0YXNrIGZvciB0aGUgZXZlbnROYW1lICsgY2FwdHVyZSxcbiAgICAgICAgICAgIC8vIGp1c3QgcmV0dXJuLCBiZWNhdXNlIHdlIHVzZSB0aGUgc2hhcmVkIGdsb2JhbFpvbmVBd2FyZUNhbGxiYWNrIGhlcmUuXG4gICAgICAgICAgICBpZiAodGFza0RhdGEuaXNFeGlzdGluZykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVBZGRFdmVudExpc3RlbmVyLmNhbGwodGFza0RhdGEudGFyZ2V0LCB0YXNrRGF0YS5ldmVudE5hbWUsIHRhc2tEYXRhLmNhcHR1cmUgPyBnbG9iYWxab25lQXdhcmVDYXB0dXJlQ2FsbGJhY2sgOiBnbG9iYWxab25lQXdhcmVDYWxsYmFjaywgdGFza0RhdGEub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbUNhbmNlbEdsb2JhbCA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICAvLyBpZiB0YXNrIGlzIG5vdCBtYXJrZWQgYXMgaXNSZW1vdmVkLCB0aGlzIGNhbGwgaXMgZGlyZWN0bHlcbiAgICAgICAgICAgIC8vIGZyb20gWm9uZS5wcm90b3R5cGUuY2FuY2VsVGFzaywgd2Ugc2hvdWxkIHJlbW92ZSB0aGUgdGFza1xuICAgICAgICAgICAgLy8gZnJvbSB0YXNrc0xpc3Qgb2YgdGFyZ2V0IGZpcnN0XG4gICAgICAgICAgICBpZiAoIXRhc2suaXNSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sRXZlbnROYW1lcyA9IHpvbmVTeW1ib2xFdmVudE5hbWVzW3Rhc2suZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBsZXQgc3ltYm9sRXZlbnROYW1lO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xFdmVudE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN5bWJvbEV2ZW50TmFtZSA9IHN5bWJvbEV2ZW50TmFtZXNbdGFzay5jYXB0dXJlID8gVFJVRV9TVFIgOiBGQUxTRV9TVFJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2tzID0gc3ltYm9sRXZlbnROYW1lICYmIHRhc2sudGFyZ2V0W3N5bWJvbEV2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBleGlzdGluZ1Rhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2sgPSBleGlzdGluZ1Rhc2tzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGFzayA9PT0gdGFzaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFza3Muc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNldCBpc1JlbW92ZWQgdG8gZGF0YSBmb3IgZmFzdGVyIGludm9rZVRhc2sgY2hlY2tcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmlzUmVtb3ZlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGFza3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0YXNrcyBmb3IgdGhlIGV2ZW50TmFtZSArIGNhcHR1cmUgaGF2ZSBnb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgZ2xvYmFsWm9uZUF3YXJlQ2FsbGJhY2sgYW5kIHJlbW92ZSB0aGUgdGFzayBjYWNoZSBmcm9tIHRhcmdldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmFsbFJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLnRhcmdldFtzeW1ib2xFdmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBpZiBhbGwgdGFza3MgZm9yIHRoZSBldmVudE5hbWUgKyBjYXB0dXJlIGhhdmUgZ29uZSxcbiAgICAgICAgICAgIC8vIHdlIHdpbGwgcmVhbGx5IHJlbW92ZSB0aGUgZ2xvYmFsIGV2ZW50IGNhbGxiYWNrLFxuICAgICAgICAgICAgLy8gaWYgbm90LCByZXR1cm5cbiAgICAgICAgICAgIGlmICghdGFzay5hbGxSZW1vdmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0YXNrLnRhcmdldCwgdGFzay5ldmVudE5hbWUsIHRhc2suY2FwdHVyZSA/IGdsb2JhbFpvbmVBd2FyZUNhcHR1cmVDYWxsYmFjayA6IGdsb2JhbFpvbmVBd2FyZUNhbGxiYWNrLCB0YXNrLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjdXN0b21TY2hlZHVsZU5vbkdsb2JhbCA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlQWRkRXZlbnRMaXN0ZW5lci5jYWxsKHRhc2tEYXRhLnRhcmdldCwgdGFza0RhdGEuZXZlbnROYW1lLCB0YXNrLmludm9rZSwgdGFza0RhdGEub3B0aW9ucyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGN1c3RvbVNjaGVkdWxlUHJlcGVuZCA9IGZ1bmN0aW9uICh0YXNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUHJlcGVuZEV2ZW50TGlzdGVuZXIuY2FsbCh0YXNrRGF0YS50YXJnZXQsIHRhc2tEYXRhLmV2ZW50TmFtZSwgdGFzay5pbnZva2UsIHRhc2tEYXRhLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjdXN0b21DYW5jZWxOb25HbG9iYWwgPSBmdW5jdGlvbiAodGFzaykge1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuY2FsbCh0YXNrLnRhcmdldCwgdGFzay5ldmVudE5hbWUsIHRhc2suaW52b2tlLCB0YXNrLm9wdGlvbnMpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjdXN0b21TY2hlZHVsZSA9IHVzZUdsb2JhbENhbGxiYWNrID8gY3VzdG9tU2NoZWR1bGVHbG9iYWwgOiBjdXN0b21TY2hlZHVsZU5vbkdsb2JhbDtcbiAgICAgICAgY29uc3QgY3VzdG9tQ2FuY2VsID0gdXNlR2xvYmFsQ2FsbGJhY2sgPyBjdXN0b21DYW5jZWxHbG9iYWwgOiBjdXN0b21DYW5jZWxOb25HbG9iYWw7XG4gICAgICAgIGNvbnN0IGNvbXBhcmVUYXNrQ2FsbGJhY2tWc0RlbGVnYXRlID0gZnVuY3Rpb24gKHRhc2ssIGRlbGVnYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlT2ZEZWxlZ2F0ZSA9IHR5cGVvZiBkZWxlZ2F0ZTtcbiAgICAgICAgICAgIHJldHVybiAodHlwZU9mRGVsZWdhdGUgPT09ICdmdW5jdGlvbicgJiYgdGFzay5jYWxsYmFjayA9PT0gZGVsZWdhdGUpIHx8XG4gICAgICAgICAgICAgICAgKHR5cGVPZkRlbGVnYXRlID09PSAnb2JqZWN0JyAmJiB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgPT09IGRlbGVnYXRlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY29tcGFyZSA9IChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLmRpZmYpID8gcGF0Y2hPcHRpb25zLmRpZmYgOiBjb21wYXJlVGFza0NhbGxiYWNrVnNEZWxlZ2F0ZTtcbiAgICAgICAgY29uc3QgdW5wYXRjaGVkRXZlbnRzID0gWm9uZVt6b25lU3ltYm9sKCdVTlBBVENIRURfRVZFTlRTJyldO1xuICAgICAgICBjb25zdCBwYXNzaXZlRXZlbnRzID0gX2dsb2JhbFt6b25lU3ltYm9sKCdQQVNTSVZFX0VWRU5UUycpXTtcbiAgICAgICAgY29uc3QgbWFrZUFkZExpc3RlbmVyID0gZnVuY3Rpb24gKG5hdGl2ZUxpc3RlbmVyLCBhZGRTb3VyY2UsIGN1c3RvbVNjaGVkdWxlRm4sIGN1c3RvbUNhbmNlbEZuLCByZXR1cm5UYXJnZXQgPSBmYWxzZSwgcHJlcGVuZCA9IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMgfHwgX2dsb2JhbDtcbiAgICAgICAgICAgICAgICBsZXQgZXZlbnROYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgICAgIGlmIChwYXRjaE9wdGlvbnMgJiYgcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50TmFtZSA9IHBhdGNoT3B0aW9ucy50cmFuc2ZlckV2ZW50TmFtZShldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgZGVsZWdhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICAgICAgaWYgKCFkZWxlZ2F0ZSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmF0aXZlTGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzTm9kZSAmJiBldmVudE5hbWUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgcGF0Y2ggdW5jYXVnaHRFeGNlcHRpb24gb2Ygbm9kZWpzIHRvIHByZXZlbnQgZW5kbGVzcyBsb29wXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBkb24ndCBjcmVhdGUgdGhlIGJpbmQgZGVsZWdhdGUgZnVuY3Rpb24gZm9yIGhhbmRsZUV2ZW50XG4gICAgICAgICAgICAgICAgLy8gY2FzZSBoZXJlIHRvIGltcHJvdmUgYWRkRXZlbnRMaXN0ZW5lciBwZXJmb3JtYW5jZVxuICAgICAgICAgICAgICAgIC8vIHdlIHdpbGwgY3JlYXRlIHRoZSBiaW5kIGRlbGVnYXRlIHdoZW4gaW52b2tlXG4gICAgICAgICAgICAgICAgbGV0IGlzSGFuZGxlRXZlbnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRlbGVnYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVsZWdhdGUuaGFuZGxlRXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlzSGFuZGxlRXZlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVIYW5kbGVyICYmICF2YWxpZGF0ZUhhbmRsZXIobmF0aXZlTGlzdGVuZXIsIGRlbGVnYXRlLCB0YXJnZXQsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBwYXNzaXZlID0gcGFzc2l2ZVN1cHBvcnRlZCAmJiAhIXBhc3NpdmVFdmVudHMgJiYgcGFzc2l2ZUV2ZW50cy5pbmRleE9mKGV2ZW50TmFtZSkgIT09IC0xO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBidWlsZEV2ZW50TGlzdGVuZXJPcHRpb25zKGFyZ3VtZW50c1syXSwgcGFzc2l2ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHVucGF0Y2hlZEV2ZW50cykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayB1bnBhdGNoZWQgbGlzdFxuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVucGF0Y2hlZEV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gdW5wYXRjaGVkRXZlbnRzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhc3NpdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZUxpc3RlbmVyLmNhbGwodGFyZ2V0LCBldmVudE5hbWUsIGRlbGVnYXRlLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuYXRpdmVMaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gIW9wdGlvbnMgPyBmYWxzZSA6IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyB0cnVlIDogb3B0aW9ucy5jYXB0dXJlO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uY2UgPSBvcHRpb25zICYmIHR5cGVvZiBvcHRpb25zID09PSAnb2JqZWN0JyA/IG9wdGlvbnMub25jZSA6IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHpvbmUgPSBab25lLmN1cnJlbnQ7XG4gICAgICAgICAgICAgICAgbGV0IHN5bWJvbEV2ZW50TmFtZXMgPSB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICghc3ltYm9sRXZlbnROYW1lcykge1xuICAgICAgICAgICAgICAgICAgICBwcmVwYXJlRXZlbnROYW1lcyhldmVudE5hbWUsIGV2ZW50TmFtZVRvU3RyaW5nKTtcbiAgICAgICAgICAgICAgICAgICAgc3ltYm9sRXZlbnROYW1lcyA9IHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbEV2ZW50TmFtZSA9IHN5bWJvbEV2ZW50TmFtZXNbY2FwdHVyZSA/IFRSVUVfU1RSIDogRkFMU0VfU1RSXTtcbiAgICAgICAgICAgICAgICBsZXQgZXhpc3RpbmdUYXNrcyA9IHRhcmdldFtzeW1ib2xFdmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGxldCBpc0V4aXN0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKGV4aXN0aW5nVGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxyZWFkeSBoYXZlIHRhc2sgcmVnaXN0ZXJlZFxuICAgICAgICAgICAgICAgICAgICBpc0V4aXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrRHVwbGljYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV4aXN0aW5nVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShleGlzdGluZ1Rhc2tzW2ldLCBkZWxlZ2F0ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2FtZSBjYWxsYmFjaywgc2FtZSBjYXB0dXJlLCBzYW1lIGV2ZW50IG5hbWUsIGp1c3QgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFza3MgPSB0YXJnZXRbc3ltYm9sRXZlbnROYW1lXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgc291cmNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnN0cnVjdG9yTmFtZSA9IHRhcmdldC5jb25zdHJ1Y3RvclsnbmFtZSddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldFNvdXJjZSA9IGdsb2JhbFNvdXJjZXNbY29uc3RydWN0b3JOYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0U291cmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHRhcmdldFNvdXJjZVtldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIXNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBjb25zdHJ1Y3Rvck5hbWUgKyBhZGRTb3VyY2UgK1xuICAgICAgICAgICAgICAgICAgICAgICAgKGV2ZW50TmFtZVRvU3RyaW5nID8gZXZlbnROYW1lVG9TdHJpbmcoZXZlbnROYW1lKSA6IGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGRvIG5vdCBjcmVhdGUgYSBuZXcgb2JqZWN0IGFzIHRhc2suZGF0YSB0byBwYXNzIHRob3NlIHRoaW5nc1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgdXNlIHRoZSBnbG9iYWwgc2hhcmVkIG9uZVxuICAgICAgICAgICAgICAgIHRhc2tEYXRhLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICAgICAgICAgIGlmIChvbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGFkZEV2ZW50TGlzdGVuZXIgd2l0aCBvbmNlIG9wdGlvbnMsIHdlIGRvbid0IHBhc3MgaXQgdG9cbiAgICAgICAgICAgICAgICAgICAgLy8gbmF0aXZlIGFkZEV2ZW50TGlzdGVuZXIsIGluc3RlYWQgd2Uga2VlcCB0aGUgb25jZSBzZXR0aW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBoYW5kbGUgb3Vyc2VsdmVzLlxuICAgICAgICAgICAgICAgICAgICB0YXNrRGF0YS5vcHRpb25zLm9uY2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFza0RhdGEudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIHRhc2tEYXRhLmNhcHR1cmUgPSBjYXB0dXJlO1xuICAgICAgICAgICAgICAgIHRhc2tEYXRhLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgICAgICAgICB0YXNrRGF0YS5pc0V4aXN0aW5nID0gaXNFeGlzdGluZztcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gdXNlR2xvYmFsQ2FsbGJhY2sgPyBPUFRJTUlaRURfWk9ORV9FVkVOVF9UQVNLX0RBVEEgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgLy8ga2VlcCB0YXNrRGF0YSBpbnRvIGRhdGEgdG8gYWxsb3cgb25TY2hlZHVsZUV2ZW50VGFzayB0byBhY2Nlc3MgdGhlIHRhc2sgaW5mb3JtYXRpb25cbiAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhLnRhc2tEYXRhID0gdGFza0RhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSB6b25lLnNjaGVkdWxlRXZlbnRUYXNrKHNvdXJjZSwgZGVsZWdhdGUsIGRhdGEsIGN1c3RvbVNjaGVkdWxlRm4sIGN1c3RvbUNhbmNlbEZuKTtcbiAgICAgICAgICAgICAgICAvLyBzaG91bGQgY2xlYXIgdGFza0RhdGEudGFyZ2V0IHRvIGF2b2lkIG1lbW9yeSBsZWFrXG4gICAgICAgICAgICAgICAgLy8gaXNzdWUsIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzIwNDQyXG4gICAgICAgICAgICAgICAgdGFza0RhdGEudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIGNsZWFyIHVwIHRhc2tEYXRhIGJlY2F1c2UgaXQgaXMgYSBnbG9iYWwgb2JqZWN0XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YS50YXNrRGF0YSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGhhdmUgdG8gc2F2ZSB0aG9zZSBpbmZvcm1hdGlvbiB0byB0YXNrIGluIGNhc2VcbiAgICAgICAgICAgICAgICAvLyBhcHBsaWNhdGlvbiBtYXkgY2FsbCB0YXNrLnpvbmUuY2FuY2VsVGFzaygpIGRpcmVjdGx5XG4gICAgICAgICAgICAgICAgaWYgKG9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vbmNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEoIXBhc3NpdmVTdXBwb3J0ZWQgJiYgdHlwZW9mIHRhc2sub3B0aW9ucyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBpZiBub3Qgc3VwcG9ydCBwYXNzaXZlLCBhbmQgd2UgcGFzcyBhbiBvcHRpb24gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgIC8vIHRvIGFkZEV2ZW50TGlzdGVuZXIsIHdlIHNob3VsZCBzYXZlIHRoZSBvcHRpb25zIHRvIHRhc2tcbiAgICAgICAgICAgICAgICAgICAgdGFzay5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGFzay50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGFzay5jYXB0dXJlID0gY2FwdHVyZTtcbiAgICAgICAgICAgICAgICB0YXNrLmV2ZW50TmFtZSA9IGV2ZW50TmFtZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNIYW5kbGVFdmVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIG9yaWdpbmFsIGRlbGVnYXRlIGZvciBjb21wYXJlIHRvIGNoZWNrIGR1cGxpY2F0ZVxuICAgICAgICAgICAgICAgICAgICB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVwZW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFza3MudW5zaGlmdCh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJldHVyblRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvW0FERF9FVkVOVF9MSVNURU5FUl0gPSBtYWtlQWRkTGlzdGVuZXIobmF0aXZlQWRkRXZlbnRMaXN0ZW5lciwgQUREX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSwgY3VzdG9tU2NoZWR1bGUsIGN1c3RvbUNhbmNlbCwgcmV0dXJuVGFyZ2V0KTtcbiAgICAgICAgaWYgKG5hdGl2ZVByZXBlbmRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICBwcm90b1tQUkVQRU5EX0VWRU5UX0xJU1RFTkVSXSA9IG1ha2VBZGRMaXN0ZW5lcihuYXRpdmVQcmVwZW5kRXZlbnRMaXN0ZW5lciwgUFJFUEVORF9FVkVOVF9MSVNURU5FUl9TT1VSQ0UsIGN1c3RvbVNjaGVkdWxlUHJlcGVuZCwgY3VzdG9tQ2FuY2VsLCByZXR1cm5UYXJnZXQsIHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHByb3RvW1JFTU9WRV9FVkVOVF9MSVNURU5FUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzIHx8IF9nbG9iYWw7XG4gICAgICAgICAgICBsZXQgZXZlbnROYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlID0gIW9wdGlvbnMgPyBmYWxzZSA6IHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicgPyB0cnVlIDogb3B0aW9ucy5jYXB0dXJlO1xuICAgICAgICAgICAgY29uc3QgZGVsZWdhdGUgPSBhcmd1bWVudHNbMV07XG4gICAgICAgICAgICBpZiAoIWRlbGVnYXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWxpZGF0ZUhhbmRsZXIgJiZcbiAgICAgICAgICAgICAgICAhdmFsaWRhdGVIYW5kbGVyKG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIsIGRlbGVnYXRlLCB0YXJnZXQsIGFyZ3VtZW50cykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzeW1ib2xFdmVudE5hbWVzID0gem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgIGxldCBzeW1ib2xFdmVudE5hbWU7XG4gICAgICAgICAgICBpZiAoc3ltYm9sRXZlbnROYW1lcykge1xuICAgICAgICAgICAgICAgIHN5bWJvbEV2ZW50TmFtZSA9IHN5bWJvbEV2ZW50TmFtZXNbY2FwdHVyZSA/IFRSVUVfU1RSIDogRkFMU0VfU1RSXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nVGFza3MgPSBzeW1ib2xFdmVudE5hbWUgJiYgdGFyZ2V0W3N5bWJvbEV2ZW50TmFtZV07XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdUYXNrcykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhpc3RpbmdUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1Rhc2sgPSBleGlzdGluZ1Rhc2tzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tcGFyZShleGlzdGluZ1Rhc2ssIGRlbGVnYXRlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYXNrcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzZXQgaXNSZW1vdmVkIHRvIGRhdGEgZm9yIGZhc3RlciBpbnZva2VUYXNrIGNoZWNrXG4gICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1Rhc2suaXNSZW1vdmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1Rhc2tzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGFsbCB0YXNrcyBmb3IgdGhlIGV2ZW50TmFtZSArIGNhcHR1cmUgaGF2ZSBnb25lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBnbG9iYWxab25lQXdhcmVDYWxsYmFjayBhbmQgcmVtb3ZlIHRoZSB0YXNrIGNhY2hlIGZyb20gdGFyZ2V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdUYXNrLmFsbFJlbW92ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldFtzeW1ib2xFdmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiB0aGUgdGFyZ2V0LCB3ZSBoYXZlIGFuIGV2ZW50IGxpc3RlbmVyIHdoaWNoIGlzIGFkZGVkIGJ5IG9uX3Byb3BlcnR5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjaCBhcyB0YXJnZXQub25jbGljayA9IGZ1bmN0aW9uKCkge30sIHNvIHdlIG5lZWQgdG8gY2xlYXIgdGhpcyBpbnRlcm5hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHByb3BlcnR5IHRvbyBpZiBhbGwgZGVsZWdhdGVzIGFsbCByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudE5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9uUHJvcGVydHlTeW1ib2wgPSBaT05FX1NZTUJPTF9QUkVGSVggKyAnT05fUFJPUEVSVFknICsgZXZlbnROYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbb25Qcm9wZXJ0eVN5bWJvbF0gPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nVGFzay56b25lLmNhbmNlbFRhc2soZXhpc3RpbmdUYXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXR1cm5UYXJnZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaXNzdWUgOTMwLCBkaWRuJ3QgZmluZCB0aGUgZXZlbnQgbmFtZSBvciBjYWxsYmFja1xuICAgICAgICAgICAgLy8gZnJvbSB6b25lIGtlcHQgZXhpc3RpbmdUYXNrcywgdGhlIGNhbGxiYWNrIG1heWJlXG4gICAgICAgICAgICAvLyBhZGRlZCBvdXRzaWRlIG9mIHpvbmUsIHdlIG5lZWQgdG8gY2FsbCBuYXRpdmUgcmVtb3ZlRXZlbnRMaXN0ZW5lclxuICAgICAgICAgICAgLy8gdG8gdHJ5IHRvIHJlbW92ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSZW1vdmVFdmVudExpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICAgIHByb3RvW0xJU1RFTkVSU19FVkVOVF9MSVNURU5FUl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzIHx8IF9nbG9iYWw7XG4gICAgICAgICAgICBsZXQgZXZlbnROYW1lID0gYXJndW1lbnRzWzBdO1xuICAgICAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBldmVudE5hbWUgPSBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdGFza3MgPSBmaW5kRXZlbnRUYXNrcyh0YXJnZXQsIGV2ZW50TmFtZVRvU3RyaW5nID8gZXZlbnROYW1lVG9TdHJpbmcoZXZlbnROYW1lKSA6IGV2ZW50TmFtZSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHRhc2tzW2ldO1xuICAgICAgICAgICAgICAgIGxldCBkZWxlZ2F0ZSA9IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA/IHRhc2sub3JpZ2luYWxEZWxlZ2F0ZSA6IHRhc2suY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goZGVsZWdhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVycztcbiAgICAgICAgfTtcbiAgICAgICAgcHJvdG9bUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVJdID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcyB8fCBfZ2xvYmFsO1xuICAgICAgICAgICAgbGV0IGV2ZW50TmFtZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRhcmdldCk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IEVWRU5UX05BTUVfU1lNQk9MX1JFR1guZXhlYyhwcm9wKTtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV2dE5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaW4gbm9kZWpzIEV2ZW50RW1pdHRlciwgcmVtb3ZlTGlzdGVuZXIgZXZlbnQgaXNcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlZCBmb3IgbW9uaXRvcmluZyB0aGUgcmVtb3ZlTGlzdGVuZXIgY2FsbCxcbiAgICAgICAgICAgICAgICAgICAgLy8gc28ganVzdCBrZWVwIHJlbW92ZUxpc3RlbmVyIGV2ZW50TGlzdGVuZXIgdW50aWxcbiAgICAgICAgICAgICAgICAgICAgLy8gYWxsIG90aGVyIGV2ZW50TGlzdGVuZXJzIGFyZSByZW1vdmVkXG4gICAgICAgICAgICAgICAgICAgIGlmIChldnROYW1lICYmIGV2dE5hbWUgIT09ICdyZW1vdmVMaXN0ZW5lcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVJdLmNhbGwodGhpcywgZXZ0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gcmVtb3ZlIHJlbW92ZUxpc3RlbmVyIGxpc3RlbmVyIGZpbmFsbHlcbiAgICAgICAgICAgICAgICB0aGlzW1JFTU9WRV9BTExfTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSXS5jYWxsKHRoaXMsICdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGNoT3B0aW9ucyAmJiBwYXRjaE9wdGlvbnMudHJhbnNmZXJFdmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnROYW1lID0gcGF0Y2hPcHRpb25zLnRyYW5zZmVyRXZlbnROYW1lKGV2ZW50TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbEV2ZW50TmFtZXMgPSB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChzeW1ib2xFdmVudE5hbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN5bWJvbEV2ZW50TmFtZSA9IHN5bWJvbEV2ZW50TmFtZXNbRkFMU0VfU1RSXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ltYm9sQ2FwdHVyZUV2ZW50TmFtZSA9IHN5bWJvbEV2ZW50TmFtZXNbVFJVRV9TVFJdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrcyA9IHRhcmdldFtzeW1ib2xFdmVudE5hbWVdO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYXB0dXJlVGFza3MgPSB0YXJnZXRbc3ltYm9sQ2FwdHVyZUV2ZW50TmFtZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlVGFza3MgPSB0YXNrcy5zbGljZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW1vdmVUYXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSByZW1vdmVUYXNrc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgZGVsZWdhdGUgPSB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgPyB0YXNrLm9yaWdpbmFsRGVsZWdhdGUgOiB0YXNrLmNhbGxiYWNrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbUkVNT1ZFX0VWRU5UX0xJU1RFTkVSXS5jYWxsKHRoaXMsIGV2ZW50TmFtZSwgZGVsZWdhdGUsIHRhc2sub3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhcHR1cmVUYXNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVtb3ZlVGFza3MgPSBjYXB0dXJlVGFza3Muc2xpY2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVtb3ZlVGFza3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0YXNrID0gcmVtb3ZlVGFza3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGRlbGVnYXRlID0gdGFzay5vcmlnaW5hbERlbGVnYXRlID8gdGFzay5vcmlnaW5hbERlbGVnYXRlIDogdGFzay5jYWxsYmFjaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW1JFTU9WRV9FVkVOVF9MSVNURU5FUl0uY2FsbCh0aGlzLCBldmVudE5hbWUsIGRlbGVnYXRlLCB0YXNrLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldHVyblRhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBmb3IgbmF0aXZlIHRvU3RyaW5nIHBhdGNoXG4gICAgICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChwcm90b1tBRERfRVZFTlRfTElTVEVORVJdLCBuYXRpdmVBZGRFdmVudExpc3RlbmVyKTtcbiAgICAgICAgYXR0YWNoT3JpZ2luVG9QYXRjaGVkKHByb3RvW1JFTU9WRV9FVkVOVF9MSVNURU5FUl0sIG5hdGl2ZVJlbW92ZUV2ZW50TGlzdGVuZXIpO1xuICAgICAgICBpZiAobmF0aXZlUmVtb3ZlQWxsTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQocHJvdG9bUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVJdLCBuYXRpdmVSZW1vdmVBbGxMaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuYXRpdmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIGF0dGFjaE9yaWdpblRvUGF0Y2hlZChwcm90b1tMSVNURU5FUlNfRVZFTlRfTElTVEVORVJdLCBuYXRpdmVMaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXBpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHRzW2ldID0gcGF0Y2hFdmVudFRhcmdldE1ldGhvZHMoYXBpc1tpXSwgcGF0Y2hPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59XG5mdW5jdGlvbiBmaW5kRXZlbnRUYXNrcyh0YXJnZXQsIGV2ZW50TmFtZSkge1xuICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgIGNvbnN0IGZvdW5kVGFza3MgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiB0YXJnZXQpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gRVZFTlRfTkFNRV9TWU1CT0xfUkVHWC5leGVjKHByb3ApO1xuICAgICAgICAgICAgbGV0IGV2dE5hbWUgPSBtYXRjaCAmJiBtYXRjaFsxXTtcbiAgICAgICAgICAgIGlmIChldnROYW1lICYmICghZXZlbnROYW1lIHx8IGV2dE5hbWUgPT09IGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0YXNrcyA9IHRhcmdldFtwcm9wXTtcbiAgICAgICAgICAgICAgICBpZiAodGFza3MpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXNrcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm91bmRUYXNrcy5wdXNoKHRhc2tzW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZm91bmRUYXNrcztcbiAgICB9XG4gICAgbGV0IHN5bWJvbEV2ZW50TmFtZSA9IHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV07XG4gICAgaWYgKCFzeW1ib2xFdmVudE5hbWUpIHtcbiAgICAgICAgcHJlcGFyZUV2ZW50TmFtZXMoZXZlbnROYW1lKTtcbiAgICAgICAgc3ltYm9sRXZlbnROYW1lID0gem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXTtcbiAgICB9XG4gICAgY29uc3QgY2FwdHVyZUZhbHNlVGFza3MgPSB0YXJnZXRbc3ltYm9sRXZlbnROYW1lW0ZBTFNFX1NUUl1dO1xuICAgIGNvbnN0IGNhcHR1cmVUcnVlVGFza3MgPSB0YXJnZXRbc3ltYm9sRXZlbnROYW1lW1RSVUVfU1RSXV07XG4gICAgaWYgKCFjYXB0dXJlRmFsc2VUYXNrcykge1xuICAgICAgICByZXR1cm4gY2FwdHVyZVRydWVUYXNrcyA/IGNhcHR1cmVUcnVlVGFza3Muc2xpY2UoKSA6IFtdO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNhcHR1cmVUcnVlVGFza3MgPyBjYXB0dXJlRmFsc2VUYXNrcy5jb25jYXQoY2FwdHVyZVRydWVUYXNrcykgOlxuICAgICAgICAgICAgY2FwdHVyZUZhbHNlVGFza3Muc2xpY2UoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50UHJvdG90eXBlKGdsb2JhbCwgYXBpKSB7XG4gICAgY29uc3QgRXZlbnQgPSBnbG9iYWxbJ0V2ZW50J107XG4gICAgaWYgKEV2ZW50ICYmIEV2ZW50LnByb3RvdHlwZSkge1xuICAgICAgICBhcGkucGF0Y2hNZXRob2QoRXZlbnQucHJvdG90eXBlLCAnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJywgKGRlbGVnYXRlKSA9PiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgc2VsZltJTU1FRElBVEVfUFJPUEFHQVRJT05fU1lNQk9MXSA9IHRydWU7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGNhbGwgdGhlIG5hdGl2ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb25cbiAgICAgICAgICAgIC8vIGluIGNhc2UgaW4gc29tZSBoeWJyaWQgYXBwbGljYXRpb24sIHNvbWUgcGFydCBvZlxuICAgICAgICAgICAgLy8gYXBwbGljYXRpb24gd2lsbCBiZSBjb250cm9sbGVkIGJ5IHpvbmUsIHNvbWUgYXJlIG5vdFxuICAgICAgICAgICAgZGVsZWdhdGUgJiYgZGVsZWdhdGUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5mdW5jdGlvbiBwYXRjaENhbGxiYWNrcyhhcGksIHRhcmdldCwgdGFyZ2V0TmFtZSwgbWV0aG9kLCBjYWxsYmFja3MpIHtcbiAgICBjb25zdCBzeW1ib2wgPSBab25lLl9fc3ltYm9sX18obWV0aG9kKTtcbiAgICBpZiAodGFyZ2V0W3N5bWJvbF0pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBuYXRpdmVEZWxlZ2F0ZSA9IHRhcmdldFtzeW1ib2xdID0gdGFyZ2V0W21ldGhvZF07XG4gICAgdGFyZ2V0W21ldGhvZF0gPSBmdW5jdGlvbiAobmFtZSwgb3B0cywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0cyAmJiBvcHRzLnByb3RvdHlwZSkge1xuICAgICAgICAgICAgY2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc291cmNlID0gYCR7dGFyZ2V0TmFtZX0uJHttZXRob2R9OjpgICsgY2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG90eXBlID0gb3B0cy5wcm90b3R5cGU7XG4gICAgICAgICAgICAgICAgLy8gTm90ZTogdGhlIGBwYXRjaENhbGxiYWNrc2AgaXMgdXNlZCBmb3IgcGF0Y2hpbmcgdGhlIGBkb2N1bWVudC5yZWdpc3RlckVsZW1lbnRgIGFuZFxuICAgICAgICAgICAgICAgIC8vIGBjdXN0b21FbGVtZW50cy5kZWZpbmVgLiBXZSBleHBsaWNpdGx5IHdyYXAgdGhlIHBhdGNoaW5nIGNvZGUgaW50byB0cnktY2F0Y2ggc2luY2VcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFja3MgbWF5IGJlIGFscmVhZHkgcGF0Y2hlZCBieSBvdGhlciB3ZWIgY29tcG9uZW50cyBmcmFtZXdvcmtzIChlLmcuIExXQyksIGFuZCB0aGV5XG4gICAgICAgICAgICAgICAgLy8gbWFrZSB0aG9zZSBwcm9wZXJ0aWVzIG5vbi13cml0YWJsZS4gVGhpcyBtZWFucyB0aGF0IHBhdGNoaW5nIGNhbGxiYWNrIHdpbGwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICAvLyBgY2Fubm90IGFzc2lnbiB0byByZWFkLW9ubHkgcHJvcGVydHlgLiBTZWUgdGhpcyBjb2RlIGFzIGFuIGV4YW1wbGU6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhbGVzZm9yY2UvbHdjL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL0Bsd2MvZW5naW5lLWNvcmUvc3JjL2ZyYW1ld29yay9iYXNlLWJyaWRnZS1lbGVtZW50LnRzI0wxODAtTDE4NlxuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gc3RvcCB0aGUgYXBwbGljYXRpb24gcmVuZGVyaW5nIGlmIHdlIGNvdWxkbid0IHBhdGNoIHNvbWVcbiAgICAgICAgICAgICAgICAvLyBjYWxsYmFjaywgZS5nLiBgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrYC5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvdG90eXBlLmhhc093blByb3BlcnR5KGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVzY3JpcHRvciA9IGFwaS5PYmplY3RHZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IocHJvdG90eXBlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGFwaS53cmFwV2l0aEN1cnJlbnRab25lKGRlc2NyaXB0b3IudmFsdWUsIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLl9yZWRlZmluZVByb3BlcnR5KG9wdHMucHJvdG90eXBlLCBjYWxsYmFjaywgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChwcm90b3R5cGVbY2FsbGJhY2tdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2NhbGxiYWNrXSA9IGFwaS53cmFwV2l0aEN1cnJlbnRab25lKHByb3RvdHlwZVtjYWxsYmFja10sIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAocHJvdG90eXBlW2NhbGxiYWNrXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdG90eXBlW2NhbGxiYWNrXSA9IGFwaS53cmFwV2l0aEN1cnJlbnRab25lKHByb3RvdHlwZVtjYWxsYmFja10sIHNvdXJjZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdGU6IHdlIGxlYXZlIHRoZSBjYXRjaCBibG9jayBlbXB0eSBzaW5jZSB0aGVyZSdzIG5vIHdheSB0byBoYW5kbGUgdGhlIGVycm9yIHJlbGF0ZWRcbiAgICAgICAgICAgICAgICAgICAgLy8gdG8gbm9uLXdyaXRhYmxlIHByb3BlcnR5LlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuYXRpdmVEZWxlZ2F0ZS5jYWxsKHRhcmdldCwgbmFtZSwgb3B0cywgb3B0aW9ucyk7XG4gICAgfTtcbiAgICBhcGkuYXR0YWNoT3JpZ2luVG9QYXRjaGVkKHRhcmdldFttZXRob2RdLCBuYXRpdmVEZWxlZ2F0ZSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBHb29nbGUgTExDIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXQgaHR0cHM6Ly9hbmd1bGFyLmlvL2xpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gZmlsdGVyUHJvcGVydGllcyh0YXJnZXQsIG9uUHJvcGVydGllcywgaWdub3JlUHJvcGVydGllcykge1xuICAgIGlmICghaWdub3JlUHJvcGVydGllcyB8fCBpZ25vcmVQcm9wZXJ0aWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb25Qcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBjb25zdCB0aXAgPSBpZ25vcmVQcm9wZXJ0aWVzLmZpbHRlcihpcCA9PiBpcC50YXJnZXQgPT09IHRhcmdldCk7XG4gICAgaWYgKCF0aXAgfHwgdGlwLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gb25Qcm9wZXJ0aWVzO1xuICAgIH1cbiAgICBjb25zdCB0YXJnZXRJZ25vcmVQcm9wZXJ0aWVzID0gdGlwWzBdLmlnbm9yZVByb3BlcnRpZXM7XG4gICAgcmV0dXJuIG9uUHJvcGVydGllcy5maWx0ZXIob3AgPT4gdGFyZ2V0SWdub3JlUHJvcGVydGllcy5pbmRleE9mKG9wKSA9PT0gLTEpO1xufVxuZnVuY3Rpb24gcGF0Y2hGaWx0ZXJlZFByb3BlcnRpZXModGFyZ2V0LCBvblByb3BlcnRpZXMsIGlnbm9yZVByb3BlcnRpZXMsIHByb3RvdHlwZSkge1xuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGFyZ2V0IGlzIGF2YWlsYWJsZSwgc29tZXRpbWVzIHRhcmdldCB3aWxsIGJlIHVuZGVmaW5lZFxuICAgIC8vIGJlY2F1c2UgZGlmZmVyZW50IGJyb3dzZXIgb3Igc29tZSAzcmQgcGFydHkgcGx1Z2luLlxuICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZmlsdGVyZWRQcm9wZXJ0aWVzID0gZmlsdGVyUHJvcGVydGllcyh0YXJnZXQsIG9uUHJvcGVydGllcywgaWdub3JlUHJvcGVydGllcyk7XG4gICAgcGF0Y2hPblByb3BlcnRpZXModGFyZ2V0LCBmaWx0ZXJlZFByb3BlcnRpZXMsIHByb3RvdHlwZSk7XG59XG4vKipcbiAqIEdldCBhbGwgZXZlbnQgbmFtZSBwcm9wZXJ0aWVzIHdoaWNoIHRoZSBldmVudCBuYW1lIHN0YXJ0c1dpdGggYG9uYFxuICogZnJvbSB0aGUgdGFyZ2V0IG9iamVjdCBpdHNlbGYsIGluaGVyaXRlZCBwcm9wZXJ0aWVzIGFyZSBub3QgY29uc2lkZXJlZC5cbiAqL1xuZnVuY3Rpb24gZ2V0T25FdmVudE5hbWVzKHRhcmdldCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0YXJnZXQpXG4gICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLnN0YXJ0c1dpdGgoJ29uJykgJiYgbmFtZS5sZW5ndGggPiAyKVxuICAgICAgICAubWFwKG5hbWUgPT4gbmFtZS5zdWJzdHJpbmcoMikpO1xufVxuZnVuY3Rpb24gcHJvcGVydHlEZXNjcmlwdG9yUGF0Y2goYXBpLCBfZ2xvYmFsKSB7XG4gICAgaWYgKGlzTm9kZSAmJiAhaXNNaXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoWm9uZVthcGkuc3ltYm9sKCdwYXRjaEV2ZW50cycpXSkge1xuICAgICAgICAvLyBldmVudHMgYXJlIGFscmVhZHkgYmVlbiBwYXRjaGVkIGJ5IGxlZ2FjeSBwYXRjaC5cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpZ25vcmVQcm9wZXJ0aWVzID0gX2dsb2JhbFsnX19ab25lX2lnbm9yZV9vbl9wcm9wZXJ0aWVzJ107XG4gICAgLy8gZm9yIGJyb3dzZXJzIHRoYXQgd2UgY2FuIHBhdGNoIHRoZSBkZXNjcmlwdG9yOiAgQ2hyb21lICYgRmlyZWZveFxuICAgIGxldCBwYXRjaFRhcmdldHMgPSBbXTtcbiAgICBpZiAoaXNCcm93c2VyKSB7XG4gICAgICAgIGNvbnN0IGludGVybmFsV2luZG93ID0gd2luZG93O1xuICAgICAgICBwYXRjaFRhcmdldHMgPSBwYXRjaFRhcmdldHMuY29uY2F0KFtcbiAgICAgICAgICAgICdEb2N1bWVudCcsICdTVkdFbGVtZW50JywgJ0VsZW1lbnQnLCAnSFRNTEVsZW1lbnQnLCAnSFRNTEJvZHlFbGVtZW50JywgJ0hUTUxNZWRpYUVsZW1lbnQnLFxuICAgICAgICAgICAgJ0hUTUxGcmFtZVNldEVsZW1lbnQnLCAnSFRNTEZyYW1lRWxlbWVudCcsICdIVE1MSUZyYW1lRWxlbWVudCcsICdIVE1MTWFycXVlZUVsZW1lbnQnLCAnV29ya2VyJ1xuICAgICAgICBdKTtcbiAgICAgICAgY29uc3QgaWdub3JlRXJyb3JQcm9wZXJ0aWVzID0gaXNJRSgpID8gW3sgdGFyZ2V0OiBpbnRlcm5hbFdpbmRvdywgaWdub3JlUHJvcGVydGllczogWydlcnJvciddIH1dIDogW107XG4gICAgICAgIC8vIGluIElFL0VkZ2UsIG9uUHJvcCBub3QgZXhpc3QgaW4gd2luZG93IG9iamVjdCwgYnV0IGluIFdpbmRvd1Byb3RvdHlwZVxuICAgICAgICAvLyBzbyB3ZSBuZWVkIHRvIHBhc3MgV2luZG93UHJvdG90eXBlIHRvIGNoZWNrIG9uUHJvcCBleGlzdCBvciBub3RcbiAgICAgICAgcGF0Y2hGaWx0ZXJlZFByb3BlcnRpZXMoaW50ZXJuYWxXaW5kb3csIGdldE9uRXZlbnROYW1lcyhpbnRlcm5hbFdpbmRvdyksIGlnbm9yZVByb3BlcnRpZXMgPyBpZ25vcmVQcm9wZXJ0aWVzLmNvbmNhdChpZ25vcmVFcnJvclByb3BlcnRpZXMpIDogaWdub3JlUHJvcGVydGllcywgT2JqZWN0R2V0UHJvdG90eXBlT2YoaW50ZXJuYWxXaW5kb3cpKTtcbiAgICB9XG4gICAgcGF0Y2hUYXJnZXRzID0gcGF0Y2hUYXJnZXRzLmNvbmNhdChbXG4gICAgICAgICdYTUxIdHRwUmVxdWVzdCcsICdYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0JywgJ0lEQkluZGV4JywgJ0lEQlJlcXVlc3QnLCAnSURCT3BlbkRCUmVxdWVzdCcsXG4gICAgICAgICdJREJEYXRhYmFzZScsICdJREJUcmFuc2FjdGlvbicsICdJREJDdXJzb3InLCAnV2ViU29ja2V0J1xuICAgIF0pO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGF0Y2hUYXJnZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldCA9IF9nbG9iYWxbcGF0Y2hUYXJnZXRzW2ldXTtcbiAgICAgICAgdGFyZ2V0ICYmIHRhcmdldC5wcm90b3R5cGUgJiZcbiAgICAgICAgICAgIHBhdGNoRmlsdGVyZWRQcm9wZXJ0aWVzKHRhcmdldC5wcm90b3R5cGUsIGdldE9uRXZlbnROYW1lcyh0YXJnZXQucHJvdG90eXBlKSwgaWdub3JlUHJvcGVydGllcyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblpvbmUuX19sb2FkX3BhdGNoKCd1dGlsJywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgLy8gQ29sbGVjdCBuYXRpdmUgZXZlbnQgbmFtZXMgYnkgbG9va2luZyBhdCBwcm9wZXJ0aWVzXG4gICAgLy8gb24gdGhlIGdsb2JhbCBuYW1lc3BhY2UsIGUuZy4gJ29uY2xpY2snLlxuICAgIGNvbnN0IGV2ZW50TmFtZXMgPSBnZXRPbkV2ZW50TmFtZXMoZ2xvYmFsKTtcbiAgICBhcGkucGF0Y2hPblByb3BlcnRpZXMgPSBwYXRjaE9uUHJvcGVydGllcztcbiAgICBhcGkucGF0Y2hNZXRob2QgPSBwYXRjaE1ldGhvZDtcbiAgICBhcGkuYmluZEFyZ3VtZW50cyA9IGJpbmRBcmd1bWVudHM7XG4gICAgYXBpLnBhdGNoTWFjcm9UYXNrID0gcGF0Y2hNYWNyb1Rhc2s7XG4gICAgLy8gSW4gZWFybGllciB2ZXJzaW9uIG9mIHpvbmUuanMgKDwwLjkuMCksIHdlIHVzZSBlbnYgbmFtZSBgX196b25lX3N5bWJvbF9fQkxBQ0tfTElTVEVEX0VWRU5UU2AgdG9cbiAgICAvLyBkZWZpbmUgd2hpY2ggZXZlbnRzIHdpbGwgbm90IGJlIHBhdGNoZWQgYnkgYFpvbmUuanNgLlxuICAgIC8vIEluIG5ld2VyIHZlcnNpb24gKD49MC45LjApLCB3ZSBjaGFuZ2UgdGhlIGVudiBuYW1lIHRvIGBfX3pvbmVfc3ltYm9sX19VTlBBVENIRURfRVZFTlRTYCB0byBrZWVwXG4gICAgLy8gdGhlIG5hbWUgY29uc2lzdGVudCB3aXRoIGFuZ3VsYXIgcmVwby5cbiAgICAvLyBUaGUgIGBfX3pvbmVfc3ltYm9sX19CTEFDS19MSVNURURfRVZFTlRTYCBpcyBkZXByZWNhdGVkLCBidXQgaXQgaXMgc3RpbGwgYmUgc3VwcG9ydGVkIGZvclxuICAgIC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICAgIGNvbnN0IFNZTUJPTF9CTEFDS19MSVNURURfRVZFTlRTID0gWm9uZS5fX3N5bWJvbF9fKCdCTEFDS19MSVNURURfRVZFTlRTJyk7XG4gICAgY29uc3QgU1lNQk9MX1VOUEFUQ0hFRF9FVkVOVFMgPSBab25lLl9fc3ltYm9sX18oJ1VOUEFUQ0hFRF9FVkVOVFMnKTtcbiAgICBpZiAoZ2xvYmFsW1NZTUJPTF9VTlBBVENIRURfRVZFTlRTXSkge1xuICAgICAgICBnbG9iYWxbU1lNQk9MX0JMQUNLX0xJU1RFRF9FVkVOVFNdID0gZ2xvYmFsW1NZTUJPTF9VTlBBVENIRURfRVZFTlRTXTtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFtTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UU10pIHtcbiAgICAgICAgWm9uZVtTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UU10gPSBab25lW1NZTUJPTF9VTlBBVENIRURfRVZFTlRTXSA9XG4gICAgICAgICAgICBnbG9iYWxbU1lNQk9MX0JMQUNLX0xJU1RFRF9FVkVOVFNdO1xuICAgIH1cbiAgICBhcGkucGF0Y2hFdmVudFByb3RvdHlwZSA9IHBhdGNoRXZlbnRQcm90b3R5cGU7XG4gICAgYXBpLnBhdGNoRXZlbnRUYXJnZXQgPSBwYXRjaEV2ZW50VGFyZ2V0O1xuICAgIGFwaS5pc0lFT3JFZGdlID0gaXNJRU9yRWRnZTtcbiAgICBhcGkuT2JqZWN0RGVmaW5lUHJvcGVydHkgPSBPYmplY3REZWZpbmVQcm9wZXJ0eTtcbiAgICBhcGkuT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0R2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuICAgIGFwaS5PYmplY3RDcmVhdGUgPSBPYmplY3RDcmVhdGU7XG4gICAgYXBpLkFycmF5U2xpY2UgPSBBcnJheVNsaWNlO1xuICAgIGFwaS5wYXRjaENsYXNzID0gcGF0Y2hDbGFzcztcbiAgICBhcGkud3JhcFdpdGhDdXJyZW50Wm9uZSA9IHdyYXBXaXRoQ3VycmVudFpvbmU7XG4gICAgYXBpLmZpbHRlclByb3BlcnRpZXMgPSBmaWx0ZXJQcm9wZXJ0aWVzO1xuICAgIGFwaS5hdHRhY2hPcmlnaW5Ub1BhdGNoZWQgPSBhdHRhY2hPcmlnaW5Ub1BhdGNoZWQ7XG4gICAgYXBpLl9yZWRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xuICAgIGFwaS5wYXRjaENhbGxiYWNrcyA9IHBhdGNoQ2FsbGJhY2tzO1xuICAgIGFwaS5nZXRHbG9iYWxPYmplY3RzID0gKCkgPT4gKHtcbiAgICAgICAgZ2xvYmFsU291cmNlcyxcbiAgICAgICAgem9uZVN5bWJvbEV2ZW50TmFtZXMsXG4gICAgICAgIGV2ZW50TmFtZXMsXG4gICAgICAgIGlzQnJvd3NlcixcbiAgICAgICAgaXNNaXgsXG4gICAgICAgIGlzTm9kZSxcbiAgICAgICAgVFJVRV9TVFIsXG4gICAgICAgIEZBTFNFX1NUUixcbiAgICAgICAgWk9ORV9TWU1CT0xfUFJFRklYLFxuICAgICAgICBBRERfRVZFTlRfTElTVEVORVJfU1RSLFxuICAgICAgICBSRU1PVkVfRVZFTlRfTElTVEVORVJfU1RSXG4gICAgfSk7XG59KTtcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEdvb2dsZSBMTEMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL2FuZ3VsYXIuaW8vbGljZW5zZVxuICovXG5jb25zdCB0YXNrU3ltYm9sID0gem9uZVN5bWJvbCgnem9uZVRhc2snKTtcbmZ1bmN0aW9uIHBhdGNoVGltZXIod2luZG93LCBzZXROYW1lLCBjYW5jZWxOYW1lLCBuYW1lU3VmZml4KSB7XG4gICAgbGV0IHNldE5hdGl2ZSA9IG51bGw7XG4gICAgbGV0IGNsZWFyTmF0aXZlID0gbnVsbDtcbiAgICBzZXROYW1lICs9IG5hbWVTdWZmaXg7XG4gICAgY2FuY2VsTmFtZSArPSBuYW1lU3VmZml4O1xuICAgIGNvbnN0IHRhc2tzQnlIYW5kbGVJZCA9IHt9O1xuICAgIGZ1bmN0aW9uIHNjaGVkdWxlVGFzayh0YXNrKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0YXNrLmRhdGE7XG4gICAgICAgIGRhdGEuYXJnc1swXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0YXNrLmludm9rZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgICBkYXRhLmhhbmRsZUlkID0gc2V0TmF0aXZlLmFwcGx5KHdpbmRvdywgZGF0YS5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyVGFzayh0YXNrKSB7XG4gICAgICAgIHJldHVybiBjbGVhck5hdGl2ZS5jYWxsKHdpbmRvdywgdGFzay5kYXRhLmhhbmRsZUlkKTtcbiAgICB9XG4gICAgc2V0TmF0aXZlID1cbiAgICAgICAgcGF0Y2hNZXRob2Qod2luZG93LCBzZXROYW1lLCAoZGVsZWdhdGUpID0+IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICBpc1BlcmlvZGljOiBuYW1lU3VmZml4ID09PSAnSW50ZXJ2YWwnLFxuICAgICAgICAgICAgICAgICAgICBkZWxheTogKG5hbWVTdWZmaXggPT09ICdUaW1lb3V0JyB8fCBuYW1lU3VmZml4ID09PSAnSW50ZXJ2YWwnKSA/IGFyZ3NbMV0gfHwgMCA6XG4gICAgICAgICAgICAgICAgICAgICAgICB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IGFyZ3NcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gYXJnc1swXTtcbiAgICAgICAgICAgICAgICBhcmdzWzBdID0gZnVuY3Rpb24gdGltZXIoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlzc3VlLTkzNCwgdGFzayB3aWxsIGJlIGNhbmNlbGxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXZlbiBpdCBpcyBhIHBlcmlvZGljIHRhc2sgc3VjaCBhc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0SW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzQwMzg3XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDbGVhbnVwIHRhc2tzQnlIYW5kbGVJZCBzaG91bGQgYmUgaGFuZGxlZCBiZWZvcmUgc2NoZWR1bGVUYXNrXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTaW5jZSBzb21lIHpvbmVTcGVjIG1heSBpbnRlcmNlcHQgYW5kIGRvZXNuJ3QgdHJpZ2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2NoZWR1bGVGbihzY2hlZHVsZVRhc2spIHByb3ZpZGVkIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShvcHRpb25zLmlzUGVyaW9kaWMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmhhbmRsZUlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpbiBub24tbm9kZWpzIGVudiwgd2UgcmVtb3ZlIHRpbWVySWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZnJvbSBsb2NhbCBjYWNoZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZUlkW29wdGlvbnMuaGFuZGxlSWRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhhbmRsZUlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vZGUgcmV0dXJucyBjb21wbGV4IG9iamVjdHMgYXMgaGFuZGxlSWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIHJlbW92ZSB0YXNrIHJlZmVyZW5jZSBmcm9tIHRpbWVyIG9iamVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmhhbmRsZUlkW3Rhc2tTeW1ib2xdID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBzY2hlZHVsZU1hY3JvVGFza1dpdGhDdXJyZW50Wm9uZShzZXROYW1lLCBhcmdzWzBdLCBvcHRpb25zLCBzY2hlZHVsZVRhc2ssIGNsZWFyVGFzayk7XG4gICAgICAgICAgICAgICAgaWYgKCF0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0YXNrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb2RlLmpzIG11c3QgYWRkaXRpb25hbGx5IHN1cHBvcnQgdGhlIHJlZiBhbmQgdW5yZWYgZnVuY3Rpb25zLlxuICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZSA9IHRhc2suZGF0YS5oYW5kbGVJZDtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGhhbmRsZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yIG5vbiBub2RlanMgZW52LCB3ZSBzYXZlIGhhbmRsZUlkOiB0YXNrXG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcHBpbmcgaW4gbG9jYWwgY2FjaGUgZm9yIGNsZWFyVGltZW91dFxuICAgICAgICAgICAgICAgICAgICB0YXNrc0J5SGFuZGxlSWRbaGFuZGxlXSA9IHRhc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGhhbmRsZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3Igbm9kZWpzIGVudiwgd2Ugc2F2ZSB0YXNrXG4gICAgICAgICAgICAgICAgICAgIC8vIHJlZmVyZW5jZSBpbiB0aW1lcklkIE9iamVjdCBmb3IgY2xlYXJUaW1lb3V0XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZVt0YXNrU3ltYm9sXSA9IHRhc2s7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgaGFuZGxlIGlzIG51bGwsIGJlY2F1c2Ugc29tZSBwb2x5ZmlsbCBvciBicm93c2VyXG4gICAgICAgICAgICAgICAgLy8gbWF5IHJldHVybiB1bmRlZmluZWQgZnJvbSBzZXRUaW1lb3V0L3NldEludGVydmFsL3NldEltbWVkaWF0ZS9yZXF1ZXN0QW5pbWF0aW9uRnJhbWVcbiAgICAgICAgICAgICAgICBpZiAoaGFuZGxlICYmIGhhbmRsZS5yZWYgJiYgaGFuZGxlLnVucmVmICYmIHR5cGVvZiBoYW5kbGUucmVmID09PSAnZnVuY3Rpb24nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBoYW5kbGUudW5yZWYgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGFzay5yZWYgPSBoYW5kbGUucmVmLmJpbmQoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgdGFzay51bnJlZiA9IGhhbmRsZS51bnJlZi5iaW5kKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaGFuZGxlID09PSAnbnVtYmVyJyB8fCBoYW5kbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciBieSBjYWxsaW5nIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJldHVybiBkZWxlZ2F0ZS5hcHBseSh3aW5kb3csIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICBjbGVhck5hdGl2ZSA9XG4gICAgICAgIHBhdGNoTWV0aG9kKHdpbmRvdywgY2FuY2VsTmFtZSwgKGRlbGVnYXRlKSA9PiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgY29uc3QgaWQgPSBhcmdzWzBdO1xuICAgICAgICAgICAgbGV0IHRhc2s7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGlkID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgIC8vIG5vbiBub2RlanMgZW52LlxuICAgICAgICAgICAgICAgIHRhc2sgPSB0YXNrc0J5SGFuZGxlSWRbaWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9kZWpzIGVudi5cbiAgICAgICAgICAgICAgICB0YXNrID0gaWQgJiYgaWRbdGFza1N5bWJvbF07XG4gICAgICAgICAgICAgICAgLy8gb3RoZXIgZW52aXJvbm1lbnRzLlxuICAgICAgICAgICAgICAgIGlmICghdGFzaykge1xuICAgICAgICAgICAgICAgICAgICB0YXNrID0gaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRhc2sgJiYgdHlwZW9mIHRhc2sudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFzay5zdGF0ZSAhPT0gJ25vdFNjaGVkdWxlZCcgJiZcbiAgICAgICAgICAgICAgICAgICAgKHRhc2suY2FuY2VsRm4gJiYgdGFzay5kYXRhLmlzUGVyaW9kaWMgfHwgdGFzay5ydW5Db3VudCA9PT0gMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpZCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlSWRbaWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZFt0YXNrU3ltYm9sXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90IGNhbmNlbCBhbHJlYWR5IGNhbmNlbGVkIGZ1bmN0aW9uc1xuICAgICAgICAgICAgICAgICAgICB0YXNrLnpvbmUuY2FuY2VsVGFzayh0YXNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBjYXVzZSBhbiBlcnJvciBieSBjYWxsaW5nIGl0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIGRlbGVnYXRlLmFwcGx5KHdpbmRvdywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIHBhdGNoQ3VzdG9tRWxlbWVudHMoX2dsb2JhbCwgYXBpKSB7XG4gICAgY29uc3QgeyBpc0Jyb3dzZXIsIGlzTWl4IH0gPSBhcGkuZ2V0R2xvYmFsT2JqZWN0cygpO1xuICAgIGlmICgoIWlzQnJvd3NlciAmJiAhaXNNaXgpIHx8ICFfZ2xvYmFsWydjdXN0b21FbGVtZW50cyddIHx8ICEoJ2N1c3RvbUVsZW1lbnRzJyBpbiBfZ2xvYmFsKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNhbGxiYWNrcyA9IFsnY29ubmVjdGVkQ2FsbGJhY2snLCAnZGlzY29ubmVjdGVkQ2FsbGJhY2snLCAnYWRvcHRlZENhbGxiYWNrJywgJ2F0dHJpYnV0ZUNoYW5nZWRDYWxsYmFjayddO1xuICAgIGFwaS5wYXRjaENhbGxiYWNrcyhhcGksIF9nbG9iYWwuY3VzdG9tRWxlbWVudHMsICdjdXN0b21FbGVtZW50cycsICdkZWZpbmUnLCBjYWxsYmFja3MpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0UGF0Y2goX2dsb2JhbCwgYXBpKSB7XG4gICAgaWYgKFpvbmVbYXBpLnN5bWJvbCgncGF0Y2hFdmVudFRhcmdldCcpXSkge1xuICAgICAgICAvLyBFdmVudFRhcmdldCBpcyBhbHJlYWR5IHBhdGNoZWQuXG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgeyBldmVudE5hbWVzLCB6b25lU3ltYm9sRXZlbnROYW1lcywgVFJVRV9TVFIsIEZBTFNFX1NUUiwgWk9ORV9TWU1CT0xfUFJFRklYIH0gPSBhcGkuZ2V0R2xvYmFsT2JqZWN0cygpO1xuICAgIC8vICBwcmVkZWZpbmUgYWxsIF9fem9uZV9zeW1ib2xfXyArIGV2ZW50TmFtZSArIHRydWUvZmFsc2Ugc3RyaW5nXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldmVudE5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50TmFtZSA9IGV2ZW50TmFtZXNbaV07XG4gICAgICAgIGNvbnN0IGZhbHNlRXZlbnROYW1lID0gZXZlbnROYW1lICsgRkFMU0VfU1RSO1xuICAgICAgICBjb25zdCB0cnVlRXZlbnROYW1lID0gZXZlbnROYW1lICsgVFJVRV9TVFI7XG4gICAgICAgIGNvbnN0IHN5bWJvbCA9IFpPTkVfU1lNQk9MX1BSRUZJWCArIGZhbHNlRXZlbnROYW1lO1xuICAgICAgICBjb25zdCBzeW1ib2xDYXB0dXJlID0gWk9ORV9TWU1CT0xfUFJFRklYICsgdHJ1ZUV2ZW50TmFtZTtcbiAgICAgICAgem9uZVN5bWJvbEV2ZW50TmFtZXNbZXZlbnROYW1lXSA9IHt9O1xuICAgICAgICB6b25lU3ltYm9sRXZlbnROYW1lc1tldmVudE5hbWVdW0ZBTFNFX1NUUl0gPSBzeW1ib2w7XG4gICAgICAgIHpvbmVTeW1ib2xFdmVudE5hbWVzW2V2ZW50TmFtZV1bVFJVRV9TVFJdID0gc3ltYm9sQ2FwdHVyZTtcbiAgICB9XG4gICAgY29uc3QgRVZFTlRfVEFSR0VUID0gX2dsb2JhbFsnRXZlbnRUYXJnZXQnXTtcbiAgICBpZiAoIUVWRU5UX1RBUkdFVCB8fCAhRVZFTlRfVEFSR0VULnByb3RvdHlwZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGFwaS5wYXRjaEV2ZW50VGFyZ2V0KF9nbG9iYWwsIGFwaSwgW0VWRU5UX1RBUkdFVCAmJiBFVkVOVF9UQVJHRVQucHJvdG90eXBlXSk7XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBwYXRjaEV2ZW50KGdsb2JhbCwgYXBpKSB7XG4gICAgYXBpLnBhdGNoRXZlbnRQcm90b3R5cGUoZ2xvYmFsLCBhcGkpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgR29vZ2xlIExMQyBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vYW5ndWxhci5pby9saWNlbnNlXG4gKi9cblpvbmUuX19sb2FkX3BhdGNoKCdsZWdhY3knLCAoZ2xvYmFsKSA9PiB7XG4gICAgY29uc3QgbGVnYWN5UGF0Y2ggPSBnbG9iYWxbWm9uZS5fX3N5bWJvbF9fKCdsZWdhY3lQYXRjaCcpXTtcbiAgICBpZiAobGVnYWN5UGF0Y2gpIHtcbiAgICAgICAgbGVnYWN5UGF0Y2goKTtcbiAgICB9XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdxdWV1ZU1pY3JvdGFzaycsIChnbG9iYWwsIFpvbmUsIGFwaSkgPT4ge1xuICAgIGFwaS5wYXRjaE1ldGhvZChnbG9iYWwsICdxdWV1ZU1pY3JvdGFzaycsIGRlbGVnYXRlID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBab25lLmN1cnJlbnQuc2NoZWR1bGVNaWNyb1Rhc2soJ3F1ZXVlTWljcm90YXNrJywgYXJnc1swXSk7XG4gICAgICAgIH07XG4gICAgfSk7XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCd0aW1lcnMnLCAoZ2xvYmFsKSA9PiB7XG4gICAgY29uc3Qgc2V0ID0gJ3NldCc7XG4gICAgY29uc3QgY2xlYXIgPSAnY2xlYXInO1xuICAgIHBhdGNoVGltZXIoZ2xvYmFsLCBzZXQsIGNsZWFyLCAnVGltZW91dCcpO1xuICAgIHBhdGNoVGltZXIoZ2xvYmFsLCBzZXQsIGNsZWFyLCAnSW50ZXJ2YWwnKTtcbiAgICBwYXRjaFRpbWVyKGdsb2JhbCwgc2V0LCBjbGVhciwgJ0ltbWVkaWF0ZScpO1xufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgncmVxdWVzdEFuaW1hdGlvbkZyYW1lJywgKGdsb2JhbCkgPT4ge1xuICAgIHBhdGNoVGltZXIoZ2xvYmFsLCAncmVxdWVzdCcsICdjYW5jZWwnLCAnQW5pbWF0aW9uRnJhbWUnKTtcbiAgICBwYXRjaFRpbWVyKGdsb2JhbCwgJ21velJlcXVlc3QnLCAnbW96Q2FuY2VsJywgJ0FuaW1hdGlvbkZyYW1lJyk7XG4gICAgcGF0Y2hUaW1lcihnbG9iYWwsICd3ZWJraXRSZXF1ZXN0JywgJ3dlYmtpdENhbmNlbCcsICdBbmltYXRpb25GcmFtZScpO1xufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnYmxvY2tpbmcnLCAoZ2xvYmFsLCBab25lKSA9PiB7XG4gICAgY29uc3QgYmxvY2tpbmdNZXRob2RzID0gWydhbGVydCcsICdwcm9tcHQnLCAnY29uZmlybSddO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2tpbmdNZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBibG9ja2luZ01ldGhvZHNbaV07XG4gICAgICAgIHBhdGNoTWV0aG9kKGdsb2JhbCwgbmFtZSwgKGRlbGVnYXRlLCBzeW1ib2wsIG5hbWUpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAocywgYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBab25lLmN1cnJlbnQucnVuKGRlbGVnYXRlLCBnbG9iYWwsIGFyZ3MsIG5hbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufSk7XG5ab25lLl9fbG9hZF9wYXRjaCgnRXZlbnRUYXJnZXQnLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBwYXRjaEV2ZW50KGdsb2JhbCwgYXBpKTtcbiAgICBldmVudFRhcmdldFBhdGNoKGdsb2JhbCwgYXBpKTtcbiAgICAvLyBwYXRjaCBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0J3MgYWRkRXZlbnRMaXN0ZW5lci9yZW1vdmVFdmVudExpc3RlbmVyXG4gICAgY29uc3QgWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCA9IGdsb2JhbFsnWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCddO1xuICAgIGlmIChYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ICYmIFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXQucHJvdG90eXBlKSB7XG4gICAgICAgIGFwaS5wYXRjaEV2ZW50VGFyZ2V0KGdsb2JhbCwgYXBpLCBbWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldC5wcm90b3R5cGVdKTtcbiAgICB9XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdNdXRhdGlvbk9ic2VydmVyJywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgcGF0Y2hDbGFzcygnTXV0YXRpb25PYnNlcnZlcicpO1xuICAgIHBhdGNoQ2xhc3MoJ1dlYktpdE11dGF0aW9uT2JzZXJ2ZXInKTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ0ludGVyc2VjdGlvbk9ic2VydmVyJywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgcGF0Y2hDbGFzcygnSW50ZXJzZWN0aW9uT2JzZXJ2ZXInKTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ0ZpbGVSZWFkZXInLCAoZ2xvYmFsLCBab25lLCBhcGkpID0+IHtcbiAgICBwYXRjaENsYXNzKCdGaWxlUmVhZGVyJyk7XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdvbl9wcm9wZXJ0eScsIChnbG9iYWwsIFpvbmUsIGFwaSkgPT4ge1xuICAgIHByb3BlcnR5RGVzY3JpcHRvclBhdGNoKGFwaSwgZ2xvYmFsKTtcbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ2N1c3RvbUVsZW1lbnRzJywgKGdsb2JhbCwgWm9uZSwgYXBpKSA9PiB7XG4gICAgcGF0Y2hDdXN0b21FbGVtZW50cyhnbG9iYWwsIGFwaSk7XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdYSFInLCAoZ2xvYmFsLCBab25lKSA9PiB7XG4gICAgLy8gVHJlYXQgWE1MSHR0cFJlcXVlc3QgYXMgYSBtYWNyb3Rhc2suXG4gICAgcGF0Y2hYSFIoZ2xvYmFsKTtcbiAgICBjb25zdCBYSFJfVEFTSyA9IHpvbmVTeW1ib2woJ3hoclRhc2snKTtcbiAgICBjb25zdCBYSFJfU1lOQyA9IHpvbmVTeW1ib2woJ3hoclN5bmMnKTtcbiAgICBjb25zdCBYSFJfTElTVEVORVIgPSB6b25lU3ltYm9sKCd4aHJMaXN0ZW5lcicpO1xuICAgIGNvbnN0IFhIUl9TQ0hFRFVMRUQgPSB6b25lU3ltYm9sKCd4aHJTY2hlZHVsZWQnKTtcbiAgICBjb25zdCBYSFJfVVJMID0gem9uZVN5bWJvbCgneGhyVVJMJyk7XG4gICAgY29uc3QgWEhSX0VSUk9SX0JFRk9SRV9TQ0hFRFVMRUQgPSB6b25lU3ltYm9sKCd4aHJFcnJvckJlZm9yZVNjaGVkdWxlZCcpO1xuICAgIGZ1bmN0aW9uIHBhdGNoWEhSKHdpbmRvdykge1xuICAgICAgICBjb25zdCBYTUxIdHRwUmVxdWVzdCA9IHdpbmRvd1snWE1MSHR0cFJlcXVlc3QnXTtcbiAgICAgICAgaWYgKCFYTUxIdHRwUmVxdWVzdCkge1xuICAgICAgICAgICAgLy8gWE1MSHR0cFJlcXVlc3QgaXMgbm90IGF2YWlsYWJsZSBpbiBzZXJ2aWNlIHdvcmtlclxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlID0gWE1MSHR0cFJlcXVlc3QucHJvdG90eXBlO1xuICAgICAgICBmdW5jdGlvbiBmaW5kUGVuZGluZ1Rhc2sodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0W1hIUl9UQVNLXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgb3JpQWRkTGlzdGVuZXIgPSBYTUxIdHRwUmVxdWVzdFByb3RvdHlwZVtaT05FX1NZTUJPTF9BRERfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICBsZXQgb3JpUmVtb3ZlTGlzdGVuZXIgPSBYTUxIdHRwUmVxdWVzdFByb3RvdHlwZVtaT05FX1NZTUJPTF9SRU1PVkVfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICBpZiAoIW9yaUFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0ID0gd2luZG93WydYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0J107XG4gICAgICAgICAgICBpZiAoWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXRQcm90b3R5cGUgPSBYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0LnByb3RvdHlwZTtcbiAgICAgICAgICAgICAgICBvcmlBZGRMaXN0ZW5lciA9IFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXRQcm90b3R5cGVbWk9ORV9TWU1CT0xfQUREX0VWRU5UX0xJU1RFTkVSXTtcbiAgICAgICAgICAgICAgICBvcmlSZW1vdmVMaXN0ZW5lciA9IFhNTEh0dHBSZXF1ZXN0RXZlbnRUYXJnZXRQcm90b3R5cGVbWk9ORV9TWU1CT0xfUkVNT1ZFX0VWRU5UX0xJU1RFTkVSXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBSRUFEWV9TVEFURV9DSEFOR0UgPSAncmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgICAgIGNvbnN0IFNDSEVEVUxFRCA9ICdzY2hlZHVsZWQnO1xuICAgICAgICBmdW5jdGlvbiBzY2hlZHVsZVRhc2sodGFzaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRhc2suZGF0YTtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGRhdGEudGFyZ2V0O1xuICAgICAgICAgICAgdGFyZ2V0W1hIUl9TQ0hFRFVMRURdID0gZmFsc2U7XG4gICAgICAgICAgICB0YXJnZXRbWEhSX0VSUk9SX0JFRk9SRV9TQ0hFRFVMRURdID0gZmFsc2U7XG4gICAgICAgICAgICAvLyByZW1vdmUgZXhpc3RpbmcgZXZlbnQgbGlzdGVuZXJcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyID0gdGFyZ2V0W1hIUl9MSVNURU5FUl07XG4gICAgICAgICAgICBpZiAoIW9yaUFkZExpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgb3JpQWRkTGlzdGVuZXIgPSB0YXJnZXRbWk9ORV9TWU1CT0xfQUREX0VWRU5UX0xJU1RFTkVSXTtcbiAgICAgICAgICAgICAgICBvcmlSZW1vdmVMaXN0ZW5lciA9IHRhcmdldFtaT05FX1NZTUJPTF9SRU1PVkVfRVZFTlRfTElTVEVORVJdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgb3JpUmVtb3ZlTGlzdGVuZXIuY2FsbCh0YXJnZXQsIFJFQURZX1NUQVRFX0NIQU5HRSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbmV3TGlzdGVuZXIgPSB0YXJnZXRbWEhSX0xJU1RFTkVSXSA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnJlYWR5U3RhdGUgPT09IHRhcmdldC5ET05FKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWV0aW1lcyBvbiBzb21lIGJyb3dzZXJzIFhNTEh0dHBSZXF1ZXN0IHdpbGwgZmlyZSBvbnJlYWR5c3RhdGVjaGFuZ2Ugd2l0aFxuICAgICAgICAgICAgICAgICAgICAvLyByZWFkeVN0YXRlPTQgbXVsdGlwbGUgdGltZXMsIHNvIHdlIG5lZWQgdG8gY2hlY2sgdGFzayBzdGF0ZSBoZXJlXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5hYm9ydGVkICYmIHRhcmdldFtYSFJfU0NIRURVTEVEXSAmJiB0YXNrLnN0YXRlID09PSBTQ0hFRFVMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIHhociBoYXMgcmVnaXN0ZXJlZCBvbmxvYWQgbGlzdGVuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIHRoYXQgaXMgdGhlIGNhc2UsIHRoZSB0YXNrIHNob3VsZCBpbnZva2UgYWZ0ZXIgYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmxvYWQgbGlzdGVuZXJzIGZpbmlzaC5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsc28gaWYgdGhlIHJlcXVlc3QgZmFpbGVkIHdpdGhvdXQgcmVzcG9uc2UgKHN0YXR1cyA9IDApLCB0aGUgbG9hZCBldmVudCBoYW5kbGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aWxsIG5vdCBiZSB0cmlnZ2VyZWQsIGluIHRoYXQgY2FzZSwgd2Ugc2hvdWxkIGFsc28gaW52b2tlIHRoZSBwbGFjZWhvbGRlciBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdG8gY2xvc2UgdGhlIFhNTEh0dHBSZXF1ZXN0OjpzZW5kIG1hY3JvVGFzay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbmd1bGFyL2FuZ3VsYXIvaXNzdWVzLzM4Nzk1XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkVGFza3MgPSB0YXJnZXRbWm9uZS5fX3N5bWJvbF9fKCdsb2FkZmFsc2UnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LnN0YXR1cyAhPT0gMCAmJiBsb2FkVGFza3MgJiYgbG9hZFRhc2tzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcmlJbnZva2UgPSB0YXNrLmludm9rZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmludm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZCB0byBsb2FkIHRoZSB0YXNrcyBhZ2FpbiwgYmVjYXVzZSBpbiBvdGhlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBsb2FkIGxpc3RlbmVyLCB0aGV5IG1heSByZW1vdmUgdGhlbXNlbHZlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsb2FkVGFza3MgPSB0YXJnZXRbWm9uZS5fX3N5bWJvbF9fKCdsb2FkZmFsc2UnKV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9hZFRhc2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9hZFRhc2tzW2ldID09PSB0YXNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9hZFRhc2tzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuYWJvcnRlZCAmJiB0YXNrLnN0YXRlID09PSBTQ0hFRFVMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaUludm9rZS5jYWxsKHRhc2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2FkVGFza3MucHVzaCh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suaW52b2tlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRhdGEuYWJvcnRlZCAmJiB0YXJnZXRbWEhSX1NDSEVEVUxFRF0gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlcnJvciBvY2N1cnMgd2hlbiB4aHIuc2VuZCgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXRbWEhSX0VSUk9SX0JFRk9SRV9TQ0hFRFVMRURdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvcmlBZGRMaXN0ZW5lci5jYWxsKHRhcmdldCwgUkVBRFlfU1RBVEVfQ0hBTkdFLCBuZXdMaXN0ZW5lcik7XG4gICAgICAgICAgICBjb25zdCBzdG9yZWRUYXNrID0gdGFyZ2V0W1hIUl9UQVNLXTtcbiAgICAgICAgICAgIGlmICghc3RvcmVkVGFzaykge1xuICAgICAgICAgICAgICAgIHRhcmdldFtYSFJfVEFTS10gPSB0YXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VuZE5hdGl2ZS5hcHBseSh0YXJnZXQsIGRhdGEuYXJncyk7XG4gICAgICAgICAgICB0YXJnZXRbWEhSX1NDSEVEVUxFRF0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcGxhY2Vob2xkZXJDYWxsYmFjaygpIHsgfVxuICAgICAgICBmdW5jdGlvbiBjbGVhclRhc2sodGFzaykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRhc2suZGF0YTtcbiAgICAgICAgICAgIC8vIE5vdGUgLSBpZGVhbGx5LCB3ZSB3b3VsZCBjYWxsIGRhdGEudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIgaGVyZSwgYnV0IGl0J3MgdG9vIGxhdGVcbiAgICAgICAgICAgIC8vIHRvIHByZXZlbnQgaXQgZnJvbSBmaXJpbmcuIFNvIGluc3RlYWQsIHdlIHN0b3JlIGluZm8gZm9yIHRoZSBldmVudCBsaXN0ZW5lci5cbiAgICAgICAgICAgIGRhdGEuYWJvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gYWJvcnROYXRpdmUuYXBwbHkoZGF0YS50YXJnZXQsIGRhdGEuYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3Blbk5hdGl2ZSA9IHBhdGNoTWV0aG9kKFhNTEh0dHBSZXF1ZXN0UHJvdG90eXBlLCAnb3BlbicsICgpID0+IGZ1bmN0aW9uIChzZWxmLCBhcmdzKSB7XG4gICAgICAgICAgICBzZWxmW1hIUl9TWU5DXSA9IGFyZ3NbMl0gPT0gZmFsc2U7XG4gICAgICAgICAgICBzZWxmW1hIUl9VUkxdID0gYXJnc1sxXTtcbiAgICAgICAgICAgIHJldHVybiBvcGVuTmF0aXZlLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgWE1MSFRUUFJFUVVFU1RfU09VUkNFID0gJ1hNTEh0dHBSZXF1ZXN0LnNlbmQnO1xuICAgICAgICBjb25zdCBmZXRjaFRhc2tBYm9ydGluZyA9IHpvbmVTeW1ib2woJ2ZldGNoVGFza0Fib3J0aW5nJyk7XG4gICAgICAgIGNvbnN0IGZldGNoVGFza1NjaGVkdWxpbmcgPSB6b25lU3ltYm9sKCdmZXRjaFRhc2tTY2hlZHVsaW5nJyk7XG4gICAgICAgIGNvbnN0IHNlbmROYXRpdmUgPSBwYXRjaE1ldGhvZChYTUxIdHRwUmVxdWVzdFByb3RvdHlwZSwgJ3NlbmQnLCAoKSA9PiBmdW5jdGlvbiAoc2VsZiwgYXJncykge1xuICAgICAgICAgICAgaWYgKFpvbmUuY3VycmVudFtmZXRjaFRhc2tTY2hlZHVsaW5nXSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIC8vIGEgZmV0Y2ggaXMgc2NoZWR1bGluZywgc28gd2UgYXJlIHVzaW5nIHhociB0byBwb2x5ZmlsbCBmZXRjaFxuICAgICAgICAgICAgICAgIC8vIGFuZCBiZWNhdXNlIHdlIGFscmVhZHkgc2NoZWR1bGUgbWFjcm9UYXNrIGZvciBmZXRjaCwgd2Ugc2hvdWxkXG4gICAgICAgICAgICAgICAgLy8gbm90IHNjaGVkdWxlIGEgbWFjcm9UYXNrIGZvciB4aHIgYWdhaW5cbiAgICAgICAgICAgICAgICByZXR1cm4gc2VuZE5hdGl2ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmW1hIUl9TWU5DXSkge1xuICAgICAgICAgICAgICAgIC8vIGlmIHRoZSBYSFIgaXMgc3luYyB0aGVyZSBpcyBubyB0YXNrIHRvIHNjaGVkdWxlLCBqdXN0IGV4ZWN1dGUgdGhlIGNvZGUuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbmROYXRpdmUuYXBwbHkoc2VsZiwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyB0YXJnZXQ6IHNlbGYsIHVybDogc2VsZltYSFJfVVJMXSwgaXNQZXJpb2RpYzogZmFsc2UsIGFyZ3M6IGFyZ3MsIGFib3J0ZWQ6IGZhbHNlIH07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFzayA9IHNjaGVkdWxlTWFjcm9UYXNrV2l0aEN1cnJlbnRab25lKFhNTEhUVFBSRVFVRVNUX1NPVVJDRSwgcGxhY2Vob2xkZXJDYWxsYmFjaywgb3B0aW9ucywgc2NoZWR1bGVUYXNrLCBjbGVhclRhc2spO1xuICAgICAgICAgICAgICAgIGlmIChzZWxmICYmIHNlbGZbWEhSX0VSUk9SX0JFRk9SRV9TQ0hFRFVMRURdID09PSB0cnVlICYmICFvcHRpb25zLmFib3J0ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGFzay5zdGF0ZSA9PT0gU0NIRURVTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHhociByZXF1ZXN0IHRocm93IGVycm9yIHdoZW4gc2VuZFxuICAgICAgICAgICAgICAgICAgICAvLyB3ZSBzaG91bGQgaW52b2tlIHRhc2sgaW5zdGVhZCBvZiBsZWF2aW5nIGEgc2NoZWR1bGVkXG4gICAgICAgICAgICAgICAgICAgIC8vIHBlbmRpbmcgbWFjcm9UYXNrXG4gICAgICAgICAgICAgICAgICAgIHRhc2suaW52b2tlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYWJvcnROYXRpdmUgPSBwYXRjaE1ldGhvZChYTUxIdHRwUmVxdWVzdFByb3RvdHlwZSwgJ2Fib3J0JywgKCkgPT4gZnVuY3Rpb24gKHNlbGYsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhc2sgPSBmaW5kUGVuZGluZ1Rhc2soc2VsZik7XG4gICAgICAgICAgICBpZiAodGFzayAmJiB0eXBlb2YgdGFzay50eXBlID09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIFhIUiBoYXMgYWxyZWFkeSBjb21wbGV0ZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIFhIUiBoYXMgYWxyZWFkeSBiZWVuIGFib3J0ZWQsIGRvIG5vdGhpbmcuXG4gICAgICAgICAgICAgICAgLy8gRml4ICM1NjksIGNhbGwgYWJvcnQgbXVsdGlwbGUgdGltZXMgYmVmb3JlIGRvbmUgd2lsbCBjYXVzZVxuICAgICAgICAgICAgICAgIC8vIG1hY3JvVGFzayB0YXNrIGNvdW50IGJlIG5lZ2F0aXZlIG51bWJlclxuICAgICAgICAgICAgICAgIGlmICh0YXNrLmNhbmNlbEZuID09IG51bGwgfHwgKHRhc2suZGF0YSAmJiB0YXNrLmRhdGEuYWJvcnRlZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0YXNrLnpvbmUuY2FuY2VsVGFzayh0YXNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFpvbmUuY3VycmVudFtmZXRjaFRhc2tBYm9ydGluZ10gPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAvLyB0aGUgYWJvcnQgaXMgY2FsbGVkIGZyb20gZmV0Y2ggcG9seWZpbGwsIHdlIG5lZWQgdG8gY2FsbCBuYXRpdmUgYWJvcnQgb2YgWEhSLlxuICAgICAgICAgICAgICAgIHJldHVybiBhYm9ydE5hdGl2ZS5hcHBseShzZWxmLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE90aGVyd2lzZSwgd2UgYXJlIHRyeWluZyB0byBhYm9ydCBhbiBYSFIgd2hpY2ggaGFzIG5vdCB5ZXQgYmVlbiBzZW50LCBzbyB0aGVyZSBpcyBub1xuICAgICAgICAgICAgLy8gdGFza1xuICAgICAgICAgICAgLy8gdG8gY2FuY2VsLiBEbyBub3RoaW5nLlxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblpvbmUuX19sb2FkX3BhdGNoKCdnZW9sb2NhdGlvbicsIChnbG9iYWwpID0+IHtcbiAgICAvLy8gR0VPX0xPQ0FUSU9OXG4gICAgaWYgKGdsb2JhbFsnbmF2aWdhdG9yJ10gJiYgZ2xvYmFsWyduYXZpZ2F0b3InXS5nZW9sb2NhdGlvbikge1xuICAgICAgICBwYXRjaFByb3RvdHlwZShnbG9iYWxbJ25hdmlnYXRvciddLmdlb2xvY2F0aW9uLCBbJ2dldEN1cnJlbnRQb3NpdGlvbicsICd3YXRjaFBvc2l0aW9uJ10pO1xuICAgIH1cbn0pO1xuWm9uZS5fX2xvYWRfcGF0Y2goJ1Byb21pc2VSZWplY3Rpb25FdmVudCcsIChnbG9iYWwsIFpvbmUpID0+IHtcbiAgICAvLyBoYW5kbGUgdW5oYW5kbGVkIHByb21pc2UgcmVqZWN0aW9uXG4gICAgZnVuY3Rpb24gZmluZFByb21pc2VSZWplY3Rpb25IYW5kbGVyKGV2dE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBjb25zdCBldmVudFRhc2tzID0gZmluZEV2ZW50VGFza3MoZ2xvYmFsLCBldnROYW1lKTtcbiAgICAgICAgICAgIGV2ZW50VGFza3MuZm9yRWFjaChldmVudFRhc2sgPT4ge1xuICAgICAgICAgICAgICAgIC8vIHdpbmRvd3MgaGFzIGFkZGVkIHVuaGFuZGxlZHJlamVjdGlvbiBldmVudCBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIC8vIHRyaWdnZXIgdGhlIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgICAgICAgICAgY29uc3QgUHJvbWlzZVJlamVjdGlvbkV2ZW50ID0gZ2xvYmFsWydQcm9taXNlUmVqZWN0aW9uRXZlbnQnXTtcbiAgICAgICAgICAgICAgICBpZiAoUHJvbWlzZVJlamVjdGlvbkV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV2dCA9IG5ldyBQcm9taXNlUmVqZWN0aW9uRXZlbnQoZXZ0TmFtZSwgeyBwcm9taXNlOiBlLnByb21pc2UsIHJlYXNvbjogZS5yZWplY3Rpb24gfSk7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50VGFzay5pbnZva2UoZXZ0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGdsb2JhbFsnUHJvbWlzZVJlamVjdGlvbkV2ZW50J10pIHtcbiAgICAgICAgWm9uZVt6b25lU3ltYm9sKCd1bmhhbmRsZWRQcm9taXNlUmVqZWN0aW9uSGFuZGxlcicpXSA9XG4gICAgICAgICAgICBmaW5kUHJvbWlzZVJlamVjdGlvbkhhbmRsZXIoJ3VuaGFuZGxlZHJlamVjdGlvbicpO1xuICAgICAgICBab25lW3pvbmVTeW1ib2woJ3JlamVjdGlvbkhhbmRsZWRIYW5kbGVyJyldID1cbiAgICAgICAgICAgIGZpbmRQcm9taXNlUmVqZWN0aW9uSGFuZGxlcigncmVqZWN0aW9uaGFuZGxlZCcpO1xuICAgIH1cbn0pO1xuIl0sIm5hbWVzIjpbImdsb2JhbCIsInBlcmZvcm1hbmNlIiwibWFyayIsIm5hbWUiLCJwZXJmb3JtYW5jZU1lYXN1cmUiLCJsYWJlbCIsInN5bWJvbFByZWZpeCIsIl9fc3ltYm9sX18iLCJjaGVja0R1cGxpY2F0ZSIsIkVycm9yIiwiWm9uZSIsImNvbnN0cnVjdG9yIiwicGFyZW50Iiwiem9uZVNwZWMiLCJfcGFyZW50IiwiX25hbWUiLCJfcHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJfem9uZURlbGVnYXRlIiwiX1pvbmVEZWxlZ2F0ZSIsImFzc2VydFpvbmVQYXRjaGVkIiwicGF0Y2hlcyIsInJvb3QiLCJ6b25lIiwiY3VycmVudCIsIl9jdXJyZW50Wm9uZUZyYW1lIiwiY3VycmVudFRhc2siLCJfY3VycmVudFRhc2siLCJfX2xvYWRfcGF0Y2giLCJmbiIsImlnbm9yZUR1cGxpY2F0ZSIsImhhc093blByb3BlcnR5IiwicGVyZk5hbWUiLCJfYXBpIiwiZ2V0Iiwia2V5IiwiZ2V0Wm9uZVdpdGgiLCJmb3JrIiwid3JhcCIsImNhbGxiYWNrIiwic291cmNlIiwiX2NhbGxiYWNrIiwiaW50ZXJjZXB0IiwicnVuR3VhcmRlZCIsImFyZ3VtZW50cyIsInJ1biIsImFwcGx5VGhpcyIsImFwcGx5QXJncyIsImludm9rZSIsImVycm9yIiwiaGFuZGxlRXJyb3IiLCJydW5UYXNrIiwidGFzayIsIk5PX1pPTkUiLCJzdGF0ZSIsIm5vdFNjaGVkdWxlZCIsInR5cGUiLCJldmVudFRhc2siLCJtYWNyb1Rhc2siLCJyZUVudHJ5R3VhcmQiLCJydW5uaW5nIiwiX3RyYW5zaXRpb25UbyIsInNjaGVkdWxlZCIsInJ1bkNvdW50IiwicHJldmlvdXNUYXNrIiwiZGF0YSIsImlzUGVyaW9kaWMiLCJjYW5jZWxGbiIsInVuZGVmaW5lZCIsImludm9rZVRhc2siLCJ1bmtub3duIiwiX3VwZGF0ZVRhc2tDb3VudCIsInNjaGVkdWxlVGFzayIsIm5ld1pvbmUiLCJzY2hlZHVsaW5nIiwiem9uZURlbGVnYXRlcyIsIl96b25lRGVsZWdhdGVzIiwiX3pvbmUiLCJlcnIiLCJzY2hlZHVsZU1pY3JvVGFzayIsImN1c3RvbVNjaGVkdWxlIiwiWm9uZVRhc2siLCJtaWNyb1Rhc2siLCJzY2hlZHVsZU1hY3JvVGFzayIsImN1c3RvbUNhbmNlbCIsInNjaGVkdWxlRXZlbnRUYXNrIiwiY2FuY2VsVGFzayIsImNhbmNlbGluZyIsImNvdW50IiwiaSIsImxlbmd0aCIsIkRFTEVHQVRFX1pTIiwib25IYXNUYXNrIiwiZGVsZWdhdGUiLCJfIiwidGFyZ2V0IiwiaGFzVGFza1N0YXRlIiwiaGFzVGFzayIsIm9uU2NoZWR1bGVUYXNrIiwib25JbnZva2VUYXNrIiwib25DYW5jZWxUYXNrIiwicGFyZW50RGVsZWdhdGUiLCJfdGFza0NvdW50cyIsIl9wYXJlbnREZWxlZ2F0ZSIsIl9mb3JrWlMiLCJvbkZvcmsiLCJfZm9ya0RsZ3QiLCJfZm9ya0N1cnJab25lIiwiX2ludGVyY2VwdFpTIiwib25JbnRlcmNlcHQiLCJfaW50ZXJjZXB0RGxndCIsIl9pbnRlcmNlcHRDdXJyWm9uZSIsIl9pbnZva2VaUyIsIm9uSW52b2tlIiwiX2ludm9rZURsZ3QiLCJfaW52b2tlQ3VyclpvbmUiLCJfaGFuZGxlRXJyb3JaUyIsIm9uSGFuZGxlRXJyb3IiLCJfaGFuZGxlRXJyb3JEbGd0IiwiX2hhbmRsZUVycm9yQ3VyclpvbmUiLCJfc2NoZWR1bGVUYXNrWlMiLCJfc2NoZWR1bGVUYXNrRGxndCIsIl9zY2hlZHVsZVRhc2tDdXJyWm9uZSIsIl9pbnZva2VUYXNrWlMiLCJfaW52b2tlVGFza0RsZ3QiLCJfaW52b2tlVGFza0N1cnJab25lIiwiX2NhbmNlbFRhc2taUyIsIl9jYW5jZWxUYXNrRGxndCIsIl9jYW5jZWxUYXNrQ3VyclpvbmUiLCJfaGFzVGFza1pTIiwiX2hhc1Rhc2tEbGd0IiwiX2hhc1Rhc2tEbGd0T3duZXIiLCJfaGFzVGFza0N1cnJab25lIiwiem9uZVNwZWNIYXNUYXNrIiwicGFyZW50SGFzVGFzayIsInRhcmdldFpvbmUiLCJhcHBseSIsInJldHVyblRhc2siLCJwdXNoIiwic2NoZWR1bGVGbiIsInZhbHVlIiwiaXNFbXB0eSIsImNvdW50cyIsInByZXYiLCJuZXh0IiwiY2hhbmdlIiwib3B0aW9ucyIsIl9zdGF0ZSIsInNlbGYiLCJ1c2VHIiwiY2FsbCIsImFyZ3MiLCJfbnVtYmVyT2ZOZXN0ZWRUYXNrRnJhbWVzIiwiZHJhaW5NaWNyb1Rhc2tRdWV1ZSIsImNhbmNlbFNjaGVkdWxlUmVxdWVzdCIsInRvU3RhdGUiLCJmcm9tU3RhdGUxIiwiZnJvbVN0YXRlMiIsInRvU3RyaW5nIiwiaGFuZGxlSWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b0pTT04iLCJzeW1ib2xTZXRUaW1lb3V0Iiwic3ltYm9sUHJvbWlzZSIsInN5bWJvbFRoZW4iLCJfbWljcm9UYXNrUXVldWUiLCJfaXNEcmFpbmluZ01pY3JvdGFza1F1ZXVlIiwibmF0aXZlTWljcm9UYXNrUXVldWVQcm9taXNlIiwibmF0aXZlU2NoZWR1bGVNaWNyb1Rhc2siLCJmdW5jIiwicmVzb2x2ZSIsIm5hdGl2ZVRoZW4iLCJxdWV1ZSIsIm9uVW5oYW5kbGVkRXJyb3IiLCJtaWNyb3Rhc2tEcmFpbkRvbmUiLCJzeW1ib2wiLCJjdXJyZW50Wm9uZUZyYW1lIiwibm9vcCIsInNob3dVbmNhdWdodEVycm9yIiwicGF0Y2hFdmVudFRhcmdldCIsInBhdGNoT25Qcm9wZXJ0aWVzIiwicGF0Y2hNZXRob2QiLCJiaW5kQXJndW1lbnRzIiwicGF0Y2hUaGVuIiwicGF0Y2hNYWNyb1Rhc2siLCJwYXRjaEV2ZW50UHJvdG90eXBlIiwiaXNJRU9yRWRnZSIsImdldEdsb2JhbE9iamVjdHMiLCJPYmplY3REZWZpbmVQcm9wZXJ0eSIsIk9iamVjdEdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIk9iamVjdENyZWF0ZSIsIkFycmF5U2xpY2UiLCJwYXRjaENsYXNzIiwid3JhcFdpdGhDdXJyZW50Wm9uZSIsImZpbHRlclByb3BlcnRpZXMiLCJhdHRhY2hPcmlnaW5Ub1BhdGNoZWQiLCJfcmVkZWZpbmVQcm9wZXJ0eSIsInBhdGNoQ2FsbGJhY2tzIiwid2luZG93IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydHkiLCJPYmplY3RHZXRQcm90b3R5cGVPZiIsImdldFByb3RvdHlwZU9mIiwiY3JlYXRlIiwiQXJyYXkiLCJzbGljZSIsIkFERF9FVkVOVF9MSVNURU5FUl9TVFIiLCJSRU1PVkVfRVZFTlRfTElTVEVORVJfU1RSIiwiWk9ORV9TWU1CT0xfQUREX0VWRU5UX0xJU1RFTkVSIiwiWk9ORV9TWU1CT0xfUkVNT1ZFX0VWRU5UX0xJU1RFTkVSIiwiVFJVRV9TVFIiLCJGQUxTRV9TVFIiLCJaT05FX1NZTUJPTF9QUkVGSVgiLCJzY2hlZHVsZU1hY3JvVGFza1dpdGhDdXJyZW50Wm9uZSIsInpvbmVTeW1ib2wiLCJpc1dpbmRvd0V4aXN0cyIsImludGVybmFsV2luZG93IiwiX2dsb2JhbCIsIlJFTU9WRV9BVFRSSUJVVEUiLCJwYXRjaFByb3RvdHlwZSIsImZuTmFtZXMiLCJwcm90b3R5cGVEZXNjIiwiaXNQcm9wZXJ0eVdyaXRhYmxlIiwicGF0Y2hlZCIsInByb3BlcnR5RGVzYyIsIndyaXRhYmxlIiwic2V0IiwiaXNXZWJXb3JrZXIiLCJXb3JrZXJHbG9iYWxTY29wZSIsImlzTm9kZSIsInByb2Nlc3MiLCJpc0Jyb3dzZXIiLCJpc01peCIsInpvbmVTeW1ib2xFdmVudE5hbWVzJDEiLCJ3cmFwRm4iLCJldmVudCIsImV2ZW50TmFtZVN5bWJvbCIsImxpc3RlbmVyIiwicmVzdWx0IiwiZXJyb3JFdmVudCIsIm1lc3NhZ2UiLCJmaWxlbmFtZSIsImxpbmVubyIsImNvbG5vIiwicHJldmVudERlZmF1bHQiLCJwYXRjaFByb3BlcnR5Iiwib2JqIiwicHJvcCIsImRlc2MiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwib25Qcm9wUGF0Y2hlZFN5bWJvbCIsIm9yaWdpbmFsRGVzY0dldCIsIm9yaWdpbmFsRGVzY1NldCIsImV2ZW50TmFtZSIsIm5ld1ZhbHVlIiwicHJldmlvdXNWYWx1ZSIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlQXR0cmlidXRlIiwib25Qcm9wZXJ0aWVzIiwiaiIsIm9yaWdpbmFsSW5zdGFuY2VLZXkiLCJjbGFzc05hbWUiLCJPcmlnaW5hbENsYXNzIiwiYSIsImluc3RhbmNlIiwicGF0Y2hGbiIsInByb3RvIiwiZGVsZWdhdGVOYW1lIiwicGF0Y2hEZWxlZ2F0ZSIsImZ1bmNOYW1lIiwibWV0YUNyZWF0b3IiLCJzZXROYXRpdmUiLCJjYklkeCIsIm1ldGEiLCJvcmlnaW5hbCIsImlzRGV0ZWN0ZWRJRU9yRWRnZSIsImllT3JFZGdlIiwiaXNJRSIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwiaW5kZXhPZiIsImFwaSIsInJlYWRhYmxlT2JqZWN0VG9TdHJpbmciLCJKU09OIiwic3RyaW5naWZ5IiwiX3VuY2F1Z2h0UHJvbWlzZUVycm9ycyIsImlzRGlzYWJsZVdyYXBwaW5nVW5jYXVnaHRQcm9taXNlUmVqZWN0aW9uIiwiY3JlYXRpb25UcmFjZSIsImUiLCJyZWplY3Rpb24iLCJjb25zb2xlIiwic3RhY2siLCJ1bmNhdWdodFByb21pc2VFcnJvciIsInNoaWZ0IiwidGhyb3dPcmlnaW5hbCIsImhhbmRsZVVuaGFuZGxlZFJlamVjdGlvbiIsIlVOSEFORExFRF9QUk9NSVNFX1JFSkVDVElPTl9IQU5ETEVSX1NZTUJPTCIsImhhbmRsZXIiLCJpc1RoZW5hYmxlIiwidGhlbiIsImZvcndhcmRSZXNvbHV0aW9uIiwiZm9yd2FyZFJlamVjdGlvbiIsIlpvbmVBd2FyZVByb21pc2UiLCJyZWplY3QiLCJzeW1ib2xTdGF0ZSIsInN5bWJvbFZhbHVlIiwic3ltYm9sRmluYWxseSIsInN5bWJvbFBhcmVudFByb21pc2VWYWx1ZSIsInN5bWJvbFBhcmVudFByb21pc2VTdGF0ZSIsIlVOUkVTT0xWRUQiLCJSRVNPTFZFRCIsIlJFSkVDVEVEIiwiUkVKRUNURURfTk9fQ0FUQ0giLCJtYWtlUmVzb2x2ZXIiLCJwcm9taXNlIiwidiIsInJlc29sdmVQcm9taXNlIiwib25jZSIsIndhc0NhbGxlZCIsIndyYXBwZXIiLCJ3cmFwcGVkRnVuY3Rpb24iLCJUWVBFX0VSUk9SIiwiQ1VSUkVOVF9UQVNLX1RSQUNFX1NZTUJPTCIsIm9uY2VXcmFwcGVyIiwiVHlwZUVycm9yIiwiY2xlYXJSZWplY3RlZE5vQ2F0Y2giLCJ0cmFjZSIsInNjaGVkdWxlUmVzb2x2ZU9yUmVqZWN0IiwiUkVKRUNUSU9OX0hBTkRMRURfSEFORExFUiIsInNwbGljZSIsImNoYWluUHJvbWlzZSIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsInByb21pc2VTdGF0ZSIsInBhcmVudFByb21pc2VWYWx1ZSIsImlzRmluYWxseVByb21pc2UiLCJaT05FX0FXQVJFX1BST01JU0VfVE9fU1RSSU5HIiwiQWdncmVnYXRlRXJyb3IiLCJhbnkiLCJ2YWx1ZXMiLCJTeW1ib2wiLCJpdGVyYXRvciIsIlByb21pc2UiLCJwcm9taXNlcyIsImZpbmlzaGVkIiwiZXJyb3JzIiwicmFjZSIsInJlcyIsInJlaiIsIm9uUmVzb2x2ZSIsIm9uUmVqZWN0IiwiYWxsIiwiYWxsV2l0aENhbGxiYWNrIiwiYWxsU2V0dGxlZCIsIlAiLCJ0aGVuQ2FsbGJhY2siLCJzdGF0dXMiLCJlcnJvckNhbGxiYWNrIiwicmVhc29uIiwidW5yZXNvbHZlZENvdW50IiwidmFsdWVJbmRleCIsInJlc29sdmVkVmFsdWVzIiwiY3VyVmFsdWVJbmRleCIsInRoZW5FcnIiLCJleGVjdXRvciIsInRvU3RyaW5nVGFnIiwic3BlY2llcyIsIl9hIiwiQyIsImNhdGNoIiwiZmluYWxseSIsIm9uRmluYWxseSIsIk5hdGl2ZVByb21pc2UiLCJzeW1ib2xUaGVuUGF0Y2hlZCIsIkN0b3IiLCJvcmlnaW5hbFRoZW4iLCJ3cmFwcGVkIiwiem9uZWlmeSIsInJlc3VsdFByb21pc2UiLCJjdG9yIiwib3JpZ2luYWxGdW5jdGlvblRvU3RyaW5nIiwiRnVuY3Rpb24iLCJPUklHSU5BTF9ERUxFR0FURV9TWU1CT0wiLCJQUk9NSVNFX1NZTUJPTCIsIkVSUk9SX1NZTUJPTCIsIm5ld0Z1bmN0aW9uVG9TdHJpbmciLCJvcmlnaW5hbERlbGVnYXRlIiwibmF0aXZlUHJvbWlzZSIsIm5hdGl2ZUVycm9yIiwib3JpZ2luYWxPYmplY3RUb1N0cmluZyIsIlBST01JU0VfT0JKRUNUX1RPX1NUUklORyIsInBhc3NpdmVTdXBwb3J0ZWQiLCJPUFRJTUlaRURfWk9ORV9FVkVOVF9UQVNLX0RBVEEiLCJ6b25lU3ltYm9sRXZlbnROYW1lcyIsImdsb2JhbFNvdXJjZXMiLCJFVkVOVF9OQU1FX1NZTUJPTF9SRUdYIiwiUmVnRXhwIiwiSU1NRURJQVRFX1BST1BBR0FUSU9OX1NZTUJPTCIsInByZXBhcmVFdmVudE5hbWVzIiwiZXZlbnROYW1lVG9TdHJpbmciLCJmYWxzZUV2ZW50TmFtZSIsInRydWVFdmVudE5hbWUiLCJzeW1ib2xDYXB0dXJlIiwiYXBpcyIsInBhdGNoT3B0aW9ucyIsIkFERF9FVkVOVF9MSVNURU5FUiIsImFkZCIsIlJFTU9WRV9FVkVOVF9MSVNURU5FUiIsInJtIiwiTElTVEVORVJTX0VWRU5UX0xJU1RFTkVSIiwibGlzdGVuZXJzIiwiUkVNT1ZFX0FMTF9MSVNURU5FUlNfRVZFTlRfTElTVEVORVIiLCJybUFsbCIsInpvbmVTeW1ib2xBZGRFdmVudExpc3RlbmVyIiwiQUREX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSIsIlBSRVBFTkRfRVZFTlRfTElTVEVORVIiLCJQUkVQRU5EX0VWRU5UX0xJU1RFTkVSX1NPVVJDRSIsImlzUmVtb3ZlZCIsImhhbmRsZUV2ZW50IiwiZ2xvYmFsQ2FsbGJhY2siLCJjb250ZXh0IiwiaXNDYXB0dXJlIiwidGFza3MiLCJjb3B5VGFza3MiLCJnbG9iYWxab25lQXdhcmVDYWxsYmFjayIsImdsb2JhbFpvbmVBd2FyZUNhcHR1cmVDYWxsYmFjayIsInBhdGNoRXZlbnRUYXJnZXRNZXRob2RzIiwidXNlR2xvYmFsQ2FsbGJhY2siLCJ2YWxpZGF0ZUhhbmRsZXIiLCJ2aCIsImNoa0R1cCIsInJldHVyblRhcmdldCIsInJ0IiwidGFza0RhdGEiLCJuYXRpdmVBZGRFdmVudExpc3RlbmVyIiwibmF0aXZlUmVtb3ZlRXZlbnRMaXN0ZW5lciIsIm5hdGl2ZUxpc3RlbmVycyIsIm5hdGl2ZVJlbW92ZUFsbExpc3RlbmVycyIsIm5hdGl2ZVByZXBlbmRFdmVudExpc3RlbmVyIiwicHJlcGVuZCIsImJ1aWxkRXZlbnRMaXN0ZW5lck9wdGlvbnMiLCJwYXNzaXZlIiwiY2FwdHVyZSIsImFzc2lnbiIsImN1c3RvbVNjaGVkdWxlR2xvYmFsIiwiaXNFeGlzdGluZyIsImN1c3RvbUNhbmNlbEdsb2JhbCIsInN5bWJvbEV2ZW50TmFtZXMiLCJzeW1ib2xFdmVudE5hbWUiLCJleGlzdGluZ1Rhc2tzIiwiZXhpc3RpbmdUYXNrIiwiYWxsUmVtb3ZlZCIsImN1c3RvbVNjaGVkdWxlTm9uR2xvYmFsIiwiY3VzdG9tU2NoZWR1bGVQcmVwZW5kIiwiY3VzdG9tQ2FuY2VsTm9uR2xvYmFsIiwiY29tcGFyZVRhc2tDYWxsYmFja1ZzRGVsZWdhdGUiLCJ0eXBlT2ZEZWxlZ2F0ZSIsImNvbXBhcmUiLCJkaWZmIiwidW5wYXRjaGVkRXZlbnRzIiwicGFzc2l2ZUV2ZW50cyIsIm1ha2VBZGRMaXN0ZW5lciIsIm5hdGl2ZUxpc3RlbmVyIiwiYWRkU291cmNlIiwiY3VzdG9tU2NoZWR1bGVGbiIsImN1c3RvbUNhbmNlbEZuIiwidHJhbnNmZXJFdmVudE5hbWUiLCJpc0hhbmRsZUV2ZW50IiwiY29uc3RydWN0b3JOYW1lIiwidGFyZ2V0U291cmNlIiwidW5zaGlmdCIsIm9uUHJvcGVydHlTeW1ib2wiLCJmaW5kRXZlbnRUYXNrcyIsImtleXMiLCJtYXRjaCIsImV4ZWMiLCJldnROYW1lIiwic3ltYm9sQ2FwdHVyZUV2ZW50TmFtZSIsImNhcHR1cmVUYXNrcyIsInJlbW92ZVRhc2tzIiwicmVzdWx0cyIsImZvdW5kVGFza3MiLCJjYXB0dXJlRmFsc2VUYXNrcyIsImNhcHR1cmVUcnVlVGFza3MiLCJjb25jYXQiLCJFdmVudCIsInRhcmdldE5hbWUiLCJtZXRob2QiLCJjYWxsYmFja3MiLCJuYXRpdmVEZWxlZ2F0ZSIsIm9wdHMiLCJmb3JFYWNoIiwiZGVzY3JpcHRvciIsImlnbm9yZVByb3BlcnRpZXMiLCJ0aXAiLCJmaWx0ZXIiLCJpcCIsInRhcmdldElnbm9yZVByb3BlcnRpZXMiLCJvcCIsInBhdGNoRmlsdGVyZWRQcm9wZXJ0aWVzIiwiZmlsdGVyZWRQcm9wZXJ0aWVzIiwiZ2V0T25FdmVudE5hbWVzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsInN0YXJ0c1dpdGgiLCJtYXAiLCJzdWJzdHJpbmciLCJwcm9wZXJ0eURlc2NyaXB0b3JQYXRjaCIsInBhdGNoVGFyZ2V0cyIsImlnbm9yZUVycm9yUHJvcGVydGllcyIsImV2ZW50TmFtZXMiLCJTWU1CT0xfQkxBQ0tfTElTVEVEX0VWRU5UUyIsIlNZTUJPTF9VTlBBVENIRURfRVZFTlRTIiwidGFza1N5bWJvbCIsInBhdGNoVGltZXIiLCJzZXROYW1lIiwiY2FuY2VsTmFtZSIsIm5hbWVTdWZmaXgiLCJjbGVhck5hdGl2ZSIsInRhc2tzQnlIYW5kbGVJZCIsImNsZWFyVGFzayIsImRlbGF5IiwidGltZXIiLCJoYW5kbGUiLCJyZWYiLCJ1bnJlZiIsImJpbmQiLCJpZCIsInBhdGNoQ3VzdG9tRWxlbWVudHMiLCJjdXN0b21FbGVtZW50cyIsImV2ZW50VGFyZ2V0UGF0Y2giLCJFVkVOVF9UQVJHRVQiLCJwYXRjaEV2ZW50IiwibGVnYWN5UGF0Y2giLCJjbGVhciIsImJsb2NraW5nTWV0aG9kcyIsInMiLCJYTUxIdHRwUmVxdWVzdEV2ZW50VGFyZ2V0IiwicGF0Y2hYSFIiLCJYSFJfVEFTSyIsIlhIUl9TWU5DIiwiWEhSX0xJU1RFTkVSIiwiWEhSX1NDSEVEVUxFRCIsIlhIUl9VUkwiLCJYSFJfRVJST1JfQkVGT1JFX1NDSEVEVUxFRCIsIlhNTEh0dHBSZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3RQcm90b3R5cGUiLCJmaW5kUGVuZGluZ1Rhc2siLCJvcmlBZGRMaXN0ZW5lciIsIm9yaVJlbW92ZUxpc3RlbmVyIiwiWE1MSHR0cFJlcXVlc3RFdmVudFRhcmdldFByb3RvdHlwZSIsIlJFQURZX1NUQVRFX0NIQU5HRSIsIlNDSEVEVUxFRCIsIm5ld0xpc3RlbmVyIiwicmVhZHlTdGF0ZSIsIkRPTkUiLCJhYm9ydGVkIiwibG9hZFRhc2tzIiwib3JpSW52b2tlIiwic3RvcmVkVGFzayIsInNlbmROYXRpdmUiLCJwbGFjZWhvbGRlckNhbGxiYWNrIiwiYWJvcnROYXRpdmUiLCJvcGVuTmF0aXZlIiwiWE1MSFRUUFJFUVVFU1RfU09VUkNFIiwiZmV0Y2hUYXNrQWJvcnRpbmciLCJmZXRjaFRhc2tTY2hlZHVsaW5nIiwidXJsIiwiZ2VvbG9jYXRpb24iLCJmaW5kUHJvbWlzZVJlamVjdGlvbkhhbmRsZXIiLCJldmVudFRhc2tzIiwiUHJvbWlzZVJlamVjdGlvbkV2ZW50IiwiZXZ0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///583\n"))}},I=>{I(I.s=435)}]);